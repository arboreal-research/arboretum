use anyhow::Result;
use arrow::record_batch::RecordBatch;
use arrow::datatypes::{Schema, Field, DataType};
use parquet::arrow::AsyncArrowWriter;
use tokio::fs::File;
use std::sync::Arc;
use crate::ffi::*;
use std::path::{PathBuf, Path};

struct ParquetWriter {
    row_count: usize,
    partition_size: usize,
    partition_counter: usize,
    output_path: PathBuf,
    schema: Arc<Schema>,
}

impl ParquetWriter {
    pub fn new(output_path: impl AsRef<Path>, partition_size: usize, schema: Arc<Schema>) -> Self {
        Self {
            row_count: 0,
            partition_size,
            partition_counter: 0,
            output_path: output_path.as_ref().to_path_buf(),
            schema,
        }
    }

    pub fn should_flush(&self) -> bool {
        self.row_count >= self.partition_size
    }

    pub fn add_row(&mut self) -> bool {
        self.row_count += 1;
        self.should_flush()
    }

    pub async fn flush(&mut self, batch: RecordBatch) -> Result<()> {
        if self.row_count == 0 {
            return Ok(());
        }

        let path = self.output_path.with_extension(format!("{}.parquet", self.partition_counter));
        let file = File::create(path).await?;
        let mut writer = AsyncArrowWriter::try_new(file, self.schema.clone(), None)?;

        writer.write(&batch).await?;
        writer.close().await?;

        self.row_count = 0;
        self.partition_counter += 1;

        Ok(())
    }

    pub async fn cancel(&mut self) -> Result<()> {
      for partition in 0..self.partition_counter {
        let path = self.output_path.with_extension(format!("{}.parquet", partition));
          let _ = tokio::fs::remove_file(path).await;
      }
      Ok(())
    }
}


//// BEGIN ARBORETUM GENERATED CODE ////
pub struct TableBuilders {
  t0: TableBuilder0,
  t1: TableBuilder1,
  t2: TableBuilder2,
  t3: TableBuilder3,
  t4: TableBuilder4,
  t5: TableBuilder5,
  t6: TableBuilder6,
  t7: TableBuilder7,
  t8: TableBuilder8,
  t9: TableBuilder9,
  t10: TableBuilder10,
  t11: TableBuilder11,
  t12: TableBuilder12,
  t13: TableBuilder13,
  t14: TableBuilder14,
  t15: TableBuilder15,
  t16: TableBuilder16,
  t17: TableBuilder17,
  t18: TableBuilder18,
  t19: TableBuilder19,
  t20: TableBuilder20,
  t21: TableBuilder21,
  t22: TableBuilder22,
  t23: TableBuilder23,
  t24: TableBuilder24,
  t25: TableBuilder25,
  t26: TableBuilder26,
  t27: TableBuilder27,
  t28: TableBuilder28,
  t29: TableBuilder29,
  t30: TableBuilder30,
  t31: TableBuilder31,
  t32: TableBuilder32,
  t33: TableBuilder33,
  t34: TableBuilder34,
  t35: TableBuilder35,
  t36: TableBuilder36,
  t37: TableBuilder37,
  t38: TableBuilder38,
  t39: TableBuilder39,
  t40: TableBuilder40,
  t41: TableBuilder41,
  t42: TableBuilder42,
  t43: TableBuilder43,
  t44: TableBuilder44,
  t45: TableBuilder45,
  t46: TableBuilder46,
  t47: TableBuilder47,
  t48: TableBuilder48,
  t49: TableBuilder49,
  t50: TableBuilder50,
  t51: TableBuilder51,
  t52: TableBuilder52,
  t53: TableBuilder53,
  t54: TableBuilder54,
  t55: TableBuilder55,
  t56: TableBuilder56,
  t57: TableBuilder57,
  t58: TableBuilder58,
  t59: TableBuilder59,
  t60: TableBuilder60,
  t61: TableBuilder61,
  t62: TableBuilder62,
  t63: TableBuilder63,
  t64: TableBuilder64,
  t65: TableBuilder65,
  t66: TableBuilder66,
  t67: TableBuilder67,
  t68: TableBuilder68,
  t69: TableBuilder69,
  t70: TableBuilder70,
  t71: TableBuilder71,
  t72: TableBuilder72,
  t73: TableBuilder73,
  t74: TableBuilder74,
  t75: TableBuilder75,
  t76: TableBuilder76,
  t77: TableBuilder77,
  t78: TableBuilder78,
  t79: TableBuilder79,
  t80: TableBuilder80,
  t81: TableBuilder81,
  t82: TableBuilder82,
  t83: TableBuilder83,
  t84: TableBuilder84,
  t85: TableBuilder85,
  t86: TableBuilder86,
  t87: TableBuilder87,
  t88: TableBuilder88,
  t89: TableBuilder89,
  t90: TableBuilder90,
  t91: TableBuilder91,
  t92: TableBuilder92,
  t93: TableBuilder93,
  t94: TableBuilder94,
  t95: TableBuilder95,
  t96: TableBuilder96,
  t97: TableBuilder97,
  t98: TableBuilder98,
  t99: TableBuilder99,
  t100: TableBuilder100,
  t101: TableBuilder101,
  t102: TableBuilder102,
  t103: TableBuilder103,
  t104: TableBuilder104,
  t105: TableBuilder105,
  t106: TableBuilder106,
  t107: TableBuilder107,
  t108: TableBuilder108,
  t109: TableBuilder109,
  t110: TableBuilder110,
  t111: TableBuilder111,
  t112: TableBuilder112,
  t113: TableBuilder113,
  t114: TableBuilder114,
  t115: TableBuilder115,
  t116: TableBuilder116,
  t117: TableBuilder117,
  t118: TableBuilder118,
  t119: TableBuilder119,
  t120: TableBuilder120,
  t121: TableBuilder121,
  t122: TableBuilder122,
  t123: TableBuilder123,
  t124: TableBuilder124,
  t125: TableBuilder125,
  t126: TableBuilder126,
  t127: TableBuilder127,
  t128: TableBuilder128,
  t129: TableBuilder129,
  t130: TableBuilder130,
  t131: TableBuilder131,
  t132: TableBuilder132,
  t133: TableBuilder133,
  t134: TableBuilder134,
  t135: TableBuilder135,
  t136: TableBuilder136,
  t137: TableBuilder137,
  t138: TableBuilder138,
  t139: TableBuilder139,
  t140: TableBuilder140,
  t141: TableBuilder141,
  t142: TableBuilder142,
  t143: TableBuilder143,
  t144: TableBuilder144,
  t145: TableBuilder145,
  t146: TableBuilder146,
  t147: TableBuilder147,
  t148: TableBuilder148,
  t149: TableBuilder149,
  t150: TableBuilder150,
  t151: TableBuilder151,
  t152: TableBuilder152,
  t153: TableBuilder153,
  t154: TableBuilder154,
  t155: TableBuilder155,
  t156: TableBuilder156,
  t157: TableBuilder157,
  t158: TableBuilder158,
  t159: TableBuilder159,
  t160: TableBuilder160,
  t161: TableBuilder161,
  t162: TableBuilder162,
  t163: TableBuilder163,
  t164: TableBuilder164,
  t165: TableBuilder165,
  t166: TableBuilder166,
  t167: TableBuilder167,
  t168: TableBuilder168,
  t169: TableBuilder169,
  t170: TableBuilder170,
  t171: TableBuilder171,
  t172: TableBuilder172,
  t173: TableBuilder173,
  t174: TableBuilder174,
  t175: TableBuilder175,
  t176: TableBuilder176,
  t177: TableBuilder177,
  t178: TableBuilder178,
  t179: TableBuilder179,
  t180: TableBuilder180,
  t181: TableBuilder181,
  t182: TableBuilder182,
  t183: TableBuilder183,
  t184: TableBuilder184,
  t185: TableBuilder185,
  t186: TableBuilder186,
  t187: TableBuilder187,
  t188: TableBuilder188,
  t189: TableBuilder189,
  t190: TableBuilder190,
  t191: TableBuilder191,
  t192: TableBuilder192,
  t193: TableBuilder193,
  t194: TableBuilder194,
  t195: TableBuilder195,
  t196: TableBuilder196,
  t197: TableBuilder197,
  t198: TableBuilder198,
  t199: TableBuilder199,
  t200: TableBuilder200,
  t201: TableBuilder201,
  t202: TableBuilder202,
  t203: TableBuilder203,
  t204: TableBuilder204,
  t205: TableBuilder205,
  t206: TableBuilder206,
  t207: TableBuilder207,
  t208: TableBuilder208,
  t209: TableBuilder209,
  t210: TableBuilder210,
  t211: TableBuilder211,
  t212: TableBuilder212,
  t213: TableBuilder213,
  t214: TableBuilder214,
  t215: TableBuilder215,
  t216: TableBuilder216,
  t217: TableBuilder217,
  t218: TableBuilder218,
  t219: TableBuilder219,
  t220: TableBuilder220,
  t221: TableBuilder221,
  t222: TableBuilder222,
  t223: TableBuilder223,
  t224: TableBuilder224,
  t225: TableBuilder225,
  t226: TableBuilder226,
  t227: TableBuilder227,
  t228: TableBuilder228,
  t229: TableBuilder229,
  t230: TableBuilder230,
  t231: TableBuilder231,
  t232: TableBuilder232,
  t233: TableBuilder233,
  t234: TableBuilder234,
  t235: TableBuilder235,
  t236: TableBuilder236,
  t237: TableBuilder237,
  t238: TableBuilder238,
  t239: TableBuilder239,
  t240: TableBuilder240,
  t241: TableBuilder241,
  t242: TableBuilder242,
  t243: TableBuilder243,
  t244: TableBuilder244,
  t245: TableBuilder245,
  t246: TableBuilder246,
  t247: TableBuilder247,
  t248: TableBuilder248,
  t249: TableBuilder249,
  t250: TableBuilder250,
  t251: TableBuilder251,
  t252: TableBuilder252,
  t253: TableBuilder253,
  t254: TableBuilder254,
  t255: TableBuilder255,
  t256: TableBuilder256,
  t257: TableBuilder257,
  t258: TableBuilder258,
  t259: TableBuilder259,
  t260: TableBuilder260,
  t261: TableBuilder261,
  t262: TableBuilder262,
  t263: TableBuilder263,
  t264: TableBuilder264,
  t265: TableBuilder265,
  t266: TableBuilder266,
  t267: TableBuilder267,
  t268: TableBuilder268,
  t269: TableBuilder269,
  t270: TableBuilder270,
  t271: TableBuilder271,
  t272: TableBuilder272,
  t273: TableBuilder273,
  t274: TableBuilder274,
  t275: TableBuilder275,
  t276: TableBuilder276,
  t277: TableBuilder277,
  t278: TableBuilder278,
  t279: TableBuilder279,
  t280: TableBuilder280,
  t281: TableBuilder281,
  t282: TableBuilder282,
  t283: TableBuilder283,
  t284: TableBuilder284,
  t285: TableBuilder285,
  t286: TableBuilder286,
  t287: TableBuilder287,
  t288: TableBuilder288,
  t289: TableBuilder289,
  t290: TableBuilder290,
  t291: TableBuilder291,
  t292: TableBuilder292,
  t293: TableBuilder293,
  t294: TableBuilder294,
  t295: TableBuilder295,
  t296: TableBuilder296,
  t297: TableBuilder297,
  t298: TableBuilder298,
  t299: TableBuilder299,
  t300: TableBuilder300,
  t301: TableBuilder301,
  t302: TableBuilder302,
  t303: TableBuilder303,
  t304: TableBuilder304,
  t305: TableBuilder305,
  t306: TableBuilder306,
  t307: TableBuilder307,
  t308: TableBuilder308,
  t309: TableBuilder309,
  t310: TableBuilder310,
  t311: TableBuilder311,
  t312: TableBuilder312,
  t313: TableBuilder313,
  t314: TableBuilder314,
  t315: TableBuilder315,
  t316: TableBuilder316,
  t317: TableBuilder317,
  t318: TableBuilder318,
  t319: TableBuilder319,
  t320: TableBuilder320,
  t321: TableBuilder321,
  t322: TableBuilder322,
  t323: TableBuilder323,
  t324: TableBuilder324,
  t325: TableBuilder325,
  t326: TableBuilder326,
  t327: TableBuilder327,
  t328: TableBuilder328,
  t329: TableBuilder329,
  t330: TableBuilder330,
  t331: TableBuilder331,
  t332: TableBuilder332,
  t333: TableBuilder333,
  t334: TableBuilder334,
  t335: TableBuilder335,
  t336: TableBuilder336,
  t337: TableBuilder337,
  t338: TableBuilder338,
  t339: TableBuilder339,
  t340: TableBuilder340,
  t341: TableBuilder341,
  t342: TableBuilder342,
  t343: TableBuilder343,
  t344: TableBuilder344,
  t345: TableBuilder345,
  t346: TableBuilder346,
  t347: TableBuilder347,
  t348: TableBuilder348,
  t349: TableBuilder349,
  t350: TableBuilder350,
  t351: TableBuilder351,
  t352: TableBuilder352,
  t353: TableBuilder353,
  t354: TableBuilder354,
}

impl TableBuilders {
  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      t0: TableBuilder0::new(output_path.as_ref().join("file"), partition_size),
      t1: TableBuilder1::new(output_path.as_ref().join("source_loc"), partition_size),
      t2: TableBuilder2::new(output_path.as_ref().join("source_range"), partition_size),
      t3: TableBuilder3::new(output_path.as_ref().join("enum"), partition_size),
      t4: TableBuilder4::new(output_path.as_ref().join("enum_value"), partition_size),
      t5: TableBuilder5::new(output_path.as_ref().join("QualType"), partition_size),
      t6: TableBuilder6::new(output_path.as_ref().join("CFG"), partition_size),
      t7: TableBuilder7::new(output_path.as_ref().join("CFG_blocks"), partition_size),
      t8: TableBuilder8::new(output_path.as_ref().join("CFG_try_blocks"), partition_size),
      t9: TableBuilder9::new(output_path.as_ref().join("CFG_edges"), partition_size),
      t10: TableBuilder10::new(output_path.as_ref().join("CFGBlock"), partition_size),
      t11: TableBuilder11::new(output_path.as_ref().join("CFGBlock_elements"), partition_size),
      t12: TableBuilder12::new(output_path.as_ref().join("CFGElement"), partition_size),
      t13: TableBuilder13::new(output_path.as_ref().join("CFGInitializer"), partition_size),
      t14: TableBuilder14::new(output_path.as_ref().join("CFGScopeBegin"), partition_size),
      t15: TableBuilder15::new(output_path.as_ref().join("CFGScopeEnd"), partition_size),
      t16: TableBuilder16::new(output_path.as_ref().join("CFGNewAllocator"), partition_size),
      t17: TableBuilder17::new(output_path.as_ref().join("CFGLifetimeEnds"), partition_size),
      t18: TableBuilder18::new(output_path.as_ref().join("CFGLoopExit"), partition_size),
      t19: TableBuilder19::new(output_path.as_ref().join("CFGStmt"), partition_size),
      t20: TableBuilder20::new(output_path.as_ref().join("CFGConstructor"), partition_size),
      t21: TableBuilder21::new(output_path.as_ref().join("CFGCXXRecordTypedCall"), partition_size),
      t22: TableBuilder22::new(output_path.as_ref().join("CFGAutomaticObjDtor"), partition_size),
      t23: TableBuilder23::new(output_path.as_ref().join("CFGDeleteDtor"), partition_size),
      t24: TableBuilder24::new(output_path.as_ref().join("CFGBaseDtor"), partition_size),
      t25: TableBuilder25::new(output_path.as_ref().join("CFGMemberDtor"), partition_size),
      t26: TableBuilder26::new(output_path.as_ref().join("CFGTemporaryDtor"), partition_size),
      t27: TableBuilder27::new(output_path.as_ref().join("CFGCleanupFunction"), partition_size),
      t28: TableBuilder28::new(output_path.as_ref().join("Decl_usr"), partition_size),
      t29: TableBuilder29::new(output_path.as_ref().join("QualType_usr"), partition_size),
      t30: TableBuilder30::new(output_path.as_ref().join("FunctionDecl_cfg"), partition_size),
      t31: TableBuilder31::new(output_path.as_ref().join("RValueReferenceType"), partition_size),
      t32: TableBuilder32::new(output_path.as_ref().join("IncompleteArrayType"), partition_size),
      t33: TableBuilder33::new(output_path.as_ref().join("DependentAddressSpaceType"), partition_size),
      t34: TableBuilder34::new(output_path.as_ref().join("DependentSizedExtVectorType"), partition_size),
      t35: TableBuilder35::new(output_path.as_ref().join("DependentBitIntType"), partition_size),
      t36: TableBuilder36::new(output_path.as_ref().join("SubstTemplateTypeParmType"), partition_size),
      t37: TableBuilder37::new(output_path.as_ref().join("VectorType"), partition_size),
      t38: TableBuilder38::new(output_path.as_ref().join("MacroQualifiedType"), partition_size),
      t39: TableBuilder39::new(output_path.as_ref().join("TypeOfType"), partition_size),
      t40: TableBuilder40::new(output_path.as_ref().join("TagType"), partition_size),
      t41: TableBuilder41::new(output_path.as_ref().join("ConstantArrayType"), partition_size),
      t42: TableBuilder42::new(output_path.as_ref().join("RecordType"), partition_size),
      t43: TableBuilder43::new(output_path.as_ref().join("PipeType"), partition_size),
      t44: TableBuilder44::new(output_path.as_ref().join("ConstantMatrixType"), partition_size),
      t45: TableBuilder45::new(output_path.as_ref().join("UsingType"), partition_size),
      t46: TableBuilder46::new(output_path.as_ref().join("TypeWithKeyword"), partition_size),
      t47: TableBuilder47::new(output_path.as_ref().join("DeducedTemplateSpecializationType"), partition_size),
      t48: TableBuilder48::new(output_path.as_ref().join("DependentSizedMatrixType"), partition_size),
      t49: TableBuilder49::new(output_path.as_ref().join("AttributedType"), partition_size),
      t50: TableBuilder50::new(output_path.as_ref().join("DependentTemplateSpecializationType"), partition_size),
      t51: TableBuilder51::new(output_path.as_ref().join("TemplateTypeParmType"), partition_size),
      t52: TableBuilder52::new(output_path.as_ref().join("BlockPointerType"), partition_size),
      t53: TableBuilder53::new(output_path.as_ref().join("InjectedClassNameType"), partition_size),
      t54: TableBuilder54::new(output_path.as_ref().join("SubstTemplateTypeParmPackType"), partition_size),
      t55: TableBuilder55::new(output_path.as_ref().join("BuiltinType"), partition_size),
      t56: TableBuilder56::new(output_path.as_ref().join("DependentVectorType"), partition_size),
      t57: TableBuilder57::new(output_path.as_ref().join("ExtVectorType"), partition_size),
      t58: TableBuilder58::new(output_path.as_ref().join("ParenType"), partition_size),
      t59: TableBuilder59::new(output_path.as_ref().join("UnaryTransformType"), partition_size),
      t60: TableBuilder60::new(output_path.as_ref().join("UnresolvedUsingType"), partition_size),
      t61: TableBuilder61::new(output_path.as_ref().join("ComplexType"), partition_size),
      t62: TableBuilder62::new(output_path.as_ref().join("PointerType"), partition_size),
      t63: TableBuilder63::new(output_path.as_ref().join("BTFTagAttributedType"), partition_size),
      t64: TableBuilder64::new(output_path.as_ref().join("DependentNameType"), partition_size),
      t65: TableBuilder65::new(output_path.as_ref().join("Type"), partition_size),
      t66: TableBuilder66::new(output_path.as_ref().join("DependentUnaryTransformType"), partition_size),
      t67: TableBuilder67::new(output_path.as_ref().join("AtomicType"), partition_size),
      t68: TableBuilder68::new(output_path.as_ref().join("AutoType"), partition_size),
      t69: TableBuilder69::new(output_path.as_ref().join("TemplateSpecializationType"), partition_size),
      t70: TableBuilder70::new(output_path.as_ref().join("ReferenceType"), partition_size),
      t71: TableBuilder71::new(output_path.as_ref().join("DeducedType"), partition_size),
      t72: TableBuilder72::new(output_path.as_ref().join("PackExpansionType"), partition_size),
      t73: TableBuilder73::new(output_path.as_ref().join("DependentSizedArrayType"), partition_size),
      t74: TableBuilder74::new(output_path.as_ref().join("DecltypeType"), partition_size),
      t75: TableBuilder75::new(output_path.as_ref().join("LValueReferenceType"), partition_size),
      t76: TableBuilder76::new(output_path.as_ref().join("DependentDecltypeType"), partition_size),
      t77: TableBuilder77::new(output_path.as_ref().join("TypeOfExprType"), partition_size),
      t78: TableBuilder78::new(output_path.as_ref().join("FunctionProtoType_getParamTypes"), partition_size),
      t79: TableBuilder79::new(output_path.as_ref().join("FunctionProtoType_param_types"), partition_size),
      t80: TableBuilder80::new(output_path.as_ref().join("FunctionProtoType_exceptions"), partition_size),
      t81: TableBuilder81::new(output_path.as_ref().join("FunctionProtoType"), partition_size),
      t82: TableBuilder82::new(output_path.as_ref().join("AdjustedType"), partition_size),
      t83: TableBuilder83::new(output_path.as_ref().join("ArrayType"), partition_size),
      t84: TableBuilder84::new(output_path.as_ref().join("VariableArrayType"), partition_size),
      t85: TableBuilder85::new(output_path.as_ref().join("EnumType"), partition_size),
      t86: TableBuilder86::new(output_path.as_ref().join("DependentTypeOfExprType"), partition_size),
      t87: TableBuilder87::new(output_path.as_ref().join("DecayedType"), partition_size),
      t88: TableBuilder88::new(output_path.as_ref().join("MemberPointerType"), partition_size),
      t89: TableBuilder89::new(output_path.as_ref().join("BitIntType"), partition_size),
      t90: TableBuilder90::new(output_path.as_ref().join("TypedefType"), partition_size),
      t91: TableBuilder91::new(output_path.as_ref().join("FunctionType"), partition_size),
      t92: TableBuilder92::new(output_path.as_ref().join("FunctionNoProtoType"), partition_size),
      t93: TableBuilder93::new(output_path.as_ref().join("ElaboratedType"), partition_size),
      t94: TableBuilder94::new(output_path.as_ref().join("MatrixType"), partition_size),
      t95: TableBuilder95::new(output_path.as_ref().join("ClassTemplatePartialSpecializationDecl"), partition_size),
      t96: TableBuilder96::new(output_path.as_ref().join("TemplateParamObjectDecl"), partition_size),
      t97: TableBuilder97::new(output_path.as_ref().join("CXXRecordDecl_methods"), partition_size),
      t98: TableBuilder98::new(output_path.as_ref().join("CXXRecordDecl_ctors"), partition_size),
      t99: TableBuilder99::new(output_path.as_ref().join("CXXRecordDecl_friends"), partition_size),
      t100: TableBuilder100::new(output_path.as_ref().join("CXXRecordDecl_getLambdaExplicitTemplateParameters"), partition_size),
      t101: TableBuilder101::new(output_path.as_ref().join("CXXRecordDecl"), partition_size),
      t102: TableBuilder102::new(output_path.as_ref().join("TagDecl"), partition_size),
      t103: TableBuilder103::new(output_path.as_ref().join("HLSLBufferDecl"), partition_size),
      t104: TableBuilder104::new(output_path.as_ref().join("UsingDirectiveDecl"), partition_size),
      t105: TableBuilder105::new(output_path.as_ref().join("NamespaceAliasDecl"), partition_size),
      t106: TableBuilder106::new(output_path.as_ref().join("TypeDecl"), partition_size),
      t107: TableBuilder107::new(output_path.as_ref().join("RedeclarableTemplateDecl"), partition_size),
      t108: TableBuilder108::new(output_path.as_ref().join("ImplicitConceptSpecializationDecl"), partition_size),
      t109: TableBuilder109::new(output_path.as_ref().join("ConstructorUsingShadowDecl"), partition_size),
      t110: TableBuilder110::new(output_path.as_ref().join("BuiltinTemplateDecl"), partition_size),
      t111: TableBuilder111::new(output_path.as_ref().join("UsingShadowDecl"), partition_size),
      t112: TableBuilder112::new(output_path.as_ref().join("BindingDecl"), partition_size),
      t113: TableBuilder113::new(output_path.as_ref().join("UsingDecl"), partition_size),
      t114: TableBuilder114::new(output_path.as_ref().join("UnresolvedUsingTypenameDecl"), partition_size),
      t115: TableBuilder115::new(output_path.as_ref().join("LabelDecl"), partition_size),
      t116: TableBuilder116::new(output_path.as_ref().join("BaseUsingDecl_shadows"), partition_size),
      t117: TableBuilder117::new(output_path.as_ref().join("BaseUsingDecl"), partition_size),
      t118: TableBuilder118::new(output_path.as_ref().join("UsingPackDecl_expansions"), partition_size),
      t119: TableBuilder119::new(output_path.as_ref().join("UsingPackDecl"), partition_size),
      t120: TableBuilder120::new(output_path.as_ref().join("CXXMethodDecl_overridden_methods"), partition_size),
      t121: TableBuilder121::new(output_path.as_ref().join("CXXMethodDecl"), partition_size),
      t122: TableBuilder122::new(output_path.as_ref().join("TemplateTypeParmDecl"), partition_size),
      t123: TableBuilder123::new(output_path.as_ref().join("UnresolvedUsingIfExistsDecl"), partition_size),
      t124: TableBuilder124::new(output_path.as_ref().join("VarDecl"), partition_size),
      t125: TableBuilder125::new(output_path.as_ref().join("FunctionTemplateDecl"), partition_size),
      t126: TableBuilder126::new(output_path.as_ref().join("ClassTemplateDecl"), partition_size),
      t127: TableBuilder127::new(output_path.as_ref().join("TypedefNameDecl"), partition_size),
      t128: TableBuilder128::new(output_path.as_ref().join("TypeAliasTemplateDecl"), partition_size),
      t129: TableBuilder129::new(output_path.as_ref().join("RecordDecl_fields"), partition_size),
      t130: TableBuilder130::new(output_path.as_ref().join("RecordDecl"), partition_size),
      t131: TableBuilder131::new(output_path.as_ref().join("TemplateTemplateParmDecl"), partition_size),
      t132: TableBuilder132::new(output_path.as_ref().join("ExportDecl"), partition_size),
      t133: TableBuilder133::new(output_path.as_ref().join("UsingEnumDecl"), partition_size),
      t134: TableBuilder134::new(output_path.as_ref().join("PragmaDetectMismatchDecl"), partition_size),
      t135: TableBuilder135::new(output_path.as_ref().join("VarTemplateDecl"), partition_size),
      t136: TableBuilder136::new(output_path.as_ref().join("Decl_attrs"), partition_size),
      t137: TableBuilder137::new(output_path.as_ref().join("Decl_redecls"), partition_size),
      t138: TableBuilder138::new(output_path.as_ref().join("Decl"), partition_size),
      t139: TableBuilder139::new(output_path.as_ref().join("EmptyDecl"), partition_size),
      t140: TableBuilder140::new(output_path.as_ref().join("MSGuidDecl"), partition_size),
      t141: TableBuilder141::new(output_path.as_ref().join("CXXConstructorDecl"), partition_size),
      t142: TableBuilder142::new(output_path.as_ref().join("UnnamedGlobalConstantDecl"), partition_size),
      t143: TableBuilder143::new(output_path.as_ref().join("FieldDecl"), partition_size),
      t144: TableBuilder144::new(output_path.as_ref().join("RequiresExprBodyDecl"), partition_size),
      t145: TableBuilder145::new(output_path.as_ref().join("TypedefDecl"), partition_size),
      t146: TableBuilder146::new(output_path.as_ref().join("VarTemplateSpecializationDecl"), partition_size),
      t147: TableBuilder147::new(output_path.as_ref().join("LifetimeExtendedTemporaryDecl"), partition_size),
      t148: TableBuilder148::new(output_path.as_ref().join("DecompositionDecl_bindings"), partition_size),
      t149: TableBuilder149::new(output_path.as_ref().join("DecompositionDecl"), partition_size),
      t150: TableBuilder150::new(output_path.as_ref().join("PragmaCommentDecl"), partition_size),
      t151: TableBuilder151::new(output_path.as_ref().join("VarTemplatePartialSpecializationDecl"), partition_size),
      t152: TableBuilder152::new(output_path.as_ref().join("FunctionDecl_parameters"), partition_size),
      t153: TableBuilder153::new(output_path.as_ref().join("FunctionDecl"), partition_size),
      t154: TableBuilder154::new(output_path.as_ref().join("NonTypeTemplateParmDecl"), partition_size),
      t155: TableBuilder155::new(output_path.as_ref().join("MSPropertyDecl"), partition_size),
      t156: TableBuilder156::new(output_path.as_ref().join("ImplicitParamDecl"), partition_size),
      t157: TableBuilder157::new(output_path.as_ref().join("NamedDecl"), partition_size),
      t158: TableBuilder158::new(output_path.as_ref().join("CXXDestructorDecl"), partition_size),
      t159: TableBuilder159::new(output_path.as_ref().join("ValueDecl"), partition_size),
      t160: TableBuilder160::new(output_path.as_ref().join("CapturedDecl_parameters"), partition_size),
      t161: TableBuilder161::new(output_path.as_ref().join("CapturedDecl"), partition_size),
      t162: TableBuilder162::new(output_path.as_ref().join("FriendTemplateDecl"), partition_size),
      t163: TableBuilder163::new(output_path.as_ref().join("IndirectFieldDecl_chain"), partition_size),
      t164: TableBuilder164::new(output_path.as_ref().join("IndirectFieldDecl"), partition_size),
      t165: TableBuilder165::new(output_path.as_ref().join("EnumConstantDecl"), partition_size),
      t166: TableBuilder166::new(output_path.as_ref().join("CXXConversionDecl"), partition_size),
      t167: TableBuilder167::new(output_path.as_ref().join("EnumDecl_enumerators"), partition_size),
      t168: TableBuilder168::new(output_path.as_ref().join("EnumDecl"), partition_size),
      t169: TableBuilder169::new(output_path.as_ref().join("UnresolvedUsingValueDecl"), partition_size),
      t170: TableBuilder170::new(output_path.as_ref().join("BlockDecl_parameters"), partition_size),
      t171: TableBuilder171::new(output_path.as_ref().join("BlockDecl"), partition_size),
      t172: TableBuilder172::new(output_path.as_ref().join("DeclaratorDecl"), partition_size),
      t173: TableBuilder173::new(output_path.as_ref().join("TypeAliasDecl"), partition_size),
      t174: TableBuilder174::new(output_path.as_ref().join("CXXDeductionGuideDecl"), partition_size),
      t175: TableBuilder175::new(output_path.as_ref().join("ImportDecl_getIdentifierLocs"), partition_size),
      t176: TableBuilder176::new(output_path.as_ref().join("ImportDecl"), partition_size),
      t177: TableBuilder177::new(output_path.as_ref().join("AccessSpecDecl"), partition_size),
      t178: TableBuilder178::new(output_path.as_ref().join("ParmVarDecl"), partition_size),
      t179: TableBuilder179::new(output_path.as_ref().join("FriendDecl"), partition_size),
      t180: TableBuilder180::new(output_path.as_ref().join("FileScopeAsmDecl"), partition_size),
      t181: TableBuilder181::new(output_path.as_ref().join("StaticAssertDecl"), partition_size),
      t182: TableBuilder182::new(output_path.as_ref().join("TranslationUnitDecl"), partition_size),
      t183: TableBuilder183::new(output_path.as_ref().join("LinkageSpecDecl"), partition_size),
      t184: TableBuilder184::new(output_path.as_ref().join("ExternCContextDecl"), partition_size),
      t185: TableBuilder185::new(output_path.as_ref().join("TopLevelStmtDecl"), partition_size),
      t186: TableBuilder186::new(output_path.as_ref().join("TemplateDecl"), partition_size),
      t187: TableBuilder187::new(output_path.as_ref().join("ClassTemplateSpecializationDecl"), partition_size),
      t188: TableBuilder188::new(output_path.as_ref().join("ConceptDecl"), partition_size),
      t189: TableBuilder189::new(output_path.as_ref().join("NamespaceDecl"), partition_size),
      t190: TableBuilder190::new(output_path.as_ref().join("AsmStmt"), partition_size),
      t191: TableBuilder191::new(output_path.as_ref().join("FullExpr"), partition_size),
      t192: TableBuilder192::new(output_path.as_ref().join("CXXTemporaryObjectExpr"), partition_size),
      t193: TableBuilder193::new(output_path.as_ref().join("CXXDefaultInitExpr"), partition_size),
      t194: TableBuilder194::new(output_path.as_ref().join("CXXConstructExpr"), partition_size),
      t195: TableBuilder195::new(output_path.as_ref().join("Expr"), partition_size),
      t196: TableBuilder196::new(output_path.as_ref().join("WhileStmt"), partition_size),
      t197: TableBuilder197::new(output_path.as_ref().join("ValueStmt"), partition_size),
      t198: TableBuilder198::new(output_path.as_ref().join("DoStmt"), partition_size),
      t199: TableBuilder199::new(output_path.as_ref().join("DependentScopeDeclRefExpr"), partition_size),
      t200: TableBuilder200::new(output_path.as_ref().join("IndirectGotoStmt"), partition_size),
      t201: TableBuilder201::new(output_path.as_ref().join("ContinueStmt"), partition_size),
      t202: TableBuilder202::new(output_path.as_ref().join("ConceptSpecializationExpr"), partition_size),
      t203: TableBuilder203::new(output_path.as_ref().join("ReturnStmt"), partition_size),
      t204: TableBuilder204::new(output_path.as_ref().join("GCCAsmStmt"), partition_size),
      t205: TableBuilder205::new(output_path.as_ref().join("MSAsmStmt_getAllConstraints"), partition_size),
      t206: TableBuilder206::new(output_path.as_ref().join("MSAsmStmt_getClobbers"), partition_size),
      t207: TableBuilder207::new(output_path.as_ref().join("MSAsmStmt_getAllExprs"), partition_size),
      t208: TableBuilder208::new(output_path.as_ref().join("MSAsmStmt"), partition_size),
      t209: TableBuilder209::new(output_path.as_ref().join("SEHExceptStmt"), partition_size),
      t210: TableBuilder210::new(output_path.as_ref().join("SEHTryStmt"), partition_size),
      t211: TableBuilder211::new(output_path.as_ref().join("InitListExpr_inits"), partition_size),
      t212: TableBuilder212::new(output_path.as_ref().join("InitListExpr"), partition_size),
      t213: TableBuilder213::new(output_path.as_ref().join("SEHLeaveStmt"), partition_size),
      t214: TableBuilder214::new(output_path.as_ref().join("CapturedStmt_capture_inits"), partition_size),
      t215: TableBuilder215::new(output_path.as_ref().join("CapturedStmt"), partition_size),
      t216: TableBuilder216::new(output_path.as_ref().join("CXXCatchStmt"), partition_size),
      t217: TableBuilder217::new(output_path.as_ref().join("CXXForRangeStmt"), partition_size),
      t218: TableBuilder218::new(output_path.as_ref().join("CXXNewExpr"), partition_size),
      t219: TableBuilder219::new(output_path.as_ref().join("CoroutineBodyStmt_getParamMoves"), partition_size),
      t220: TableBuilder220::new(output_path.as_ref().join("CoroutineBodyStmt"), partition_size),
      t221: TableBuilder221::new(output_path.as_ref().join("ParenListExpr"), partition_size),
      t222: TableBuilder222::new(output_path.as_ref().join("CXXScalarValueInitExpr"), partition_size),
      t223: TableBuilder223::new(output_path.as_ref().join("MSPropertyRefExpr"), partition_size),
      t224: TableBuilder224::new(output_path.as_ref().join("SEHFinallyStmt"), partition_size),
      t225: TableBuilder225::new(output_path.as_ref().join("DeclRefExpr"), partition_size),
      t226: TableBuilder226::new(output_path.as_ref().join("CStyleCastExpr"), partition_size),
      t227: TableBuilder227::new(output_path.as_ref().join("CXXNullPtrLiteralExpr"), partition_size),
      t228: TableBuilder228::new(output_path.as_ref().join("ForStmt"), partition_size),
      t229: TableBuilder229::new(output_path.as_ref().join("AsTypeExpr"), partition_size),
      t230: TableBuilder230::new(output_path.as_ref().join("MatrixSubscriptExpr"), partition_size),
      t231: TableBuilder231::new(output_path.as_ref().join("BuiltinBitCastExpr"), partition_size),
      t232: TableBuilder232::new(output_path.as_ref().join("CXXNamedCastExpr"), partition_size),
      t233: TableBuilder233::new(output_path.as_ref().join("MemberExpr"), partition_size),
      t234: TableBuilder234::new(output_path.as_ref().join("CXXNoexceptExpr"), partition_size),
      t235: TableBuilder235::new(output_path.as_ref().join("BlockExpr"), partition_size),
      t236: TableBuilder236::new(output_path.as_ref().join("BreakStmt"), partition_size),
      t237: TableBuilder237::new(output_path.as_ref().join("CXXTryStmt"), partition_size),
      t238: TableBuilder238::new(output_path.as_ref().join("Stmt"), partition_size),
      t239: TableBuilder239::new(output_path.as_ref().join("BinaryOperator"), partition_size),
      t240: TableBuilder240::new(output_path.as_ref().join("OpaqueValueExpr"), partition_size),
      t241: TableBuilder241::new(output_path.as_ref().join("UnresolvedMemberExpr"), partition_size),
      t242: TableBuilder242::new(output_path.as_ref().join("StmtExpr"), partition_size),
      t243: TableBuilder243::new(output_path.as_ref().join("FunctionParmPackExpr"), partition_size),
      t244: TableBuilder244::new(output_path.as_ref().join("ImplicitCastExpr"), partition_size),
      t245: TableBuilder245::new(output_path.as_ref().join("UserDefinedLiteral"), partition_size),
      t246: TableBuilder246::new(output_path.as_ref().join("CXXDynamicCastExpr"), partition_size),
      t247: TableBuilder247::new(output_path.as_ref().join("ArrayTypeTraitExpr"), partition_size),
      t248: TableBuilder248::new(output_path.as_ref().join("CompoundStmt_body"), partition_size),
      t249: TableBuilder249::new(output_path.as_ref().join("CompoundStmt"), partition_size),
      t250: TableBuilder250::new(output_path.as_ref().join("CXXPseudoDestructorExpr"), partition_size),
      t251: TableBuilder251::new(output_path.as_ref().join("StringLiteral"), partition_size),
      t252: TableBuilder252::new(output_path.as_ref().join("CXXDefaultArgExpr"), partition_size),
      t253: TableBuilder253::new(output_path.as_ref().join("CXXThisExpr"), partition_size),
      t254: TableBuilder254::new(output_path.as_ref().join("CXXUuidofExpr"), partition_size),
      t255: TableBuilder255::new(output_path.as_ref().join("ShuffleVectorExpr"), partition_size),
      t256: TableBuilder256::new(output_path.as_ref().join("CXXStdInitializerListExpr"), partition_size),
      t257: TableBuilder257::new(output_path.as_ref().join("DeclStmt_decls"), partition_size),
      t258: TableBuilder258::new(output_path.as_ref().join("DeclStmt"), partition_size),
      t259: TableBuilder259::new(output_path.as_ref().join("CoyieldExpr"), partition_size),
      t260: TableBuilder260::new(output_path.as_ref().join("AtomicExpr"), partition_size),
      t261: TableBuilder261::new(output_path.as_ref().join("ImplicitValueInitExpr"), partition_size),
      t262: TableBuilder262::new(output_path.as_ref().join("NoInitExpr"), partition_size),
      t263: TableBuilder263::new(output_path.as_ref().join("CXXThrowExpr"), partition_size),
      t264: TableBuilder264::new(output_path.as_ref().join("AbstractConditionalOperator"), partition_size),
      t265: TableBuilder265::new(output_path.as_ref().join("RecoveryExpr_subExpressions"), partition_size),
      t266: TableBuilder266::new(output_path.as_ref().join("RecoveryExpr"), partition_size),
      t267: TableBuilder267::new(output_path.as_ref().join("BinaryConditionalOperator"), partition_size),
      t268: TableBuilder268::new(output_path.as_ref().join("ExtVectorElementExpr"), partition_size),
      t269: TableBuilder269::new(output_path.as_ref().join("CXXTypeidExpr"), partition_size),
      t270: TableBuilder270::new(output_path.as_ref().join("GenericSelectionExpr_getAssocExprs"), partition_size),
      t271: TableBuilder271::new(output_path.as_ref().join("GenericSelectionExpr"), partition_size),
      t272: TableBuilder272::new(output_path.as_ref().join("ExpressionTraitExpr"), partition_size),
      t273: TableBuilder273::new(output_path.as_ref().join("CXXMemberCallExpr"), partition_size),
      t274: TableBuilder274::new(output_path.as_ref().join("ArraySubscriptExpr"), partition_size),
      t275: TableBuilder275::new(output_path.as_ref().join("RequiresExpr_getLocalParameters"), partition_size),
      t276: TableBuilder276::new(output_path.as_ref().join("RequiresExpr"), partition_size),
      t277: TableBuilder277::new(output_path.as_ref().join("ImaginaryLiteral"), partition_size),
      t278: TableBuilder278::new(output_path.as_ref().join("CastExpr"), partition_size),
      t279: TableBuilder279::new(output_path.as_ref().join("PackExpansionExpr"), partition_size),
      t280: TableBuilder280::new(output_path.as_ref().join("CXXStaticCastExpr"), partition_size),
      t281: TableBuilder281::new(output_path.as_ref().join("OffsetOfExpr"), partition_size),
      t282: TableBuilder282::new(output_path.as_ref().join("UnaryExprOrTypeTraitExpr"), partition_size),
      t283: TableBuilder283::new(output_path.as_ref().join("LabelStmt"), partition_size),
      t284: TableBuilder284::new(output_path.as_ref().join("CXXBoolLiteralExpr"), partition_size),
      t285: TableBuilder285::new(output_path.as_ref().join("CharacterLiteral"), partition_size),
      t286: TableBuilder286::new(output_path.as_ref().join("AttributedStmt_getAttrs"), partition_size),
      t287: TableBuilder287::new(output_path.as_ref().join("AttributedStmt"), partition_size),
      t288: TableBuilder288::new(output_path.as_ref().join("SwitchStmt"), partition_size),
      t289: TableBuilder289::new(output_path.as_ref().join("ConstantExpr"), partition_size),
      t290: TableBuilder290::new(output_path.as_ref().join("ConvertVectorExpr"), partition_size),
      t291: TableBuilder291::new(output_path.as_ref().join("IntegerLiteral"), partition_size),
      t292: TableBuilder292::new(output_path.as_ref().join("CXXReinterpretCastExpr"), partition_size),
      t293: TableBuilder293::new(output_path.as_ref().join("MSPropertySubscriptExpr"), partition_size),
      t294: TableBuilder294::new(output_path.as_ref().join("NullStmt"), partition_size),
      t295: TableBuilder295::new(output_path.as_ref().join("CXXAddrspaceCastExpr"), partition_size),
      t296: TableBuilder296::new(output_path.as_ref().join("CXXFunctionalCastExpr"), partition_size),
      t297: TableBuilder297::new(output_path.as_ref().join("CXXOperatorCallExpr"), partition_size),
      t298: TableBuilder298::new(output_path.as_ref().join("CXXBindTemporaryExpr"), partition_size),
      t299: TableBuilder299::new(output_path.as_ref().join("CXXRewrittenBinaryOperator"), partition_size),
      t300: TableBuilder300::new(output_path.as_ref().join("OverloadExpr"), partition_size),
      t301: TableBuilder301::new(output_path.as_ref().join("DesignatedInitUpdateExpr"), partition_size),
      t302: TableBuilder302::new(output_path.as_ref().join("ConditionalOperator"), partition_size),
      t303: TableBuilder303::new(output_path.as_ref().join("TypeTraitExpr"), partition_size),
      t304: TableBuilder304::new(output_path.as_ref().join("CXXInheritedCtorInitExpr"), partition_size),
      t305: TableBuilder305::new(output_path.as_ref().join("DefaultStmt"), partition_size),
      t306: TableBuilder306::new(output_path.as_ref().join("CompoundAssignOperator"), partition_size),
      t307: TableBuilder307::new(output_path.as_ref().join("ParenExpr"), partition_size),
      t308: TableBuilder308::new(output_path.as_ref().join("PseudoObjectExpr_semantics"), partition_size),
      t309: TableBuilder309::new(output_path.as_ref().join("PseudoObjectExpr"), partition_size),
      t310: TableBuilder310::new(output_path.as_ref().join("FixedPointLiteral"), partition_size),
      t311: TableBuilder311::new(output_path.as_ref().join("SwitchCase"), partition_size),
      t312: TableBuilder312::new(output_path.as_ref().join("GotoStmt"), partition_size),
      t313: TableBuilder313::new(output_path.as_ref().join("CompoundLiteralExpr"), partition_size),
      t314: TableBuilder314::new(output_path.as_ref().join("VAArgExpr"), partition_size),
      t315: TableBuilder315::new(output_path.as_ref().join("AddrLabelExpr"), partition_size),
      t316: TableBuilder316::new(output_path.as_ref().join("GNUNullExpr"), partition_size),
      t317: TableBuilder317::new(output_path.as_ref().join("UnresolvedLookupExpr"), partition_size),
      t318: TableBuilder318::new(output_path.as_ref().join("ArrayInitIndexExpr"), partition_size),
      t319: TableBuilder319::new(output_path.as_ref().join("CXXUnresolvedConstructExpr_arguments"), partition_size),
      t320: TableBuilder320::new(output_path.as_ref().join("CXXUnresolvedConstructExpr"), partition_size),
      t321: TableBuilder321::new(output_path.as_ref().join("ExplicitCastExpr"), partition_size),
      t322: TableBuilder322::new(output_path.as_ref().join("ChooseExpr"), partition_size),
      t323: TableBuilder323::new(output_path.as_ref().join("CXXDependentScopeMemberExpr"), partition_size),
      t324: TableBuilder324::new(output_path.as_ref().join("CaseStmt"), partition_size),
      t325: TableBuilder325::new(output_path.as_ref().join("DesignatedInitExpr"), partition_size),
      t326: TableBuilder326::new(output_path.as_ref().join("TypoExpr"), partition_size),
      t327: TableBuilder327::new(output_path.as_ref().join("SizeOfPackExpr"), partition_size),
      t328: TableBuilder328::new(output_path.as_ref().join("PredefinedExpr"), partition_size),
      t329: TableBuilder329::new(output_path.as_ref().join("SubstNonTypeTemplateParmExpr"), partition_size),
      t330: TableBuilder330::new(output_path.as_ref().join("SubstNonTypeTemplateParmPackExpr"), partition_size),
      t331: TableBuilder331::new(output_path.as_ref().join("CXXParenListInitExpr_getInitExprs"), partition_size),
      t332: TableBuilder332::new(output_path.as_ref().join("CXXParenListInitExpr_getUserSpecifiedInitExprs"), partition_size),
      t333: TableBuilder333::new(output_path.as_ref().join("CXXParenListInitExpr"), partition_size),
      t334: TableBuilder334::new(output_path.as_ref().join("CUDAKernelCallExpr"), partition_size),
      t335: TableBuilder335::new(output_path.as_ref().join("CoroutineSuspendExpr"), partition_size),
      t336: TableBuilder336::new(output_path.as_ref().join("UnaryOperator"), partition_size),
      t337: TableBuilder337::new(output_path.as_ref().join("DependentCoawaitExpr"), partition_size),
      t338: TableBuilder338::new(output_path.as_ref().join("LambdaExpr_capture_inits"), partition_size),
      t339: TableBuilder339::new(output_path.as_ref().join("LambdaExpr_getExplicitTemplateParameters"), partition_size),
      t340: TableBuilder340::new(output_path.as_ref().join("LambdaExpr"), partition_size),
      t341: TableBuilder341::new(output_path.as_ref().join("ExprWithCleanups"), partition_size),
      t342: TableBuilder342::new(output_path.as_ref().join("SYCLUniqueStableNameExpr"), partition_size),
      t343: TableBuilder343::new(output_path.as_ref().join("CXXDeleteExpr"), partition_size),
      t344: TableBuilder344::new(output_path.as_ref().join("CallExpr"), partition_size),
      t345: TableBuilder345::new(output_path.as_ref().join("MaterializeTemporaryExpr"), partition_size),
      t346: TableBuilder346::new(output_path.as_ref().join("SourceLocExpr"), partition_size),
      t347: TableBuilder347::new(output_path.as_ref().join("CoawaitExpr"), partition_size),
      t348: TableBuilder348::new(output_path.as_ref().join("CXXConstCastExpr"), partition_size),
      t349: TableBuilder349::new(output_path.as_ref().join("CoreturnStmt"), partition_size),
      t350: TableBuilder350::new(output_path.as_ref().join("ArrayInitLoopExpr"), partition_size),
      t351: TableBuilder351::new(output_path.as_ref().join("MSDependentExistsStmt"), partition_size),
      t352: TableBuilder352::new(output_path.as_ref().join("IfStmt"), partition_size),
      t353: TableBuilder353::new(output_path.as_ref().join("CXXFoldExpr"), partition_size),
      t354: TableBuilder354::new(output_path.as_ref().join("FloatingLiteral"), partition_size),
    }
  }
  pub async fn push(&mut self, record: Record) -> Result<()> {
    match record {
      Record::Record0(record) => self.t0.push(record).await,
      Record::Record1(record) => self.t1.push(record).await,
      Record::Record2(record) => self.t2.push(record).await,
      Record::Record3(record) => self.t3.push(record).await,
      Record::Record4(record) => self.t4.push(record).await,
      Record::Record5(record) => self.t5.push(record).await,
      Record::Record6(record) => self.t6.push(record).await,
      Record::Record7(record) => self.t7.push(record).await,
      Record::Record8(record) => self.t8.push(record).await,
      Record::Record9(record) => self.t9.push(record).await,
      Record::Record10(record) => self.t10.push(record).await,
      Record::Record11(record) => self.t11.push(record).await,
      Record::Record12(record) => self.t12.push(record).await,
      Record::Record13(record) => self.t13.push(record).await,
      Record::Record14(record) => self.t14.push(record).await,
      Record::Record15(record) => self.t15.push(record).await,
      Record::Record16(record) => self.t16.push(record).await,
      Record::Record17(record) => self.t17.push(record).await,
      Record::Record18(record) => self.t18.push(record).await,
      Record::Record19(record) => self.t19.push(record).await,
      Record::Record20(record) => self.t20.push(record).await,
      Record::Record21(record) => self.t21.push(record).await,
      Record::Record22(record) => self.t22.push(record).await,
      Record::Record23(record) => self.t23.push(record).await,
      Record::Record24(record) => self.t24.push(record).await,
      Record::Record25(record) => self.t25.push(record).await,
      Record::Record26(record) => self.t26.push(record).await,
      Record::Record27(record) => self.t27.push(record).await,
      Record::Record28(record) => self.t28.push(record).await,
      Record::Record29(record) => self.t29.push(record).await,
      Record::Record30(record) => self.t30.push(record).await,
      Record::Record31(record) => self.t31.push(record).await,
      Record::Record32(record) => self.t32.push(record).await,
      Record::Record33(record) => self.t33.push(record).await,
      Record::Record34(record) => self.t34.push(record).await,
      Record::Record35(record) => self.t35.push(record).await,
      Record::Record36(record) => self.t36.push(record).await,
      Record::Record37(record) => self.t37.push(record).await,
      Record::Record38(record) => self.t38.push(record).await,
      Record::Record39(record) => self.t39.push(record).await,
      Record::Record40(record) => self.t40.push(record).await,
      Record::Record41(record) => self.t41.push(record).await,
      Record::Record42(record) => self.t42.push(record).await,
      Record::Record43(record) => self.t43.push(record).await,
      Record::Record44(record) => self.t44.push(record).await,
      Record::Record45(record) => self.t45.push(record).await,
      Record::Record46(record) => self.t46.push(record).await,
      Record::Record47(record) => self.t47.push(record).await,
      Record::Record48(record) => self.t48.push(record).await,
      Record::Record49(record) => self.t49.push(record).await,
      Record::Record50(record) => self.t50.push(record).await,
      Record::Record51(record) => self.t51.push(record).await,
      Record::Record52(record) => self.t52.push(record).await,
      Record::Record53(record) => self.t53.push(record).await,
      Record::Record54(record) => self.t54.push(record).await,
      Record::Record55(record) => self.t55.push(record).await,
      Record::Record56(record) => self.t56.push(record).await,
      Record::Record57(record) => self.t57.push(record).await,
      Record::Record58(record) => self.t58.push(record).await,
      Record::Record59(record) => self.t59.push(record).await,
      Record::Record60(record) => self.t60.push(record).await,
      Record::Record61(record) => self.t61.push(record).await,
      Record::Record62(record) => self.t62.push(record).await,
      Record::Record63(record) => self.t63.push(record).await,
      Record::Record64(record) => self.t64.push(record).await,
      Record::Record65(record) => self.t65.push(record).await,
      Record::Record66(record) => self.t66.push(record).await,
      Record::Record67(record) => self.t67.push(record).await,
      Record::Record68(record) => self.t68.push(record).await,
      Record::Record69(record) => self.t69.push(record).await,
      Record::Record70(record) => self.t70.push(record).await,
      Record::Record71(record) => self.t71.push(record).await,
      Record::Record72(record) => self.t72.push(record).await,
      Record::Record73(record) => self.t73.push(record).await,
      Record::Record74(record) => self.t74.push(record).await,
      Record::Record75(record) => self.t75.push(record).await,
      Record::Record76(record) => self.t76.push(record).await,
      Record::Record77(record) => self.t77.push(record).await,
      Record::Record78(record) => self.t78.push(record).await,
      Record::Record79(record) => self.t79.push(record).await,
      Record::Record80(record) => self.t80.push(record).await,
      Record::Record81(record) => self.t81.push(record).await,
      Record::Record82(record) => self.t82.push(record).await,
      Record::Record83(record) => self.t83.push(record).await,
      Record::Record84(record) => self.t84.push(record).await,
      Record::Record85(record) => self.t85.push(record).await,
      Record::Record86(record) => self.t86.push(record).await,
      Record::Record87(record) => self.t87.push(record).await,
      Record::Record88(record) => self.t88.push(record).await,
      Record::Record89(record) => self.t89.push(record).await,
      Record::Record90(record) => self.t90.push(record).await,
      Record::Record91(record) => self.t91.push(record).await,
      Record::Record92(record) => self.t92.push(record).await,
      Record::Record93(record) => self.t93.push(record).await,
      Record::Record94(record) => self.t94.push(record).await,
      Record::Record95(record) => self.t95.push(record).await,
      Record::Record96(record) => self.t96.push(record).await,
      Record::Record97(record) => self.t97.push(record).await,
      Record::Record98(record) => self.t98.push(record).await,
      Record::Record99(record) => self.t99.push(record).await,
      Record::Record100(record) => self.t100.push(record).await,
      Record::Record101(record) => self.t101.push(record).await,
      Record::Record102(record) => self.t102.push(record).await,
      Record::Record103(record) => self.t103.push(record).await,
      Record::Record104(record) => self.t104.push(record).await,
      Record::Record105(record) => self.t105.push(record).await,
      Record::Record106(record) => self.t106.push(record).await,
      Record::Record107(record) => self.t107.push(record).await,
      Record::Record108(record) => self.t108.push(record).await,
      Record::Record109(record) => self.t109.push(record).await,
      Record::Record110(record) => self.t110.push(record).await,
      Record::Record111(record) => self.t111.push(record).await,
      Record::Record112(record) => self.t112.push(record).await,
      Record::Record113(record) => self.t113.push(record).await,
      Record::Record114(record) => self.t114.push(record).await,
      Record::Record115(record) => self.t115.push(record).await,
      Record::Record116(record) => self.t116.push(record).await,
      Record::Record117(record) => self.t117.push(record).await,
      Record::Record118(record) => self.t118.push(record).await,
      Record::Record119(record) => self.t119.push(record).await,
      Record::Record120(record) => self.t120.push(record).await,
      Record::Record121(record) => self.t121.push(record).await,
      Record::Record122(record) => self.t122.push(record).await,
      Record::Record123(record) => self.t123.push(record).await,
      Record::Record124(record) => self.t124.push(record).await,
      Record::Record125(record) => self.t125.push(record).await,
      Record::Record126(record) => self.t126.push(record).await,
      Record::Record127(record) => self.t127.push(record).await,
      Record::Record128(record) => self.t128.push(record).await,
      Record::Record129(record) => self.t129.push(record).await,
      Record::Record130(record) => self.t130.push(record).await,
      Record::Record131(record) => self.t131.push(record).await,
      Record::Record132(record) => self.t132.push(record).await,
      Record::Record133(record) => self.t133.push(record).await,
      Record::Record134(record) => self.t134.push(record).await,
      Record::Record135(record) => self.t135.push(record).await,
      Record::Record136(record) => self.t136.push(record).await,
      Record::Record137(record) => self.t137.push(record).await,
      Record::Record138(record) => self.t138.push(record).await,
      Record::Record139(record) => self.t139.push(record).await,
      Record::Record140(record) => self.t140.push(record).await,
      Record::Record141(record) => self.t141.push(record).await,
      Record::Record142(record) => self.t142.push(record).await,
      Record::Record143(record) => self.t143.push(record).await,
      Record::Record144(record) => self.t144.push(record).await,
      Record::Record145(record) => self.t145.push(record).await,
      Record::Record146(record) => self.t146.push(record).await,
      Record::Record147(record) => self.t147.push(record).await,
      Record::Record148(record) => self.t148.push(record).await,
      Record::Record149(record) => self.t149.push(record).await,
      Record::Record150(record) => self.t150.push(record).await,
      Record::Record151(record) => self.t151.push(record).await,
      Record::Record152(record) => self.t152.push(record).await,
      Record::Record153(record) => self.t153.push(record).await,
      Record::Record154(record) => self.t154.push(record).await,
      Record::Record155(record) => self.t155.push(record).await,
      Record::Record156(record) => self.t156.push(record).await,
      Record::Record157(record) => self.t157.push(record).await,
      Record::Record158(record) => self.t158.push(record).await,
      Record::Record159(record) => self.t159.push(record).await,
      Record::Record160(record) => self.t160.push(record).await,
      Record::Record161(record) => self.t161.push(record).await,
      Record::Record162(record) => self.t162.push(record).await,
      Record::Record163(record) => self.t163.push(record).await,
      Record::Record164(record) => self.t164.push(record).await,
      Record::Record165(record) => self.t165.push(record).await,
      Record::Record166(record) => self.t166.push(record).await,
      Record::Record167(record) => self.t167.push(record).await,
      Record::Record168(record) => self.t168.push(record).await,
      Record::Record169(record) => self.t169.push(record).await,
      Record::Record170(record) => self.t170.push(record).await,
      Record::Record171(record) => self.t171.push(record).await,
      Record::Record172(record) => self.t172.push(record).await,
      Record::Record173(record) => self.t173.push(record).await,
      Record::Record174(record) => self.t174.push(record).await,
      Record::Record175(record) => self.t175.push(record).await,
      Record::Record176(record) => self.t176.push(record).await,
      Record::Record177(record) => self.t177.push(record).await,
      Record::Record178(record) => self.t178.push(record).await,
      Record::Record179(record) => self.t179.push(record).await,
      Record::Record180(record) => self.t180.push(record).await,
      Record::Record181(record) => self.t181.push(record).await,
      Record::Record182(record) => self.t182.push(record).await,
      Record::Record183(record) => self.t183.push(record).await,
      Record::Record184(record) => self.t184.push(record).await,
      Record::Record185(record) => self.t185.push(record).await,
      Record::Record186(record) => self.t186.push(record).await,
      Record::Record187(record) => self.t187.push(record).await,
      Record::Record188(record) => self.t188.push(record).await,
      Record::Record189(record) => self.t189.push(record).await,
      Record::Record190(record) => self.t190.push(record).await,
      Record::Record191(record) => self.t191.push(record).await,
      Record::Record192(record) => self.t192.push(record).await,
      Record::Record193(record) => self.t193.push(record).await,
      Record::Record194(record) => self.t194.push(record).await,
      Record::Record195(record) => self.t195.push(record).await,
      Record::Record196(record) => self.t196.push(record).await,
      Record::Record197(record) => self.t197.push(record).await,
      Record::Record198(record) => self.t198.push(record).await,
      Record::Record199(record) => self.t199.push(record).await,
      Record::Record200(record) => self.t200.push(record).await,
      Record::Record201(record) => self.t201.push(record).await,
      Record::Record202(record) => self.t202.push(record).await,
      Record::Record203(record) => self.t203.push(record).await,
      Record::Record204(record) => self.t204.push(record).await,
      Record::Record205(record) => self.t205.push(record).await,
      Record::Record206(record) => self.t206.push(record).await,
      Record::Record207(record) => self.t207.push(record).await,
      Record::Record208(record) => self.t208.push(record).await,
      Record::Record209(record) => self.t209.push(record).await,
      Record::Record210(record) => self.t210.push(record).await,
      Record::Record211(record) => self.t211.push(record).await,
      Record::Record212(record) => self.t212.push(record).await,
      Record::Record213(record) => self.t213.push(record).await,
      Record::Record214(record) => self.t214.push(record).await,
      Record::Record215(record) => self.t215.push(record).await,
      Record::Record216(record) => self.t216.push(record).await,
      Record::Record217(record) => self.t217.push(record).await,
      Record::Record218(record) => self.t218.push(record).await,
      Record::Record219(record) => self.t219.push(record).await,
      Record::Record220(record) => self.t220.push(record).await,
      Record::Record221(record) => self.t221.push(record).await,
      Record::Record222(record) => self.t222.push(record).await,
      Record::Record223(record) => self.t223.push(record).await,
      Record::Record224(record) => self.t224.push(record).await,
      Record::Record225(record) => self.t225.push(record).await,
      Record::Record226(record) => self.t226.push(record).await,
      Record::Record227(record) => self.t227.push(record).await,
      Record::Record228(record) => self.t228.push(record).await,
      Record::Record229(record) => self.t229.push(record).await,
      Record::Record230(record) => self.t230.push(record).await,
      Record::Record231(record) => self.t231.push(record).await,
      Record::Record232(record) => self.t232.push(record).await,
      Record::Record233(record) => self.t233.push(record).await,
      Record::Record234(record) => self.t234.push(record).await,
      Record::Record235(record) => self.t235.push(record).await,
      Record::Record236(record) => self.t236.push(record).await,
      Record::Record237(record) => self.t237.push(record).await,
      Record::Record238(record) => self.t238.push(record).await,
      Record::Record239(record) => self.t239.push(record).await,
      Record::Record240(record) => self.t240.push(record).await,
      Record::Record241(record) => self.t241.push(record).await,
      Record::Record242(record) => self.t242.push(record).await,
      Record::Record243(record) => self.t243.push(record).await,
      Record::Record244(record) => self.t244.push(record).await,
      Record::Record245(record) => self.t245.push(record).await,
      Record::Record246(record) => self.t246.push(record).await,
      Record::Record247(record) => self.t247.push(record).await,
      Record::Record248(record) => self.t248.push(record).await,
      Record::Record249(record) => self.t249.push(record).await,
      Record::Record250(record) => self.t250.push(record).await,
      Record::Record251(record) => self.t251.push(record).await,
      Record::Record252(record) => self.t252.push(record).await,
      Record::Record253(record) => self.t253.push(record).await,
      Record::Record254(record) => self.t254.push(record).await,
      Record::Record255(record) => self.t255.push(record).await,
      Record::Record256(record) => self.t256.push(record).await,
      Record::Record257(record) => self.t257.push(record).await,
      Record::Record258(record) => self.t258.push(record).await,
      Record::Record259(record) => self.t259.push(record).await,
      Record::Record260(record) => self.t260.push(record).await,
      Record::Record261(record) => self.t261.push(record).await,
      Record::Record262(record) => self.t262.push(record).await,
      Record::Record263(record) => self.t263.push(record).await,
      Record::Record264(record) => self.t264.push(record).await,
      Record::Record265(record) => self.t265.push(record).await,
      Record::Record266(record) => self.t266.push(record).await,
      Record::Record267(record) => self.t267.push(record).await,
      Record::Record268(record) => self.t268.push(record).await,
      Record::Record269(record) => self.t269.push(record).await,
      Record::Record270(record) => self.t270.push(record).await,
      Record::Record271(record) => self.t271.push(record).await,
      Record::Record272(record) => self.t272.push(record).await,
      Record::Record273(record) => self.t273.push(record).await,
      Record::Record274(record) => self.t274.push(record).await,
      Record::Record275(record) => self.t275.push(record).await,
      Record::Record276(record) => self.t276.push(record).await,
      Record::Record277(record) => self.t277.push(record).await,
      Record::Record278(record) => self.t278.push(record).await,
      Record::Record279(record) => self.t279.push(record).await,
      Record::Record280(record) => self.t280.push(record).await,
      Record::Record281(record) => self.t281.push(record).await,
      Record::Record282(record) => self.t282.push(record).await,
      Record::Record283(record) => self.t283.push(record).await,
      Record::Record284(record) => self.t284.push(record).await,
      Record::Record285(record) => self.t285.push(record).await,
      Record::Record286(record) => self.t286.push(record).await,
      Record::Record287(record) => self.t287.push(record).await,
      Record::Record288(record) => self.t288.push(record).await,
      Record::Record289(record) => self.t289.push(record).await,
      Record::Record290(record) => self.t290.push(record).await,
      Record::Record291(record) => self.t291.push(record).await,
      Record::Record292(record) => self.t292.push(record).await,
      Record::Record293(record) => self.t293.push(record).await,
      Record::Record294(record) => self.t294.push(record).await,
      Record::Record295(record) => self.t295.push(record).await,
      Record::Record296(record) => self.t296.push(record).await,
      Record::Record297(record) => self.t297.push(record).await,
      Record::Record298(record) => self.t298.push(record).await,
      Record::Record299(record) => self.t299.push(record).await,
      Record::Record300(record) => self.t300.push(record).await,
      Record::Record301(record) => self.t301.push(record).await,
      Record::Record302(record) => self.t302.push(record).await,
      Record::Record303(record) => self.t303.push(record).await,
      Record::Record304(record) => self.t304.push(record).await,
      Record::Record305(record) => self.t305.push(record).await,
      Record::Record306(record) => self.t306.push(record).await,
      Record::Record307(record) => self.t307.push(record).await,
      Record::Record308(record) => self.t308.push(record).await,
      Record::Record309(record) => self.t309.push(record).await,
      Record::Record310(record) => self.t310.push(record).await,
      Record::Record311(record) => self.t311.push(record).await,
      Record::Record312(record) => self.t312.push(record).await,
      Record::Record313(record) => self.t313.push(record).await,
      Record::Record314(record) => self.t314.push(record).await,
      Record::Record315(record) => self.t315.push(record).await,
      Record::Record316(record) => self.t316.push(record).await,
      Record::Record317(record) => self.t317.push(record).await,
      Record::Record318(record) => self.t318.push(record).await,
      Record::Record319(record) => self.t319.push(record).await,
      Record::Record320(record) => self.t320.push(record).await,
      Record::Record321(record) => self.t321.push(record).await,
      Record::Record322(record) => self.t322.push(record).await,
      Record::Record323(record) => self.t323.push(record).await,
      Record::Record324(record) => self.t324.push(record).await,
      Record::Record325(record) => self.t325.push(record).await,
      Record::Record326(record) => self.t326.push(record).await,
      Record::Record327(record) => self.t327.push(record).await,
      Record::Record328(record) => self.t328.push(record).await,
      Record::Record329(record) => self.t329.push(record).await,
      Record::Record330(record) => self.t330.push(record).await,
      Record::Record331(record) => self.t331.push(record).await,
      Record::Record332(record) => self.t332.push(record).await,
      Record::Record333(record) => self.t333.push(record).await,
      Record::Record334(record) => self.t334.push(record).await,
      Record::Record335(record) => self.t335.push(record).await,
      Record::Record336(record) => self.t336.push(record).await,
      Record::Record337(record) => self.t337.push(record).await,
      Record::Record338(record) => self.t338.push(record).await,
      Record::Record339(record) => self.t339.push(record).await,
      Record::Record340(record) => self.t340.push(record).await,
      Record::Record341(record) => self.t341.push(record).await,
      Record::Record342(record) => self.t342.push(record).await,
      Record::Record343(record) => self.t343.push(record).await,
      Record::Record344(record) => self.t344.push(record).await,
      Record::Record345(record) => self.t345.push(record).await,
      Record::Record346(record) => self.t346.push(record).await,
      Record::Record347(record) => self.t347.push(record).await,
      Record::Record348(record) => self.t348.push(record).await,
      Record::Record349(record) => self.t349.push(record).await,
      Record::Record350(record) => self.t350.push(record).await,
      Record::Record351(record) => self.t351.push(record).await,
      Record::Record352(record) => self.t352.push(record).await,
      Record::Record353(record) => self.t353.push(record).await,
      Record::Record354(record) => self.t354.push(record).await,
    }
  }

  pub async fn flush(&mut self) -> Result<()> {
    self.t0.flush().await?;
    self.t1.flush().await?;
    self.t2.flush().await?;
    self.t3.flush().await?;
    self.t4.flush().await?;
    self.t5.flush().await?;
    self.t6.flush().await?;
    self.t7.flush().await?;
    self.t8.flush().await?;
    self.t9.flush().await?;
    self.t10.flush().await?;
    self.t11.flush().await?;
    self.t12.flush().await?;
    self.t13.flush().await?;
    self.t14.flush().await?;
    self.t15.flush().await?;
    self.t16.flush().await?;
    self.t17.flush().await?;
    self.t18.flush().await?;
    self.t19.flush().await?;
    self.t20.flush().await?;
    self.t21.flush().await?;
    self.t22.flush().await?;
    self.t23.flush().await?;
    self.t24.flush().await?;
    self.t25.flush().await?;
    self.t26.flush().await?;
    self.t27.flush().await?;
    self.t28.flush().await?;
    self.t29.flush().await?;
    self.t30.flush().await?;
    self.t31.flush().await?;
    self.t32.flush().await?;
    self.t33.flush().await?;
    self.t34.flush().await?;
    self.t35.flush().await?;
    self.t36.flush().await?;
    self.t37.flush().await?;
    self.t38.flush().await?;
    self.t39.flush().await?;
    self.t40.flush().await?;
    self.t41.flush().await?;
    self.t42.flush().await?;
    self.t43.flush().await?;
    self.t44.flush().await?;
    self.t45.flush().await?;
    self.t46.flush().await?;
    self.t47.flush().await?;
    self.t48.flush().await?;
    self.t49.flush().await?;
    self.t50.flush().await?;
    self.t51.flush().await?;
    self.t52.flush().await?;
    self.t53.flush().await?;
    self.t54.flush().await?;
    self.t55.flush().await?;
    self.t56.flush().await?;
    self.t57.flush().await?;
    self.t58.flush().await?;
    self.t59.flush().await?;
    self.t60.flush().await?;
    self.t61.flush().await?;
    self.t62.flush().await?;
    self.t63.flush().await?;
    self.t64.flush().await?;
    self.t65.flush().await?;
    self.t66.flush().await?;
    self.t67.flush().await?;
    self.t68.flush().await?;
    self.t69.flush().await?;
    self.t70.flush().await?;
    self.t71.flush().await?;
    self.t72.flush().await?;
    self.t73.flush().await?;
    self.t74.flush().await?;
    self.t75.flush().await?;
    self.t76.flush().await?;
    self.t77.flush().await?;
    self.t78.flush().await?;
    self.t79.flush().await?;
    self.t80.flush().await?;
    self.t81.flush().await?;
    self.t82.flush().await?;
    self.t83.flush().await?;
    self.t84.flush().await?;
    self.t85.flush().await?;
    self.t86.flush().await?;
    self.t87.flush().await?;
    self.t88.flush().await?;
    self.t89.flush().await?;
    self.t90.flush().await?;
    self.t91.flush().await?;
    self.t92.flush().await?;
    self.t93.flush().await?;
    self.t94.flush().await?;
    self.t95.flush().await?;
    self.t96.flush().await?;
    self.t97.flush().await?;
    self.t98.flush().await?;
    self.t99.flush().await?;
    self.t100.flush().await?;
    self.t101.flush().await?;
    self.t102.flush().await?;
    self.t103.flush().await?;
    self.t104.flush().await?;
    self.t105.flush().await?;
    self.t106.flush().await?;
    self.t107.flush().await?;
    self.t108.flush().await?;
    self.t109.flush().await?;
    self.t110.flush().await?;
    self.t111.flush().await?;
    self.t112.flush().await?;
    self.t113.flush().await?;
    self.t114.flush().await?;
    self.t115.flush().await?;
    self.t116.flush().await?;
    self.t117.flush().await?;
    self.t118.flush().await?;
    self.t119.flush().await?;
    self.t120.flush().await?;
    self.t121.flush().await?;
    self.t122.flush().await?;
    self.t123.flush().await?;
    self.t124.flush().await?;
    self.t125.flush().await?;
    self.t126.flush().await?;
    self.t127.flush().await?;
    self.t128.flush().await?;
    self.t129.flush().await?;
    self.t130.flush().await?;
    self.t131.flush().await?;
    self.t132.flush().await?;
    self.t133.flush().await?;
    self.t134.flush().await?;
    self.t135.flush().await?;
    self.t136.flush().await?;
    self.t137.flush().await?;
    self.t138.flush().await?;
    self.t139.flush().await?;
    self.t140.flush().await?;
    self.t141.flush().await?;
    self.t142.flush().await?;
    self.t143.flush().await?;
    self.t144.flush().await?;
    self.t145.flush().await?;
    self.t146.flush().await?;
    self.t147.flush().await?;
    self.t148.flush().await?;
    self.t149.flush().await?;
    self.t150.flush().await?;
    self.t151.flush().await?;
    self.t152.flush().await?;
    self.t153.flush().await?;
    self.t154.flush().await?;
    self.t155.flush().await?;
    self.t156.flush().await?;
    self.t157.flush().await?;
    self.t158.flush().await?;
    self.t159.flush().await?;
    self.t160.flush().await?;
    self.t161.flush().await?;
    self.t162.flush().await?;
    self.t163.flush().await?;
    self.t164.flush().await?;
    self.t165.flush().await?;
    self.t166.flush().await?;
    self.t167.flush().await?;
    self.t168.flush().await?;
    self.t169.flush().await?;
    self.t170.flush().await?;
    self.t171.flush().await?;
    self.t172.flush().await?;
    self.t173.flush().await?;
    self.t174.flush().await?;
    self.t175.flush().await?;
    self.t176.flush().await?;
    self.t177.flush().await?;
    self.t178.flush().await?;
    self.t179.flush().await?;
    self.t180.flush().await?;
    self.t181.flush().await?;
    self.t182.flush().await?;
    self.t183.flush().await?;
    self.t184.flush().await?;
    self.t185.flush().await?;
    self.t186.flush().await?;
    self.t187.flush().await?;
    self.t188.flush().await?;
    self.t189.flush().await?;
    self.t190.flush().await?;
    self.t191.flush().await?;
    self.t192.flush().await?;
    self.t193.flush().await?;
    self.t194.flush().await?;
    self.t195.flush().await?;
    self.t196.flush().await?;
    self.t197.flush().await?;
    self.t198.flush().await?;
    self.t199.flush().await?;
    self.t200.flush().await?;
    self.t201.flush().await?;
    self.t202.flush().await?;
    self.t203.flush().await?;
    self.t204.flush().await?;
    self.t205.flush().await?;
    self.t206.flush().await?;
    self.t207.flush().await?;
    self.t208.flush().await?;
    self.t209.flush().await?;
    self.t210.flush().await?;
    self.t211.flush().await?;
    self.t212.flush().await?;
    self.t213.flush().await?;
    self.t214.flush().await?;
    self.t215.flush().await?;
    self.t216.flush().await?;
    self.t217.flush().await?;
    self.t218.flush().await?;
    self.t219.flush().await?;
    self.t220.flush().await?;
    self.t221.flush().await?;
    self.t222.flush().await?;
    self.t223.flush().await?;
    self.t224.flush().await?;
    self.t225.flush().await?;
    self.t226.flush().await?;
    self.t227.flush().await?;
    self.t228.flush().await?;
    self.t229.flush().await?;
    self.t230.flush().await?;
    self.t231.flush().await?;
    self.t232.flush().await?;
    self.t233.flush().await?;
    self.t234.flush().await?;
    self.t235.flush().await?;
    self.t236.flush().await?;
    self.t237.flush().await?;
    self.t238.flush().await?;
    self.t239.flush().await?;
    self.t240.flush().await?;
    self.t241.flush().await?;
    self.t242.flush().await?;
    self.t243.flush().await?;
    self.t244.flush().await?;
    self.t245.flush().await?;
    self.t246.flush().await?;
    self.t247.flush().await?;
    self.t248.flush().await?;
    self.t249.flush().await?;
    self.t250.flush().await?;
    self.t251.flush().await?;
    self.t252.flush().await?;
    self.t253.flush().await?;
    self.t254.flush().await?;
    self.t255.flush().await?;
    self.t256.flush().await?;
    self.t257.flush().await?;
    self.t258.flush().await?;
    self.t259.flush().await?;
    self.t260.flush().await?;
    self.t261.flush().await?;
    self.t262.flush().await?;
    self.t263.flush().await?;
    self.t264.flush().await?;
    self.t265.flush().await?;
    self.t266.flush().await?;
    self.t267.flush().await?;
    self.t268.flush().await?;
    self.t269.flush().await?;
    self.t270.flush().await?;
    self.t271.flush().await?;
    self.t272.flush().await?;
    self.t273.flush().await?;
    self.t274.flush().await?;
    self.t275.flush().await?;
    self.t276.flush().await?;
    self.t277.flush().await?;
    self.t278.flush().await?;
    self.t279.flush().await?;
    self.t280.flush().await?;
    self.t281.flush().await?;
    self.t282.flush().await?;
    self.t283.flush().await?;
    self.t284.flush().await?;
    self.t285.flush().await?;
    self.t286.flush().await?;
    self.t287.flush().await?;
    self.t288.flush().await?;
    self.t289.flush().await?;
    self.t290.flush().await?;
    self.t291.flush().await?;
    self.t292.flush().await?;
    self.t293.flush().await?;
    self.t294.flush().await?;
    self.t295.flush().await?;
    self.t296.flush().await?;
    self.t297.flush().await?;
    self.t298.flush().await?;
    self.t299.flush().await?;
    self.t300.flush().await?;
    self.t301.flush().await?;
    self.t302.flush().await?;
    self.t303.flush().await?;
    self.t304.flush().await?;
    self.t305.flush().await?;
    self.t306.flush().await?;
    self.t307.flush().await?;
    self.t308.flush().await?;
    self.t309.flush().await?;
    self.t310.flush().await?;
    self.t311.flush().await?;
    self.t312.flush().await?;
    self.t313.flush().await?;
    self.t314.flush().await?;
    self.t315.flush().await?;
    self.t316.flush().await?;
    self.t317.flush().await?;
    self.t318.flush().await?;
    self.t319.flush().await?;
    self.t320.flush().await?;
    self.t321.flush().await?;
    self.t322.flush().await?;
    self.t323.flush().await?;
    self.t324.flush().await?;
    self.t325.flush().await?;
    self.t326.flush().await?;
    self.t327.flush().await?;
    self.t328.flush().await?;
    self.t329.flush().await?;
    self.t330.flush().await?;
    self.t331.flush().await?;
    self.t332.flush().await?;
    self.t333.flush().await?;
    self.t334.flush().await?;
    self.t335.flush().await?;
    self.t336.flush().await?;
    self.t337.flush().await?;
    self.t338.flush().await?;
    self.t339.flush().await?;
    self.t340.flush().await?;
    self.t341.flush().await?;
    self.t342.flush().await?;
    self.t343.flush().await?;
    self.t344.flush().await?;
    self.t345.flush().await?;
    self.t346.flush().await?;
    self.t347.flush().await?;
    self.t348.flush().await?;
    self.t349.flush().await?;
    self.t350.flush().await?;
    self.t351.flush().await?;
    self.t352.flush().await?;
    self.t353.flush().await?;
    self.t354.flush().await?;
    Ok(())
  }
  pub async fn cancel(&mut self) -> Result<()> {
    self.t0.cancel().await?;
    self.t1.cancel().await?;
    self.t2.cancel().await?;
    self.t3.cancel().await?;
    self.t4.cancel().await?;
    self.t5.cancel().await?;
    self.t6.cancel().await?;
    self.t7.cancel().await?;
    self.t8.cancel().await?;
    self.t9.cancel().await?;
    self.t10.cancel().await?;
    self.t11.cancel().await?;
    self.t12.cancel().await?;
    self.t13.cancel().await?;
    self.t14.cancel().await?;
    self.t15.cancel().await?;
    self.t16.cancel().await?;
    self.t17.cancel().await?;
    self.t18.cancel().await?;
    self.t19.cancel().await?;
    self.t20.cancel().await?;
    self.t21.cancel().await?;
    self.t22.cancel().await?;
    self.t23.cancel().await?;
    self.t24.cancel().await?;
    self.t25.cancel().await?;
    self.t26.cancel().await?;
    self.t27.cancel().await?;
    self.t28.cancel().await?;
    self.t29.cancel().await?;
    self.t30.cancel().await?;
    self.t31.cancel().await?;
    self.t32.cancel().await?;
    self.t33.cancel().await?;
    self.t34.cancel().await?;
    self.t35.cancel().await?;
    self.t36.cancel().await?;
    self.t37.cancel().await?;
    self.t38.cancel().await?;
    self.t39.cancel().await?;
    self.t40.cancel().await?;
    self.t41.cancel().await?;
    self.t42.cancel().await?;
    self.t43.cancel().await?;
    self.t44.cancel().await?;
    self.t45.cancel().await?;
    self.t46.cancel().await?;
    self.t47.cancel().await?;
    self.t48.cancel().await?;
    self.t49.cancel().await?;
    self.t50.cancel().await?;
    self.t51.cancel().await?;
    self.t52.cancel().await?;
    self.t53.cancel().await?;
    self.t54.cancel().await?;
    self.t55.cancel().await?;
    self.t56.cancel().await?;
    self.t57.cancel().await?;
    self.t58.cancel().await?;
    self.t59.cancel().await?;
    self.t60.cancel().await?;
    self.t61.cancel().await?;
    self.t62.cancel().await?;
    self.t63.cancel().await?;
    self.t64.cancel().await?;
    self.t65.cancel().await?;
    self.t66.cancel().await?;
    self.t67.cancel().await?;
    self.t68.cancel().await?;
    self.t69.cancel().await?;
    self.t70.cancel().await?;
    self.t71.cancel().await?;
    self.t72.cancel().await?;
    self.t73.cancel().await?;
    self.t74.cancel().await?;
    self.t75.cancel().await?;
    self.t76.cancel().await?;
    self.t77.cancel().await?;
    self.t78.cancel().await?;
    self.t79.cancel().await?;
    self.t80.cancel().await?;
    self.t81.cancel().await?;
    self.t82.cancel().await?;
    self.t83.cancel().await?;
    self.t84.cancel().await?;
    self.t85.cancel().await?;
    self.t86.cancel().await?;
    self.t87.cancel().await?;
    self.t88.cancel().await?;
    self.t89.cancel().await?;
    self.t90.cancel().await?;
    self.t91.cancel().await?;
    self.t92.cancel().await?;
    self.t93.cancel().await?;
    self.t94.cancel().await?;
    self.t95.cancel().await?;
    self.t96.cancel().await?;
    self.t97.cancel().await?;
    self.t98.cancel().await?;
    self.t99.cancel().await?;
    self.t100.cancel().await?;
    self.t101.cancel().await?;
    self.t102.cancel().await?;
    self.t103.cancel().await?;
    self.t104.cancel().await?;
    self.t105.cancel().await?;
    self.t106.cancel().await?;
    self.t107.cancel().await?;
    self.t108.cancel().await?;
    self.t109.cancel().await?;
    self.t110.cancel().await?;
    self.t111.cancel().await?;
    self.t112.cancel().await?;
    self.t113.cancel().await?;
    self.t114.cancel().await?;
    self.t115.cancel().await?;
    self.t116.cancel().await?;
    self.t117.cancel().await?;
    self.t118.cancel().await?;
    self.t119.cancel().await?;
    self.t120.cancel().await?;
    self.t121.cancel().await?;
    self.t122.cancel().await?;
    self.t123.cancel().await?;
    self.t124.cancel().await?;
    self.t125.cancel().await?;
    self.t126.cancel().await?;
    self.t127.cancel().await?;
    self.t128.cancel().await?;
    self.t129.cancel().await?;
    self.t130.cancel().await?;
    self.t131.cancel().await?;
    self.t132.cancel().await?;
    self.t133.cancel().await?;
    self.t134.cancel().await?;
    self.t135.cancel().await?;
    self.t136.cancel().await?;
    self.t137.cancel().await?;
    self.t138.cancel().await?;
    self.t139.cancel().await?;
    self.t140.cancel().await?;
    self.t141.cancel().await?;
    self.t142.cancel().await?;
    self.t143.cancel().await?;
    self.t144.cancel().await?;
    self.t145.cancel().await?;
    self.t146.cancel().await?;
    self.t147.cancel().await?;
    self.t148.cancel().await?;
    self.t149.cancel().await?;
    self.t150.cancel().await?;
    self.t151.cancel().await?;
    self.t152.cancel().await?;
    self.t153.cancel().await?;
    self.t154.cancel().await?;
    self.t155.cancel().await?;
    self.t156.cancel().await?;
    self.t157.cancel().await?;
    self.t158.cancel().await?;
    self.t159.cancel().await?;
    self.t160.cancel().await?;
    self.t161.cancel().await?;
    self.t162.cancel().await?;
    self.t163.cancel().await?;
    self.t164.cancel().await?;
    self.t165.cancel().await?;
    self.t166.cancel().await?;
    self.t167.cancel().await?;
    self.t168.cancel().await?;
    self.t169.cancel().await?;
    self.t170.cancel().await?;
    self.t171.cancel().await?;
    self.t172.cancel().await?;
    self.t173.cancel().await?;
    self.t174.cancel().await?;
    self.t175.cancel().await?;
    self.t176.cancel().await?;
    self.t177.cancel().await?;
    self.t178.cancel().await?;
    self.t179.cancel().await?;
    self.t180.cancel().await?;
    self.t181.cancel().await?;
    self.t182.cancel().await?;
    self.t183.cancel().await?;
    self.t184.cancel().await?;
    self.t185.cancel().await?;
    self.t186.cancel().await?;
    self.t187.cancel().await?;
    self.t188.cancel().await?;
    self.t189.cancel().await?;
    self.t190.cancel().await?;
    self.t191.cancel().await?;
    self.t192.cancel().await?;
    self.t193.cancel().await?;
    self.t194.cancel().await?;
    self.t195.cancel().await?;
    self.t196.cancel().await?;
    self.t197.cancel().await?;
    self.t198.cancel().await?;
    self.t199.cancel().await?;
    self.t200.cancel().await?;
    self.t201.cancel().await?;
    self.t202.cancel().await?;
    self.t203.cancel().await?;
    self.t204.cancel().await?;
    self.t205.cancel().await?;
    self.t206.cancel().await?;
    self.t207.cancel().await?;
    self.t208.cancel().await?;
    self.t209.cancel().await?;
    self.t210.cancel().await?;
    self.t211.cancel().await?;
    self.t212.cancel().await?;
    self.t213.cancel().await?;
    self.t214.cancel().await?;
    self.t215.cancel().await?;
    self.t216.cancel().await?;
    self.t217.cancel().await?;
    self.t218.cancel().await?;
    self.t219.cancel().await?;
    self.t220.cancel().await?;
    self.t221.cancel().await?;
    self.t222.cancel().await?;
    self.t223.cancel().await?;
    self.t224.cancel().await?;
    self.t225.cancel().await?;
    self.t226.cancel().await?;
    self.t227.cancel().await?;
    self.t228.cancel().await?;
    self.t229.cancel().await?;
    self.t230.cancel().await?;
    self.t231.cancel().await?;
    self.t232.cancel().await?;
    self.t233.cancel().await?;
    self.t234.cancel().await?;
    self.t235.cancel().await?;
    self.t236.cancel().await?;
    self.t237.cancel().await?;
    self.t238.cancel().await?;
    self.t239.cancel().await?;
    self.t240.cancel().await?;
    self.t241.cancel().await?;
    self.t242.cancel().await?;
    self.t243.cancel().await?;
    self.t244.cancel().await?;
    self.t245.cancel().await?;
    self.t246.cancel().await?;
    self.t247.cancel().await?;
    self.t248.cancel().await?;
    self.t249.cancel().await?;
    self.t250.cancel().await?;
    self.t251.cancel().await?;
    self.t252.cancel().await?;
    self.t253.cancel().await?;
    self.t254.cancel().await?;
    self.t255.cancel().await?;
    self.t256.cancel().await?;
    self.t257.cancel().await?;
    self.t258.cancel().await?;
    self.t259.cancel().await?;
    self.t260.cancel().await?;
    self.t261.cancel().await?;
    self.t262.cancel().await?;
    self.t263.cancel().await?;
    self.t264.cancel().await?;
    self.t265.cancel().await?;
    self.t266.cancel().await?;
    self.t267.cancel().await?;
    self.t268.cancel().await?;
    self.t269.cancel().await?;
    self.t270.cancel().await?;
    self.t271.cancel().await?;
    self.t272.cancel().await?;
    self.t273.cancel().await?;
    self.t274.cancel().await?;
    self.t275.cancel().await?;
    self.t276.cancel().await?;
    self.t277.cancel().await?;
    self.t278.cancel().await?;
    self.t279.cancel().await?;
    self.t280.cancel().await?;
    self.t281.cancel().await?;
    self.t282.cancel().await?;
    self.t283.cancel().await?;
    self.t284.cancel().await?;
    self.t285.cancel().await?;
    self.t286.cancel().await?;
    self.t287.cancel().await?;
    self.t288.cancel().await?;
    self.t289.cancel().await?;
    self.t290.cancel().await?;
    self.t291.cancel().await?;
    self.t292.cancel().await?;
    self.t293.cancel().await?;
    self.t294.cancel().await?;
    self.t295.cancel().await?;
    self.t296.cancel().await?;
    self.t297.cancel().await?;
    self.t298.cancel().await?;
    self.t299.cancel().await?;
    self.t300.cancel().await?;
    self.t301.cancel().await?;
    self.t302.cancel().await?;
    self.t303.cancel().await?;
    self.t304.cancel().await?;
    self.t305.cancel().await?;
    self.t306.cancel().await?;
    self.t307.cancel().await?;
    self.t308.cancel().await?;
    self.t309.cancel().await?;
    self.t310.cancel().await?;
    self.t311.cancel().await?;
    self.t312.cancel().await?;
    self.t313.cancel().await?;
    self.t314.cancel().await?;
    self.t315.cancel().await?;
    self.t316.cancel().await?;
    self.t317.cancel().await?;
    self.t318.cancel().await?;
    self.t319.cancel().await?;
    self.t320.cancel().await?;
    self.t321.cancel().await?;
    self.t322.cancel().await?;
    self.t323.cancel().await?;
    self.t324.cancel().await?;
    self.t325.cancel().await?;
    self.t326.cancel().await?;
    self.t327.cancel().await?;
    self.t328.cancel().await?;
    self.t329.cancel().await?;
    self.t330.cancel().await?;
    self.t331.cancel().await?;
    self.t332.cancel().await?;
    self.t333.cancel().await?;
    self.t334.cancel().await?;
    self.t335.cancel().await?;
    self.t336.cancel().await?;
    self.t337.cancel().await?;
    self.t338.cancel().await?;
    self.t339.cancel().await?;
    self.t340.cancel().await?;
    self.t341.cancel().await?;
    self.t342.cancel().await?;
    self.t343.cancel().await?;
    self.t344.cancel().await?;
    self.t345.cancel().await?;
    self.t346.cancel().await?;
    self.t347.cancel().await?;
    self.t348.cancel().await?;
    self.t349.cancel().await?;
    self.t350.cancel().await?;
    self.t351.cancel().await?;
    self.t352.cancel().await?;
    self.t353.cancel().await?;
    self.t354.cancel().await?;
    Ok(())
  }
}

pub struct TableBuilder0 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // filename
  c2: arrow::array::builder::StringBuilder, // content
  writer: ParquetWriter,
}

impl TableBuilder0 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("filename", DataType::Utf8, false),
      Field::new("content", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record0) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder1 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // file_id
  c2: arrow::array::builder::UInt64Builder, // line
  c3: arrow::array::builder::UInt64Builder, // col
  c4: arrow::array::builder::UInt64Builder, // expansion_loc
  c5: arrow::array::builder::UInt64Builder, // spelling_loc
  writer: ParquetWriter,
}

impl TableBuilder1 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("file_id", DataType::UInt64, false),
      Field::new("line", DataType::UInt64, false),
      Field::new("col", DataType::UInt64, false),
      Field::new("expansion_loc", DataType::UInt64, false),
      Field::new("spelling_loc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record1) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder2 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // begin
  c2: arrow::array::builder::UInt64Builder, // end
  writer: ParquetWriter,
}

impl TableBuilder2 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("begin", DataType::UInt64, false),
      Field::new("end", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record2) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder3 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // name
  writer: ParquetWriter,
}

impl TableBuilder3 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("name", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record3) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder4 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // enum_id
  c2: arrow::array::builder::StringBuilder, // name
  writer: ParquetWriter,
}

impl TableBuilder4 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("enum_id", DataType::UInt64, false),
      Field::new("name", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record4) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder5 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // Type_id
  c2: arrow::array::builder::BooleanBuilder, // is_const
  c3: arrow::array::builder::BooleanBuilder, // is_volatile
  c4: arrow::array::builder::BooleanBuilder, // is_restrict
  writer: ParquetWriter,
}

impl TableBuilder5 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("Type_id", DataType::UInt64, false),
      Field::new("is_const", DataType::Boolean, false),
      Field::new("is_volatile", DataType::Boolean, false),
      Field::new("is_restrict", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record5) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder6 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // entry_block_id
  c2: arrow::array::builder::UInt64Builder, // exit_block_id
  c3: arrow::array::builder::BooleanBuilder, // is_linear
  c4: arrow::array::builder::UInt64Builder, // indirect_goto
  writer: ParquetWriter,
}

impl TableBuilder6 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("entry_block_id", DataType::UInt64, false),
      Field::new("exit_block_id", DataType::UInt64, false),
      Field::new("is_linear", DataType::Boolean, false),
      Field::new("indirect_goto", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record6) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder7 {
  c0: arrow::array::builder::UInt64Builder, // CFG_id
  c1: arrow::array::builder::UInt64Builder, // CFGBlock_id
  writer: ParquetWriter,
}

impl TableBuilder7 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("CFG_id", DataType::UInt64, false),
      Field::new("CFGBlock_id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record7) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder8 {
  c0: arrow::array::builder::UInt64Builder, // CFG_id
  c1: arrow::array::builder::UInt64Builder, // CFGBlock_id
  writer: ParquetWriter,
}

impl TableBuilder8 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("CFG_id", DataType::UInt64, false),
      Field::new("CFGBlock_id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record8) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder9 {
  c0: arrow::array::builder::UInt64Builder, // CFGBlock_src
  c1: arrow::array::builder::UInt64Builder, // CFGBlock_dst
  writer: ParquetWriter,
}

impl TableBuilder9 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("CFGBlock_src", DataType::UInt64, false),
      Field::new("CFGBlock_dst", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record9) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder10 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // terminator_stmt
  c2: arrow::array::builder::UInt64Builder, // terminator_kind
  c3: arrow::array::builder::UInt64Builder, // terminator_cond
  c4: arrow::array::builder::UInt64Builder, // label_stmt
  c5: arrow::array::builder::UInt64Builder, // loop_target
  c6: arrow::array::builder::BooleanBuilder, // has_no_return_element
  writer: ParquetWriter,
}

impl TableBuilder10 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("terminator_stmt", DataType::UInt64, false),
      Field::new("terminator_kind", DataType::UInt64, false),
      Field::new("terminator_cond", DataType::UInt64, false),
      Field::new("label_stmt", DataType::UInt64, false),
      Field::new("loop_target", DataType::UInt64, false),
      Field::new("has_no_return_element", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record10) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder11 {
  c0: arrow::array::builder::UInt64Builder, // CFGBlock_id
  c1: arrow::array::builder::UInt64Builder, // CFGElement_id
  writer: ParquetWriter,
}

impl TableBuilder11 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("CFGBlock_id", DataType::UInt64, false),
      Field::new("CFGElement_id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record11) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder12 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // kind
  writer: ParquetWriter,
}

impl TableBuilder12 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("kind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record12) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder13 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInitializer
  writer: ParquetWriter,
}

impl TableBuilder13 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInitializer", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record13) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder14 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTriggerStmt
  c2: arrow::array::builder::UInt64Builder, // getVarDecl
  writer: ParquetWriter,
}

impl TableBuilder14 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTriggerStmt", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record14) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder15 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTriggerStmt
  c2: arrow::array::builder::UInt64Builder, // getVarDecl
  writer: ParquetWriter,
}

impl TableBuilder15 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTriggerStmt", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record15) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder16 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAllocatorExpr
  writer: ParquetWriter,
}

impl TableBuilder16 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAllocatorExpr", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record16) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder17 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTriggerStmt
  c2: arrow::array::builder::UInt64Builder, // getVarDecl
  writer: ParquetWriter,
}

impl TableBuilder17 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTriggerStmt", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record17) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder18 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLoopStmt
  writer: ParquetWriter,
}

impl TableBuilder18 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLoopStmt", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record18) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder19 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getStmt
  writer: ParquetWriter,
}

impl TableBuilder19 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getStmt", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record19) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder20 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getStmt
  c2: arrow::array::builder::UInt64Builder, // getConstructionContext
  writer: ParquetWriter,
}

impl TableBuilder20 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getStmt", DataType::UInt64, false),
      Field::new("getConstructionContext", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record20) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder21 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getStmt
  c2: arrow::array::builder::UInt64Builder, // getConstructionContext
  writer: ParquetWriter,
}

impl TableBuilder21 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getStmt", DataType::UInt64, false),
      Field::new("getConstructionContext", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record21) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder22 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDestructorDecl
  c2: arrow::array::builder::UInt64Builder, // getTriggerStmt
  c3: arrow::array::builder::UInt64Builder, // getVarDecl
  writer: ParquetWriter,
}

impl TableBuilder22 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDestructorDecl", DataType::UInt64, false),
      Field::new("getTriggerStmt", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record22) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder23 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDestructorDecl
  c2: arrow::array::builder::UInt64Builder, // getCXXRecordDecl
  c3: arrow::array::builder::UInt64Builder, // getDeleteExpr
  writer: ParquetWriter,
}

impl TableBuilder23 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDestructorDecl", DataType::UInt64, false),
      Field::new("getCXXRecordDecl", DataType::UInt64, false),
      Field::new("getDeleteExpr", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record23) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder24 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDestructorDecl
  c2: arrow::array::builder::UInt64Builder, // getBaseSpecifier
  writer: ParquetWriter,
}

impl TableBuilder24 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDestructorDecl", DataType::UInt64, false),
      Field::new("getBaseSpecifier", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record24) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder25 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDestructorDecl
  c2: arrow::array::builder::UInt64Builder, // getFieldDecl
  writer: ParquetWriter,
}

impl TableBuilder25 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDestructorDecl", DataType::UInt64, false),
      Field::new("getFieldDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record25) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder26 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDestructorDecl
  c2: arrow::array::builder::UInt64Builder, // getBindTemporaryExpr
  writer: ParquetWriter,
}

impl TableBuilder26 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDestructorDecl", DataType::UInt64, false),
      Field::new("getBindTemporaryExpr", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record26) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder27 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getVarDecl
  c2: arrow::array::builder::UInt64Builder, // getFunctionDecl
  writer: ParquetWriter,
}

impl TableBuilder27 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
      Field::new("getFunctionDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record27) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder28 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // usr
  writer: ParquetWriter,
}

impl TableBuilder28 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("usr", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record28) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder29 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // usr
  writer: ParquetWriter,
}

impl TableBuilder29 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("usr", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record29) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder30 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // cfg
  writer: ParquetWriter,
}

impl TableBuilder30 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("cfg", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record30) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder31 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder31 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record31) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder32 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder32 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record32) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder33 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAddrSpaceExpr
  c2: arrow::array::builder::UInt64Builder, // getPointeeType
  c3: arrow::array::builder::UInt64Builder, // getAttributeLoc
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder33 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAddrSpaceExpr", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
      Field::new("getAttributeLoc", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record33) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder34 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSizeExpr
  c2: arrow::array::builder::UInt64Builder, // getElementType
  c3: arrow::array::builder::UInt64Builder, // getAttributeLoc
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder34 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSizeExpr", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("getAttributeLoc", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record34) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder35 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isUnsigned
  c2: arrow::array::builder::BooleanBuilder, // isSigned
  c3: arrow::array::builder::UInt64Builder, // getNumBitsExpr
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder35 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isUnsigned", DataType::Boolean, false),
      Field::new("isSigned", DataType::Boolean, false),
      Field::new("getNumBitsExpr", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record35) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder36 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getReplacementType
  c2: arrow::array::builder::UInt64Builder, // getAssociatedDecl
  c3: arrow::array::builder::UInt64Builder, // getReplacedParameter
  c4: arrow::array::builder::UInt32Builder, // getIndex
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder36 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getReplacementType", DataType::UInt64, false),
      Field::new("getAssociatedDecl", DataType::UInt64, false),
      Field::new("getReplacedParameter", DataType::UInt64, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record36) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder37 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getElementType
  c2: arrow::array::builder::UInt32Builder, // getNumElements
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  c5: arrow::array::builder::UInt64Builder, // getVectorKind
  writer: ParquetWriter,
}

impl TableBuilder37 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("getNumElements", DataType::UInt32, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("getVectorKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record37) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder38 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUnderlyingType
  c2: arrow::array::builder::UInt64Builder, // getModifiedType
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder38 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUnderlyingType", DataType::UInt64, false),
      Field::new("getModifiedType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record38) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder39 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUnmodifiedType
  c2: arrow::array::builder::UInt64Builder, // desugar
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // getKind
  writer: ParquetWriter,
}

impl TableBuilder39 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUnmodifiedType", DataType::UInt64, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("getKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record39) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder40 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::BooleanBuilder, // isBeingDefined
  writer: ParquetWriter,
}

impl TableBuilder40 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isBeingDefined", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record40) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder41 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSizeExpr
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder41 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSizeExpr", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record41) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder42 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::BooleanBuilder, // hasConstFields
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder42 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("hasConstFields", DataType::Boolean, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record42) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder43 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getElementType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  c4: arrow::array::builder::BooleanBuilder, // isReadOnly
  writer: ParquetWriter,
}

impl TableBuilder43 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isReadOnly", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record43) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder44 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumRows
  c2: arrow::array::builder::UInt32Builder, // getNumColumns
  c3: arrow::array::builder::UInt32Builder, // getNumElementsFlattened
  writer: ParquetWriter,
}

impl TableBuilder44 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumRows", DataType::UInt32, false),
      Field::new("getNumColumns", DataType::UInt32, false),
      Field::new("getNumElementsFlattened", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record44) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder45 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getFoundDecl
  c2: arrow::array::builder::UInt64Builder, // getUnderlyingType
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  c5: arrow::array::builder::BooleanBuilder, // typeMatchesDecl
  writer: ParquetWriter,
}

impl TableBuilder45 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getFoundDecl", DataType::UInt64, false),
      Field::new("getUnderlyingType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("typeMatchesDecl", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record45) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder46 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getKeyword
  writer: ParquetWriter,
}

impl TableBuilder46 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getKeyword", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record46) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder47 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder47 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record47) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder48 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getRowExpr
  c2: arrow::array::builder::UInt64Builder, // getColumnExpr
  c3: arrow::array::builder::UInt64Builder, // getAttributeLoc
  writer: ParquetWriter,
}

impl TableBuilder48 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getRowExpr", DataType::UInt64, false),
      Field::new("getColumnExpr", DataType::UInt64, false),
      Field::new("getAttributeLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record48) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder49 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAttrKind
  c2: arrow::array::builder::UInt64Builder, // getModifiedType
  c3: arrow::array::builder::UInt64Builder, // getEquivalentType
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  c6: arrow::array::builder::BooleanBuilder, // isQualifier
  c7: arrow::array::builder::BooleanBuilder, // isMSTypeSpec
  c8: arrow::array::builder::BooleanBuilder, // isWebAssemblyFuncrefSpec
  c9: arrow::array::builder::BooleanBuilder, // isCallingConv
  writer: ParquetWriter,
}

impl TableBuilder49 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAttrKind", DataType::UInt64, false),
      Field::new("getModifiedType", DataType::UInt64, false),
      Field::new("getEquivalentType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isQualifier", DataType::Boolean, false),
      Field::new("isMSTypeSpec", DataType::Boolean, false),
      Field::new("isWebAssemblyFuncrefSpec", DataType::Boolean, false),
      Field::new("isCallingConv", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record49) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder50 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder50 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record50) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder51 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getDepth
  c2: arrow::array::builder::UInt32Builder, // getIndex
  c3: arrow::array::builder::BooleanBuilder, // isParameterPack
  c4: arrow::array::builder::UInt64Builder, // getDecl
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder51 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDepth", DataType::UInt32, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record51) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder52 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPointeeType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder52 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record52) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder53 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInjectedSpecializationType
  c2: arrow::array::builder::UInt64Builder, // getInjectedTST
  c3: arrow::array::builder::UInt64Builder, // getDecl
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder53 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInjectedSpecializationType", DataType::UInt64, false),
      Field::new("getInjectedTST", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record53) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder54 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAssociatedDecl
  c2: arrow::array::builder::UInt64Builder, // getReplacedParameter
  c3: arrow::array::builder::UInt32Builder, // getIndex
  c4: arrow::array::builder::BooleanBuilder, // getFinal
  c5: arrow::array::builder::UInt32Builder, // getNumArgs
  c6: arrow::array::builder::BooleanBuilder, // isSugared
  c7: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder54 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAssociatedDecl", DataType::UInt64, false),
      Field::new("getReplacedParameter", DataType::UInt64, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("getFinal", DataType::Boolean, false),
      Field::new("getNumArgs", DataType::UInt32, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record54) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder55 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getKind
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  c4: arrow::array::builder::BooleanBuilder, // isInteger
  c5: arrow::array::builder::BooleanBuilder, // isSignedInteger
  c6: arrow::array::builder::BooleanBuilder, // isUnsignedInteger
  c7: arrow::array::builder::BooleanBuilder, // isFloatingPoint
  c8: arrow::array::builder::BooleanBuilder, // isSVEBool
  c9: arrow::array::builder::BooleanBuilder, // isSVECount
  c10: arrow::array::builder::BooleanBuilder, // isPlaceholderType
  c11: arrow::array::builder::BooleanBuilder, // isNonOverloadPlaceholderType
  writer: ParquetWriter,
}

impl TableBuilder55 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getKind", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isInteger", DataType::Boolean, false),
      Field::new("isSignedInteger", DataType::Boolean, false),
      Field::new("isUnsignedInteger", DataType::Boolean, false),
      Field::new("isFloatingPoint", DataType::Boolean, false),
      Field::new("isSVEBool", DataType::Boolean, false),
      Field::new("isSVECount", DataType::Boolean, false),
      Field::new("isPlaceholderType", DataType::Boolean, false),
      Field::new("isNonOverloadPlaceholderType", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record55) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder56 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSizeExpr
  c2: arrow::array::builder::UInt64Builder, // getElementType
  c3: arrow::array::builder::UInt64Builder, // getAttributeLoc
  c4: arrow::array::builder::UInt64Builder, // getVectorKind
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder56 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSizeExpr", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("getAttributeLoc", DataType::UInt64, false),
      Field::new("getVectorKind", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record56) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder57 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder57 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record57) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder58 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInnerType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder58 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInnerType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record58) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder59 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  c3: arrow::array::builder::UInt64Builder, // getUnderlyingType
  c4: arrow::array::builder::UInt64Builder, // getBaseType
  c5: arrow::array::builder::UInt64Builder, // getUTTKind
  writer: ParquetWriter,
}

impl TableBuilder59 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("getUnderlyingType", DataType::UInt64, false),
      Field::new("getBaseType", DataType::UInt64, false),
      Field::new("getUTTKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record59) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder60 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder60 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record60) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder61 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getElementType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder61 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record61) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder62 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPointeeType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder62 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record62) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder63 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getWrappedType
  c2: arrow::array::builder::UInt64Builder, // getAttr
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder63 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getWrappedType", DataType::UInt64, false),
      Field::new("getAttr", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record63) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder64 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder64 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record64) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder65 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // containsUnexpandedParameterPack
  c2: arrow::array::builder::UInt64Builder, // getLocallyUnqualifiedSingleStepDesugaredType
  c3: arrow::array::builder::UInt64Builder, // getAsPlaceholderType
  c4: arrow::array::builder::UInt64Builder, // getObjCARCImplicitLifetime
  c5: arrow::array::builder::UInt64Builder, // getDependence
  c6: arrow::array::builder::BooleanBuilder, // containsErrors
  c7: arrow::array::builder::BooleanBuilder, // hasSizedVLAType
  c8: arrow::array::builder::BooleanBuilder, // hasUnnamedOrLocalType
  c9: arrow::array::builder::BooleanBuilder, // canDecayToPointerType
  c10: arrow::array::builder::BooleanBuilder, // hasPointerRepresentation
  c11: arrow::array::builder::BooleanBuilder, // hasObjCPointerRepresentation
  c12: arrow::array::builder::BooleanBuilder, // hasIntegerRepresentation
  c13: arrow::array::builder::BooleanBuilder, // hasSignedIntegerRepresentation
  c14: arrow::array::builder::BooleanBuilder, // hasUnsignedIntegerRepresentation
  c15: arrow::array::builder::BooleanBuilder, // hasFloatingRepresentation
  c16: arrow::array::builder::UInt64Builder, // getAsStructureType
  c17: arrow::array::builder::UInt64Builder, // getAsUnionType
  c18: arrow::array::builder::UInt64Builder, // getAsComplexIntegerType
  c19: arrow::array::builder::UInt64Builder, // getAsObjCInterfaceType
  c20: arrow::array::builder::UInt64Builder, // getAsObjCInterfacePointerType
  c21: arrow::array::builder::UInt64Builder, // getAsObjCQualifiedIdType
  c22: arrow::array::builder::UInt64Builder, // getAsObjCQualifiedClassType
  c23: arrow::array::builder::UInt64Builder, // getAsObjCQualifiedInterfaceType
  c24: arrow::array::builder::UInt64Builder, // getAsCXXRecordDecl
  c25: arrow::array::builder::UInt64Builder, // getAsRecordDecl
  c26: arrow::array::builder::UInt64Builder, // getAsTagDecl
  c27: arrow::array::builder::UInt64Builder, // getPointeeCXXRecordDecl
  c28: arrow::array::builder::UInt64Builder, // getBaseElementTypeUnsafe
  c29: arrow::array::builder::UInt64Builder, // getArrayElementTypeNoTypeQual
  c30: arrow::array::builder::UInt64Builder, // getPointeeOrArrayElementType
  c31: arrow::array::builder::UInt64Builder, // getLinkage
  c32: arrow::array::builder::UInt64Builder, // getVisibility
  c33: arrow::array::builder::BooleanBuilder, // acceptsObjCTypeParams
  c34: arrow::array::builder::UInt64Builder, // getCanonicalTypeInternal
  writer: ParquetWriter,
}

impl TableBuilder65 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("containsUnexpandedParameterPack", DataType::Boolean, false),
      Field::new("getLocallyUnqualifiedSingleStepDesugaredType", DataType::UInt64, false),
      Field::new("getAsPlaceholderType", DataType::UInt64, false),
      Field::new("getObjCARCImplicitLifetime", DataType::UInt64, false),
      Field::new("getDependence", DataType::UInt64, false),
      Field::new("containsErrors", DataType::Boolean, false),
      Field::new("hasSizedVLAType", DataType::Boolean, false),
      Field::new("hasUnnamedOrLocalType", DataType::Boolean, false),
      Field::new("canDecayToPointerType", DataType::Boolean, false),
      Field::new("hasPointerRepresentation", DataType::Boolean, false),
      Field::new("hasObjCPointerRepresentation", DataType::Boolean, false),
      Field::new("hasIntegerRepresentation", DataType::Boolean, false),
      Field::new("hasSignedIntegerRepresentation", DataType::Boolean, false),
      Field::new("hasUnsignedIntegerRepresentation", DataType::Boolean, false),
      Field::new("hasFloatingRepresentation", DataType::Boolean, false),
      Field::new("getAsStructureType", DataType::UInt64, false),
      Field::new("getAsUnionType", DataType::UInt64, false),
      Field::new("getAsComplexIntegerType", DataType::UInt64, false),
      Field::new("getAsObjCInterfaceType", DataType::UInt64, false),
      Field::new("getAsObjCInterfacePointerType", DataType::UInt64, false),
      Field::new("getAsObjCQualifiedIdType", DataType::UInt64, false),
      Field::new("getAsObjCQualifiedClassType", DataType::UInt64, false),
      Field::new("getAsObjCQualifiedInterfaceType", DataType::UInt64, false),
      Field::new("getAsCXXRecordDecl", DataType::UInt64, false),
      Field::new("getAsRecordDecl", DataType::UInt64, false),
      Field::new("getAsTagDecl", DataType::UInt64, false),
      Field::new("getPointeeCXXRecordDecl", DataType::UInt64, false),
      Field::new("getBaseElementTypeUnsafe", DataType::UInt64, false),
      Field::new("getArrayElementTypeNoTypeQual", DataType::UInt64, false),
      Field::new("getPointeeOrArrayElementType", DataType::UInt64, false),
      Field::new("getLinkage", DataType::UInt64, false),
      Field::new("getVisibility", DataType::UInt64, false),
      Field::new("acceptsObjCTypeParams", DataType::Boolean, false),
      Field::new("getCanonicalTypeInternal", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::UInt64Builder::new(),
      c20: arrow::array::builder::UInt64Builder::new(),
      c21: arrow::array::builder::UInt64Builder::new(),
      c22: arrow::array::builder::UInt64Builder::new(),
      c23: arrow::array::builder::UInt64Builder::new(),
      c24: arrow::array::builder::UInt64Builder::new(),
      c25: arrow::array::builder::UInt64Builder::new(),
      c26: arrow::array::builder::UInt64Builder::new(),
      c27: arrow::array::builder::UInt64Builder::new(),
      c28: arrow::array::builder::UInt64Builder::new(),
      c29: arrow::array::builder::UInt64Builder::new(),
      c30: arrow::array::builder::UInt64Builder::new(),
      c31: arrow::array::builder::UInt64Builder::new(),
      c32: arrow::array::builder::UInt64Builder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::UInt64Builder::new();
    self.c20 = arrow::array::builder::UInt64Builder::new();
    self.c21 = arrow::array::builder::UInt64Builder::new();
    self.c22 = arrow::array::builder::UInt64Builder::new();
    self.c23 = arrow::array::builder::UInt64Builder::new();
    self.c24 = arrow::array::builder::UInt64Builder::new();
    self.c25 = arrow::array::builder::UInt64Builder::new();
    self.c26 = arrow::array::builder::UInt64Builder::new();
    self.c27 = arrow::array::builder::UInt64Builder::new();
    self.c28 = arrow::array::builder::UInt64Builder::new();
    self.c29 = arrow::array::builder::UInt64Builder::new();
    self.c30 = arrow::array::builder::UInt64Builder::new();
    self.c31 = arrow::array::builder::UInt64Builder::new();
    self.c32 = arrow::array::builder::UInt64Builder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record65) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder66 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder66 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record66) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder67 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getValueType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder67 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getValueType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record67) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder68 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTypeConstraintConcept
  c2: arrow::array::builder::BooleanBuilder, // isConstrained
  c3: arrow::array::builder::BooleanBuilder, // isDecltypeAuto
  c4: arrow::array::builder::BooleanBuilder, // isGNUAutoType
  c5: arrow::array::builder::UInt64Builder, // getKeyword
  writer: ParquetWriter,
}

impl TableBuilder68 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTypeConstraintConcept", DataType::UInt64, false),
      Field::new("isConstrained", DataType::Boolean, false),
      Field::new("isDecltypeAuto", DataType::Boolean, false),
      Field::new("isGNUAutoType", DataType::Boolean, false),
      Field::new("getKeyword", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record68) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder69 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isCurrentInstantiation
  c2: arrow::array::builder::BooleanBuilder, // isTypeAlias
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder69 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isCurrentInstantiation", DataType::Boolean, false),
      Field::new("isTypeAlias", DataType::Boolean, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record69) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder70 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSpelledAsLValue
  c2: arrow::array::builder::BooleanBuilder, // isInnerRef
  c3: arrow::array::builder::UInt64Builder, // getPointeeTypeAsWritten
  c4: arrow::array::builder::UInt64Builder, // getPointeeType
  writer: ParquetWriter,
}

impl TableBuilder70 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSpelledAsLValue", DataType::Boolean, false),
      Field::new("isInnerRef", DataType::Boolean, false),
      Field::new("getPointeeTypeAsWritten", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record70) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder71 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  c3: arrow::array::builder::UInt64Builder, // getDeducedType
  c4: arrow::array::builder::BooleanBuilder, // isDeduced
  writer: ParquetWriter,
}

impl TableBuilder71 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("getDeducedType", DataType::UInt64, false),
      Field::new("isDeduced", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record71) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder72 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPattern
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder72 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPattern", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record72) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder73 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSizeExpr
  c2: arrow::array::builder::UInt64Builder, // getBracketsRange
  c3: arrow::array::builder::UInt64Builder, // getLBracketLoc
  c4: arrow::array::builder::UInt64Builder, // getRBracketLoc
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder73 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSizeExpr", DataType::UInt64, false),
      Field::new("getBracketsRange", DataType::UInt64, false),
      Field::new("getLBracketLoc", DataType::UInt64, false),
      Field::new("getRBracketLoc", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record73) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder74 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUnderlyingExpr
  c2: arrow::array::builder::UInt64Builder, // getUnderlyingType
  c3: arrow::array::builder::UInt64Builder, // desugar
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  writer: ParquetWriter,
}

impl TableBuilder74 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUnderlyingExpr", DataType::UInt64, false),
      Field::new("getUnderlyingType", DataType::UInt64, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record74) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder75 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder75 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record75) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder76 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder76 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record76) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder77 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUnderlyingExpr
  c2: arrow::array::builder::UInt64Builder, // getKind
  c3: arrow::array::builder::UInt64Builder, // desugar
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  writer: ParquetWriter,
}

impl TableBuilder77 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUnderlyingExpr", DataType::UInt64, false),
      Field::new("getKind", DataType::UInt64, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record77) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder78 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder78 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record78) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder79 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder79 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record79) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder80 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder80 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record80) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder81 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumParams
  c2: arrow::array::builder::UInt64Builder, // getExceptionSpecType
  c3: arrow::array::builder::BooleanBuilder, // hasExceptionSpec
  c4: arrow::array::builder::BooleanBuilder, // hasDynamicExceptionSpec
  c5: arrow::array::builder::BooleanBuilder, // hasNoexceptExceptionSpec
  c6: arrow::array::builder::BooleanBuilder, // hasDependentExceptionSpec
  c7: arrow::array::builder::BooleanBuilder, // hasInstantiationDependentExceptionSpec
  c8: arrow::array::builder::UInt32Builder, // getNumExceptions
  c9: arrow::array::builder::UInt64Builder, // getNoexceptExpr
  c10: arrow::array::builder::UInt64Builder, // getExceptionSpecDecl
  c11: arrow::array::builder::UInt64Builder, // getExceptionSpecTemplate
  c12: arrow::array::builder::UInt64Builder, // canThrow
  c13: arrow::array::builder::BooleanBuilder, // isVariadic
  c14: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c15: arrow::array::builder::BooleanBuilder, // isTemplateVariadic
  c16: arrow::array::builder::BooleanBuilder, // hasTrailingReturn
  c17: arrow::array::builder::UInt64Builder, // getRefQualifier
  c18: arrow::array::builder::BooleanBuilder, // hasExtParameterInfos
  c19: arrow::array::builder::UInt32Builder, // getAArch64SMEAttributes
  c20: arrow::array::builder::BooleanBuilder, // isSugared
  c21: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder81 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumParams", DataType::UInt32, false),
      Field::new("getExceptionSpecType", DataType::UInt64, false),
      Field::new("hasExceptionSpec", DataType::Boolean, false),
      Field::new("hasDynamicExceptionSpec", DataType::Boolean, false),
      Field::new("hasNoexceptExceptionSpec", DataType::Boolean, false),
      Field::new("hasDependentExceptionSpec", DataType::Boolean, false),
      Field::new("hasInstantiationDependentExceptionSpec", DataType::Boolean, false),
      Field::new("getNumExceptions", DataType::UInt32, false),
      Field::new("getNoexceptExpr", DataType::UInt64, false),
      Field::new("getExceptionSpecDecl", DataType::UInt64, false),
      Field::new("getExceptionSpecTemplate", DataType::UInt64, false),
      Field::new("canThrow", DataType::UInt64, false),
      Field::new("isVariadic", DataType::Boolean, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("isTemplateVariadic", DataType::Boolean, false),
      Field::new("hasTrailingReturn", DataType::Boolean, false),
      Field::new("getRefQualifier", DataType::UInt64, false),
      Field::new("hasExtParameterInfos", DataType::Boolean, false),
      Field::new("getAArch64SMEAttributes", DataType::UInt32, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt32Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::UInt32Builder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt32Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::UInt32Builder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record81) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder82 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOriginalType
  c2: arrow::array::builder::UInt64Builder, // getAdjustedType
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder82 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOriginalType", DataType::UInt64, false),
      Field::new("getAdjustedType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record82) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder83 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getElementType
  c2: arrow::array::builder::UInt64Builder, // getSizeModifier
  c3: arrow::array::builder::UInt32Builder, // getIndexTypeCVRQualifiers
  writer: ParquetWriter,
}

impl TableBuilder83 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("getSizeModifier", DataType::UInt64, false),
      Field::new("getIndexTypeCVRQualifiers", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record83) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder84 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSizeExpr
  c2: arrow::array::builder::UInt64Builder, // getBracketsRange
  c3: arrow::array::builder::UInt64Builder, // getLBracketLoc
  c4: arrow::array::builder::UInt64Builder, // getRBracketLoc
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder84 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSizeExpr", DataType::UInt64, false),
      Field::new("getBracketsRange", DataType::UInt64, false),
      Field::new("getLBracketLoc", DataType::UInt64, false),
      Field::new("getRBracketLoc", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record84) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder85 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder85 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record85) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder86 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder86 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record86) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder87 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecayedType
  c2: arrow::array::builder::UInt64Builder, // getPointeeType
  writer: ParquetWriter,
}

impl TableBuilder87 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecayedType", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record87) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder88 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPointeeType
  c2: arrow::array::builder::BooleanBuilder, // isMemberFunctionPointer
  c3: arrow::array::builder::BooleanBuilder, // isMemberDataPointer
  c4: arrow::array::builder::UInt64Builder, // getClass
  c5: arrow::array::builder::BooleanBuilder, // isSugared
  c6: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder88 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPointeeType", DataType::UInt64, false),
      Field::new("isMemberFunctionPointer", DataType::Boolean, false),
      Field::new("isMemberDataPointer", DataType::Boolean, false),
      Field::new("getClass", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record88) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder89 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isUnsigned
  c2: arrow::array::builder::BooleanBuilder, // isSigned
  c3: arrow::array::builder::UInt32Builder, // getNumBits
  c4: arrow::array::builder::BooleanBuilder, // isSugared
  c5: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder89 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isUnsigned", DataType::Boolean, false),
      Field::new("isSigned", DataType::Boolean, false),
      Field::new("getNumBits", DataType::UInt32, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record89) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder90 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  c4: arrow::array::builder::BooleanBuilder, // typeMatchesDecl
  writer: ParquetWriter,
}

impl TableBuilder90 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("typeMatchesDecl", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record90) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder91 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getReturnType
  c2: arrow::array::builder::BooleanBuilder, // getHasRegParm
  c3: arrow::array::builder::UInt32Builder, // getRegParmType
  c4: arrow::array::builder::BooleanBuilder, // getNoReturnAttr
  c5: arrow::array::builder::BooleanBuilder, // getCmseNSCallAttr
  c6: arrow::array::builder::UInt64Builder, // getCallConv
  c7: arrow::array::builder::BooleanBuilder, // isConst
  c8: arrow::array::builder::BooleanBuilder, // isVolatile
  c9: arrow::array::builder::BooleanBuilder, // isRestrict
  writer: ParquetWriter,
}

impl TableBuilder91 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getReturnType", DataType::UInt64, false),
      Field::new("getHasRegParm", DataType::Boolean, false),
      Field::new("getRegParmType", DataType::UInt32, false),
      Field::new("getNoReturnAttr", DataType::Boolean, false),
      Field::new("getCmseNSCallAttr", DataType::Boolean, false),
      Field::new("getCallConv", DataType::UInt64, false),
      Field::new("isConst", DataType::Boolean, false),
      Field::new("isVolatile", DataType::Boolean, false),
      Field::new("isRestrict", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record91) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder92 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSugared
  c2: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder92 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record92) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder93 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNamedType
  c2: arrow::array::builder::UInt64Builder, // desugar
  c3: arrow::array::builder::BooleanBuilder, // isSugared
  c4: arrow::array::builder::UInt64Builder, // getOwnedTagDecl
  writer: ParquetWriter,
}

impl TableBuilder93 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNamedType", DataType::UInt64, false),
      Field::new("desugar", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("getOwnedTagDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record93) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder94 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getElementType
  c2: arrow::array::builder::BooleanBuilder, // isSugared
  c3: arrow::array::builder::UInt64Builder, // desugar
  writer: ParquetWriter,
}

impl TableBuilder94 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getElementType", DataType::UInt64, false),
      Field::new("isSugared", DataType::Boolean, false),
      Field::new("desugar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record94) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder95 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasAssociatedConstraints
  c2: arrow::array::builder::UInt64Builder, // getInstantiatedFromMember
  c3: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  c4: arrow::array::builder::UInt64Builder, // getInjectedSpecializationType
  writer: ParquetWriter,
}

impl TableBuilder95 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasAssociatedConstraints", DataType::Boolean, false),
      Field::new("getInstantiatedFromMember", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
      Field::new("getInjectedSpecializationType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record95) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder96 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder96 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record96) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder97 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder97 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record97) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder98 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder98 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record98) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder99 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder99 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record99) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder100 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder100 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record100) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder101 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c2: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c3: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c4: arrow::array::builder::UInt64Builder, // getDefinition
  c5: arrow::array::builder::BooleanBuilder, // hasDefinition
  c6: arrow::array::builder::BooleanBuilder, // isDynamicClass
  c7: arrow::array::builder::BooleanBuilder, // mayBeDynamicClass
  c8: arrow::array::builder::BooleanBuilder, // mayBeNonDynamicClass
  c9: arrow::array::builder::BooleanBuilder, // isParsingBaseSpecifiers
  c10: arrow::array::builder::UInt32Builder, // getODRHash
  c11: arrow::array::builder::UInt32Builder, // getNumBases
  c12: arrow::array::builder::UInt32Builder, // getNumVBases
  c13: arrow::array::builder::BooleanBuilder, // hasAnyDependentBases
  c14: arrow::array::builder::BooleanBuilder, // hasFriends
  c15: arrow::array::builder::BooleanBuilder, // hasSimpleCopyConstructor
  c16: arrow::array::builder::BooleanBuilder, // hasSimpleMoveConstructor
  c17: arrow::array::builder::BooleanBuilder, // hasSimpleCopyAssignment
  c18: arrow::array::builder::BooleanBuilder, // hasSimpleMoveAssignment
  c19: arrow::array::builder::BooleanBuilder, // hasSimpleDestructor
  c20: arrow::array::builder::BooleanBuilder, // hasDefaultConstructor
  c21: arrow::array::builder::BooleanBuilder, // needsImplicitDefaultConstructor
  c22: arrow::array::builder::BooleanBuilder, // hasUserDeclaredConstructor
  c23: arrow::array::builder::BooleanBuilder, // hasUserProvidedDefaultConstructor
  c24: arrow::array::builder::BooleanBuilder, // hasUserDeclaredCopyConstructor
  c25: arrow::array::builder::BooleanBuilder, // needsImplicitCopyConstructor
  c26: arrow::array::builder::BooleanBuilder, // needsOverloadResolutionForCopyConstructor
  c27: arrow::array::builder::BooleanBuilder, // implicitCopyConstructorHasConstParam
  c28: arrow::array::builder::BooleanBuilder, // hasCopyConstructorWithConstParam
  c29: arrow::array::builder::BooleanBuilder, // hasUserDeclaredMoveOperation
  c30: arrow::array::builder::BooleanBuilder, // hasUserDeclaredMoveConstructor
  c31: arrow::array::builder::BooleanBuilder, // hasMoveConstructor
  c32: arrow::array::builder::BooleanBuilder, // needsImplicitMoveConstructor
  c33: arrow::array::builder::BooleanBuilder, // needsOverloadResolutionForMoveConstructor
  c34: arrow::array::builder::BooleanBuilder, // hasUserDeclaredCopyAssignment
  c35: arrow::array::builder::BooleanBuilder, // needsImplicitCopyAssignment
  c36: arrow::array::builder::BooleanBuilder, // needsOverloadResolutionForCopyAssignment
  c37: arrow::array::builder::BooleanBuilder, // implicitCopyAssignmentHasConstParam
  c38: arrow::array::builder::BooleanBuilder, // hasCopyAssignmentWithConstParam
  c39: arrow::array::builder::BooleanBuilder, // hasUserDeclaredMoveAssignment
  c40: arrow::array::builder::BooleanBuilder, // hasMoveAssignment
  c41: arrow::array::builder::BooleanBuilder, // needsImplicitMoveAssignment
  c42: arrow::array::builder::BooleanBuilder, // needsOverloadResolutionForMoveAssignment
  c43: arrow::array::builder::BooleanBuilder, // hasUserDeclaredDestructor
  c44: arrow::array::builder::BooleanBuilder, // needsImplicitDestructor
  c45: arrow::array::builder::BooleanBuilder, // needsOverloadResolutionForDestructor
  c46: arrow::array::builder::BooleanBuilder, // isLambda
  c47: arrow::array::builder::BooleanBuilder, // isGenericLambda
  c48: arrow::array::builder::BooleanBuilder, // lambdaIsDefaultConstructibleAndAssignable
  c49: arrow::array::builder::UInt64Builder, // getLambdaCallOperator
  c50: arrow::array::builder::UInt64Builder, // getDependentLambdaCallOperator
  c51: arrow::array::builder::BooleanBuilder, // isCapturelessLambda
  c52: arrow::array::builder::BooleanBuilder, // isAggregate
  c53: arrow::array::builder::BooleanBuilder, // hasInClassInitializer
  c54: arrow::array::builder::BooleanBuilder, // hasUninitializedReferenceMember
  c55: arrow::array::builder::BooleanBuilder, // isPOD
  c56: arrow::array::builder::BooleanBuilder, // isCLike
  c57: arrow::array::builder::BooleanBuilder, // isEmpty
  c58: arrow::array::builder::BooleanBuilder, // hasInitMethod
  c59: arrow::array::builder::BooleanBuilder, // hasPrivateFields
  c60: arrow::array::builder::BooleanBuilder, // hasProtectedFields
  c61: arrow::array::builder::BooleanBuilder, // hasDirectFields
  c62: arrow::array::builder::BooleanBuilder, // isPolymorphic
  c63: arrow::array::builder::BooleanBuilder, // isAbstract
  c64: arrow::array::builder::BooleanBuilder, // isStandardLayout
  c65: arrow::array::builder::BooleanBuilder, // isCXX11StandardLayout
  c66: arrow::array::builder::BooleanBuilder, // hasMutableFields
  c67: arrow::array::builder::BooleanBuilder, // hasVariantMembers
  c68: arrow::array::builder::BooleanBuilder, // hasTrivialDefaultConstructor
  c69: arrow::array::builder::BooleanBuilder, // hasNonTrivialDefaultConstructor
  c70: arrow::array::builder::BooleanBuilder, // hasConstexprNonCopyMoveConstructor
  c71: arrow::array::builder::BooleanBuilder, // defaultedDefaultConstructorIsConstexpr
  c72: arrow::array::builder::BooleanBuilder, // hasConstexprDefaultConstructor
  c73: arrow::array::builder::BooleanBuilder, // hasTrivialCopyConstructor
  c74: arrow::array::builder::BooleanBuilder, // hasTrivialCopyConstructorForCall
  c75: arrow::array::builder::BooleanBuilder, // hasNonTrivialCopyConstructor
  c76: arrow::array::builder::BooleanBuilder, // hasNonTrivialCopyConstructorForCall
  c77: arrow::array::builder::BooleanBuilder, // hasTrivialMoveConstructor
  c78: arrow::array::builder::BooleanBuilder, // hasTrivialMoveConstructorForCall
  c79: arrow::array::builder::BooleanBuilder, // hasNonTrivialMoveConstructor
  c80: arrow::array::builder::BooleanBuilder, // hasNonTrivialMoveConstructorForCall
  c81: arrow::array::builder::BooleanBuilder, // hasTrivialCopyAssignment
  c82: arrow::array::builder::BooleanBuilder, // hasNonTrivialCopyAssignment
  c83: arrow::array::builder::BooleanBuilder, // hasTrivialMoveAssignment
  c84: arrow::array::builder::BooleanBuilder, // hasNonTrivialMoveAssignment
  c85: arrow::array::builder::BooleanBuilder, // defaultedDestructorIsConstexpr
  c86: arrow::array::builder::BooleanBuilder, // hasConstexprDestructor
  c87: arrow::array::builder::BooleanBuilder, // hasTrivialDestructor
  c88: arrow::array::builder::BooleanBuilder, // hasTrivialDestructorForCall
  c89: arrow::array::builder::BooleanBuilder, // hasNonTrivialDestructor
  c90: arrow::array::builder::BooleanBuilder, // hasNonTrivialDestructorForCall
  c91: arrow::array::builder::BooleanBuilder, // allowConstDefaultInit
  c92: arrow::array::builder::BooleanBuilder, // hasIrrelevantDestructor
  c93: arrow::array::builder::BooleanBuilder, // hasNonLiteralTypeFieldsOrBases
  c94: arrow::array::builder::BooleanBuilder, // hasInheritedConstructor
  c95: arrow::array::builder::BooleanBuilder, // hasInheritedAssignment
  c96: arrow::array::builder::BooleanBuilder, // isTriviallyCopyable
  c97: arrow::array::builder::BooleanBuilder, // isTriviallyCopyConstructible
  c98: arrow::array::builder::BooleanBuilder, // isTrivial
  c99: arrow::array::builder::BooleanBuilder, // isLiteral
  c100: arrow::array::builder::BooleanBuilder, // isStructural
  c101: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberClass
  c102: arrow::array::builder::UInt64Builder, // getDescribedClassTemplate
  c103: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKind
  c104: arrow::array::builder::UInt64Builder, // getTemplateInstantiationPattern
  c105: arrow::array::builder::UInt64Builder, // getDestructor
  c106: arrow::array::builder::BooleanBuilder, // isAnyDestructorNoReturn
  c107: arrow::array::builder::UInt64Builder, // isLocalClass
  c108: arrow::array::builder::BooleanBuilder, // mayBeAbstract
  c109: arrow::array::builder::BooleanBuilder, // isEffectivelyFinal
  c110: arrow::array::builder::UInt32Builder, // getDeviceLambdaManglingNumber
  c111: arrow::array::builder::UInt64Builder, // getMSVtorDispMode
  c112: arrow::array::builder::BooleanBuilder, // isDependentLambda
  c113: arrow::array::builder::BooleanBuilder, // isNeverDependentLambda
  c114: arrow::array::builder::UInt32Builder, // getLambdaDependencyKind
  writer: ParquetWriter,
}

impl TableBuilder101 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("hasDefinition", DataType::Boolean, false),
      Field::new("isDynamicClass", DataType::Boolean, false),
      Field::new("mayBeDynamicClass", DataType::Boolean, false),
      Field::new("mayBeNonDynamicClass", DataType::Boolean, false),
      Field::new("isParsingBaseSpecifiers", DataType::Boolean, false),
      Field::new("getODRHash", DataType::UInt32, false),
      Field::new("getNumBases", DataType::UInt32, false),
      Field::new("getNumVBases", DataType::UInt32, false),
      Field::new("hasAnyDependentBases", DataType::Boolean, false),
      Field::new("hasFriends", DataType::Boolean, false),
      Field::new("hasSimpleCopyConstructor", DataType::Boolean, false),
      Field::new("hasSimpleMoveConstructor", DataType::Boolean, false),
      Field::new("hasSimpleCopyAssignment", DataType::Boolean, false),
      Field::new("hasSimpleMoveAssignment", DataType::Boolean, false),
      Field::new("hasSimpleDestructor", DataType::Boolean, false),
      Field::new("hasDefaultConstructor", DataType::Boolean, false),
      Field::new("needsImplicitDefaultConstructor", DataType::Boolean, false),
      Field::new("hasUserDeclaredConstructor", DataType::Boolean, false),
      Field::new("hasUserProvidedDefaultConstructor", DataType::Boolean, false),
      Field::new("hasUserDeclaredCopyConstructor", DataType::Boolean, false),
      Field::new("needsImplicitCopyConstructor", DataType::Boolean, false),
      Field::new("needsOverloadResolutionForCopyConstructor", DataType::Boolean, false),
      Field::new("implicitCopyConstructorHasConstParam", DataType::Boolean, false),
      Field::new("hasCopyConstructorWithConstParam", DataType::Boolean, false),
      Field::new("hasUserDeclaredMoveOperation", DataType::Boolean, false),
      Field::new("hasUserDeclaredMoveConstructor", DataType::Boolean, false),
      Field::new("hasMoveConstructor", DataType::Boolean, false),
      Field::new("needsImplicitMoveConstructor", DataType::Boolean, false),
      Field::new("needsOverloadResolutionForMoveConstructor", DataType::Boolean, false),
      Field::new("hasUserDeclaredCopyAssignment", DataType::Boolean, false),
      Field::new("needsImplicitCopyAssignment", DataType::Boolean, false),
      Field::new("needsOverloadResolutionForCopyAssignment", DataType::Boolean, false),
      Field::new("implicitCopyAssignmentHasConstParam", DataType::Boolean, false),
      Field::new("hasCopyAssignmentWithConstParam", DataType::Boolean, false),
      Field::new("hasUserDeclaredMoveAssignment", DataType::Boolean, false),
      Field::new("hasMoveAssignment", DataType::Boolean, false),
      Field::new("needsImplicitMoveAssignment", DataType::Boolean, false),
      Field::new("needsOverloadResolutionForMoveAssignment", DataType::Boolean, false),
      Field::new("hasUserDeclaredDestructor", DataType::Boolean, false),
      Field::new("needsImplicitDestructor", DataType::Boolean, false),
      Field::new("needsOverloadResolutionForDestructor", DataType::Boolean, false),
      Field::new("isLambda", DataType::Boolean, false),
      Field::new("isGenericLambda", DataType::Boolean, false),
      Field::new("lambdaIsDefaultConstructibleAndAssignable", DataType::Boolean, false),
      Field::new("getLambdaCallOperator", DataType::UInt64, false),
      Field::new("getDependentLambdaCallOperator", DataType::UInt64, false),
      Field::new("isCapturelessLambda", DataType::Boolean, false),
      Field::new("isAggregate", DataType::Boolean, false),
      Field::new("hasInClassInitializer", DataType::Boolean, false),
      Field::new("hasUninitializedReferenceMember", DataType::Boolean, false),
      Field::new("isPOD", DataType::Boolean, false),
      Field::new("isCLike", DataType::Boolean, false),
      Field::new("isEmpty", DataType::Boolean, false),
      Field::new("hasInitMethod", DataType::Boolean, false),
      Field::new("hasPrivateFields", DataType::Boolean, false),
      Field::new("hasProtectedFields", DataType::Boolean, false),
      Field::new("hasDirectFields", DataType::Boolean, false),
      Field::new("isPolymorphic", DataType::Boolean, false),
      Field::new("isAbstract", DataType::Boolean, false),
      Field::new("isStandardLayout", DataType::Boolean, false),
      Field::new("isCXX11StandardLayout", DataType::Boolean, false),
      Field::new("hasMutableFields", DataType::Boolean, false),
      Field::new("hasVariantMembers", DataType::Boolean, false),
      Field::new("hasTrivialDefaultConstructor", DataType::Boolean, false),
      Field::new("hasNonTrivialDefaultConstructor", DataType::Boolean, false),
      Field::new("hasConstexprNonCopyMoveConstructor", DataType::Boolean, false),
      Field::new("defaultedDefaultConstructorIsConstexpr", DataType::Boolean, false),
      Field::new("hasConstexprDefaultConstructor", DataType::Boolean, false),
      Field::new("hasTrivialCopyConstructor", DataType::Boolean, false),
      Field::new("hasTrivialCopyConstructorForCall", DataType::Boolean, false),
      Field::new("hasNonTrivialCopyConstructor", DataType::Boolean, false),
      Field::new("hasNonTrivialCopyConstructorForCall", DataType::Boolean, false),
      Field::new("hasTrivialMoveConstructor", DataType::Boolean, false),
      Field::new("hasTrivialMoveConstructorForCall", DataType::Boolean, false),
      Field::new("hasNonTrivialMoveConstructor", DataType::Boolean, false),
      Field::new("hasNonTrivialMoveConstructorForCall", DataType::Boolean, false),
      Field::new("hasTrivialCopyAssignment", DataType::Boolean, false),
      Field::new("hasNonTrivialCopyAssignment", DataType::Boolean, false),
      Field::new("hasTrivialMoveAssignment", DataType::Boolean, false),
      Field::new("hasNonTrivialMoveAssignment", DataType::Boolean, false),
      Field::new("defaultedDestructorIsConstexpr", DataType::Boolean, false),
      Field::new("hasConstexprDestructor", DataType::Boolean, false),
      Field::new("hasTrivialDestructor", DataType::Boolean, false),
      Field::new("hasTrivialDestructorForCall", DataType::Boolean, false),
      Field::new("hasNonTrivialDestructor", DataType::Boolean, false),
      Field::new("hasNonTrivialDestructorForCall", DataType::Boolean, false),
      Field::new("allowConstDefaultInit", DataType::Boolean, false),
      Field::new("hasIrrelevantDestructor", DataType::Boolean, false),
      Field::new("hasNonLiteralTypeFieldsOrBases", DataType::Boolean, false),
      Field::new("hasInheritedConstructor", DataType::Boolean, false),
      Field::new("hasInheritedAssignment", DataType::Boolean, false),
      Field::new("isTriviallyCopyable", DataType::Boolean, false),
      Field::new("isTriviallyCopyConstructible", DataType::Boolean, false),
      Field::new("isTrivial", DataType::Boolean, false),
      Field::new("isLiteral", DataType::Boolean, false),
      Field::new("isStructural", DataType::Boolean, false),
      Field::new("getInstantiatedFromMemberClass", DataType::UInt64, false),
      Field::new("getDescribedClassTemplate", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKind", DataType::UInt64, false),
      Field::new("getTemplateInstantiationPattern", DataType::UInt64, false),
      Field::new("getDestructor", DataType::UInt64, false),
      Field::new("isAnyDestructorNoReturn", DataType::Boolean, false),
      Field::new("isLocalClass", DataType::UInt64, false),
      Field::new("mayBeAbstract", DataType::Boolean, false),
      Field::new("isEffectivelyFinal", DataType::Boolean, false),
      Field::new("getDeviceLambdaManglingNumber", DataType::UInt32, false),
      Field::new("getMSVtorDispMode", DataType::UInt64, false),
      Field::new("isDependentLambda", DataType::Boolean, false),
      Field::new("isNeverDependentLambda", DataType::Boolean, false),
      Field::new("getLambdaDependencyKind", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::UInt32Builder::new(),
      c11: arrow::array::builder::UInt32Builder::new(),
      c12: arrow::array::builder::UInt32Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::BooleanBuilder::new(),
      c25: arrow::array::builder::BooleanBuilder::new(),
      c26: arrow::array::builder::BooleanBuilder::new(),
      c27: arrow::array::builder::BooleanBuilder::new(),
      c28: arrow::array::builder::BooleanBuilder::new(),
      c29: arrow::array::builder::BooleanBuilder::new(),
      c30: arrow::array::builder::BooleanBuilder::new(),
      c31: arrow::array::builder::BooleanBuilder::new(),
      c32: arrow::array::builder::BooleanBuilder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::BooleanBuilder::new(),
      c35: arrow::array::builder::BooleanBuilder::new(),
      c36: arrow::array::builder::BooleanBuilder::new(),
      c37: arrow::array::builder::BooleanBuilder::new(),
      c38: arrow::array::builder::BooleanBuilder::new(),
      c39: arrow::array::builder::BooleanBuilder::new(),
      c40: arrow::array::builder::BooleanBuilder::new(),
      c41: arrow::array::builder::BooleanBuilder::new(),
      c42: arrow::array::builder::BooleanBuilder::new(),
      c43: arrow::array::builder::BooleanBuilder::new(),
      c44: arrow::array::builder::BooleanBuilder::new(),
      c45: arrow::array::builder::BooleanBuilder::new(),
      c46: arrow::array::builder::BooleanBuilder::new(),
      c47: arrow::array::builder::BooleanBuilder::new(),
      c48: arrow::array::builder::BooleanBuilder::new(),
      c49: arrow::array::builder::UInt64Builder::new(),
      c50: arrow::array::builder::UInt64Builder::new(),
      c51: arrow::array::builder::BooleanBuilder::new(),
      c52: arrow::array::builder::BooleanBuilder::new(),
      c53: arrow::array::builder::BooleanBuilder::new(),
      c54: arrow::array::builder::BooleanBuilder::new(),
      c55: arrow::array::builder::BooleanBuilder::new(),
      c56: arrow::array::builder::BooleanBuilder::new(),
      c57: arrow::array::builder::BooleanBuilder::new(),
      c58: arrow::array::builder::BooleanBuilder::new(),
      c59: arrow::array::builder::BooleanBuilder::new(),
      c60: arrow::array::builder::BooleanBuilder::new(),
      c61: arrow::array::builder::BooleanBuilder::new(),
      c62: arrow::array::builder::BooleanBuilder::new(),
      c63: arrow::array::builder::BooleanBuilder::new(),
      c64: arrow::array::builder::BooleanBuilder::new(),
      c65: arrow::array::builder::BooleanBuilder::new(),
      c66: arrow::array::builder::BooleanBuilder::new(),
      c67: arrow::array::builder::BooleanBuilder::new(),
      c68: arrow::array::builder::BooleanBuilder::new(),
      c69: arrow::array::builder::BooleanBuilder::new(),
      c70: arrow::array::builder::BooleanBuilder::new(),
      c71: arrow::array::builder::BooleanBuilder::new(),
      c72: arrow::array::builder::BooleanBuilder::new(),
      c73: arrow::array::builder::BooleanBuilder::new(),
      c74: arrow::array::builder::BooleanBuilder::new(),
      c75: arrow::array::builder::BooleanBuilder::new(),
      c76: arrow::array::builder::BooleanBuilder::new(),
      c77: arrow::array::builder::BooleanBuilder::new(),
      c78: arrow::array::builder::BooleanBuilder::new(),
      c79: arrow::array::builder::BooleanBuilder::new(),
      c80: arrow::array::builder::BooleanBuilder::new(),
      c81: arrow::array::builder::BooleanBuilder::new(),
      c82: arrow::array::builder::BooleanBuilder::new(),
      c83: arrow::array::builder::BooleanBuilder::new(),
      c84: arrow::array::builder::BooleanBuilder::new(),
      c85: arrow::array::builder::BooleanBuilder::new(),
      c86: arrow::array::builder::BooleanBuilder::new(),
      c87: arrow::array::builder::BooleanBuilder::new(),
      c88: arrow::array::builder::BooleanBuilder::new(),
      c89: arrow::array::builder::BooleanBuilder::new(),
      c90: arrow::array::builder::BooleanBuilder::new(),
      c91: arrow::array::builder::BooleanBuilder::new(),
      c92: arrow::array::builder::BooleanBuilder::new(),
      c93: arrow::array::builder::BooleanBuilder::new(),
      c94: arrow::array::builder::BooleanBuilder::new(),
      c95: arrow::array::builder::BooleanBuilder::new(),
      c96: arrow::array::builder::BooleanBuilder::new(),
      c97: arrow::array::builder::BooleanBuilder::new(),
      c98: arrow::array::builder::BooleanBuilder::new(),
      c99: arrow::array::builder::BooleanBuilder::new(),
      c100: arrow::array::builder::BooleanBuilder::new(),
      c101: arrow::array::builder::UInt64Builder::new(),
      c102: arrow::array::builder::UInt64Builder::new(),
      c103: arrow::array::builder::UInt64Builder::new(),
      c104: arrow::array::builder::UInt64Builder::new(),
      c105: arrow::array::builder::UInt64Builder::new(),
      c106: arrow::array::builder::BooleanBuilder::new(),
      c107: arrow::array::builder::UInt64Builder::new(),
      c108: arrow::array::builder::BooleanBuilder::new(),
      c109: arrow::array::builder::BooleanBuilder::new(),
      c110: arrow::array::builder::UInt32Builder::new(),
      c111: arrow::array::builder::UInt64Builder::new(),
      c112: arrow::array::builder::BooleanBuilder::new(),
      c113: arrow::array::builder::BooleanBuilder::new(),
      c114: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::UInt32Builder::new();
    self.c11 = arrow::array::builder::UInt32Builder::new();
    self.c12 = arrow::array::builder::UInt32Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::BooleanBuilder::new();
    self.c25 = arrow::array::builder::BooleanBuilder::new();
    self.c26 = arrow::array::builder::BooleanBuilder::new();
    self.c27 = arrow::array::builder::BooleanBuilder::new();
    self.c28 = arrow::array::builder::BooleanBuilder::new();
    self.c29 = arrow::array::builder::BooleanBuilder::new();
    self.c30 = arrow::array::builder::BooleanBuilder::new();
    self.c31 = arrow::array::builder::BooleanBuilder::new();
    self.c32 = arrow::array::builder::BooleanBuilder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::BooleanBuilder::new();
    self.c35 = arrow::array::builder::BooleanBuilder::new();
    self.c36 = arrow::array::builder::BooleanBuilder::new();
    self.c37 = arrow::array::builder::BooleanBuilder::new();
    self.c38 = arrow::array::builder::BooleanBuilder::new();
    self.c39 = arrow::array::builder::BooleanBuilder::new();
    self.c40 = arrow::array::builder::BooleanBuilder::new();
    self.c41 = arrow::array::builder::BooleanBuilder::new();
    self.c42 = arrow::array::builder::BooleanBuilder::new();
    self.c43 = arrow::array::builder::BooleanBuilder::new();
    self.c44 = arrow::array::builder::BooleanBuilder::new();
    self.c45 = arrow::array::builder::BooleanBuilder::new();
    self.c46 = arrow::array::builder::BooleanBuilder::new();
    self.c47 = arrow::array::builder::BooleanBuilder::new();
    self.c48 = arrow::array::builder::BooleanBuilder::new();
    self.c49 = arrow::array::builder::UInt64Builder::new();
    self.c50 = arrow::array::builder::UInt64Builder::new();
    self.c51 = arrow::array::builder::BooleanBuilder::new();
    self.c52 = arrow::array::builder::BooleanBuilder::new();
    self.c53 = arrow::array::builder::BooleanBuilder::new();
    self.c54 = arrow::array::builder::BooleanBuilder::new();
    self.c55 = arrow::array::builder::BooleanBuilder::new();
    self.c56 = arrow::array::builder::BooleanBuilder::new();
    self.c57 = arrow::array::builder::BooleanBuilder::new();
    self.c58 = arrow::array::builder::BooleanBuilder::new();
    self.c59 = arrow::array::builder::BooleanBuilder::new();
    self.c60 = arrow::array::builder::BooleanBuilder::new();
    self.c61 = arrow::array::builder::BooleanBuilder::new();
    self.c62 = arrow::array::builder::BooleanBuilder::new();
    self.c63 = arrow::array::builder::BooleanBuilder::new();
    self.c64 = arrow::array::builder::BooleanBuilder::new();
    self.c65 = arrow::array::builder::BooleanBuilder::new();
    self.c66 = arrow::array::builder::BooleanBuilder::new();
    self.c67 = arrow::array::builder::BooleanBuilder::new();
    self.c68 = arrow::array::builder::BooleanBuilder::new();
    self.c69 = arrow::array::builder::BooleanBuilder::new();
    self.c70 = arrow::array::builder::BooleanBuilder::new();
    self.c71 = arrow::array::builder::BooleanBuilder::new();
    self.c72 = arrow::array::builder::BooleanBuilder::new();
    self.c73 = arrow::array::builder::BooleanBuilder::new();
    self.c74 = arrow::array::builder::BooleanBuilder::new();
    self.c75 = arrow::array::builder::BooleanBuilder::new();
    self.c76 = arrow::array::builder::BooleanBuilder::new();
    self.c77 = arrow::array::builder::BooleanBuilder::new();
    self.c78 = arrow::array::builder::BooleanBuilder::new();
    self.c79 = arrow::array::builder::BooleanBuilder::new();
    self.c80 = arrow::array::builder::BooleanBuilder::new();
    self.c81 = arrow::array::builder::BooleanBuilder::new();
    self.c82 = arrow::array::builder::BooleanBuilder::new();
    self.c83 = arrow::array::builder::BooleanBuilder::new();
    self.c84 = arrow::array::builder::BooleanBuilder::new();
    self.c85 = arrow::array::builder::BooleanBuilder::new();
    self.c86 = arrow::array::builder::BooleanBuilder::new();
    self.c87 = arrow::array::builder::BooleanBuilder::new();
    self.c88 = arrow::array::builder::BooleanBuilder::new();
    self.c89 = arrow::array::builder::BooleanBuilder::new();
    self.c90 = arrow::array::builder::BooleanBuilder::new();
    self.c91 = arrow::array::builder::BooleanBuilder::new();
    self.c92 = arrow::array::builder::BooleanBuilder::new();
    self.c93 = arrow::array::builder::BooleanBuilder::new();
    self.c94 = arrow::array::builder::BooleanBuilder::new();
    self.c95 = arrow::array::builder::BooleanBuilder::new();
    self.c96 = arrow::array::builder::BooleanBuilder::new();
    self.c97 = arrow::array::builder::BooleanBuilder::new();
    self.c98 = arrow::array::builder::BooleanBuilder::new();
    self.c99 = arrow::array::builder::BooleanBuilder::new();
    self.c100 = arrow::array::builder::BooleanBuilder::new();
    self.c101 = arrow::array::builder::UInt64Builder::new();
    self.c102 = arrow::array::builder::UInt64Builder::new();
    self.c103 = arrow::array::builder::UInt64Builder::new();
    self.c104 = arrow::array::builder::UInt64Builder::new();
    self.c105 = arrow::array::builder::UInt64Builder::new();
    self.c106 = arrow::array::builder::BooleanBuilder::new();
    self.c107 = arrow::array::builder::UInt64Builder::new();
    self.c108 = arrow::array::builder::BooleanBuilder::new();
    self.c109 = arrow::array::builder::BooleanBuilder::new();
    self.c110 = arrow::array::builder::UInt32Builder::new();
    self.c111 = arrow::array::builder::UInt64Builder::new();
    self.c112 = arrow::array::builder::BooleanBuilder::new();
    self.c113 = arrow::array::builder::BooleanBuilder::new();
    self.c114 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record101) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    self.c35.append_value(record.c35);
    self.c36.append_value(record.c36);
    self.c37.append_value(record.c37);
    self.c38.append_value(record.c38);
    self.c39.append_value(record.c39);
    self.c40.append_value(record.c40);
    self.c41.append_value(record.c41);
    self.c42.append_value(record.c42);
    self.c43.append_value(record.c43);
    self.c44.append_value(record.c44);
    self.c45.append_value(record.c45);
    self.c46.append_value(record.c46);
    self.c47.append_value(record.c47);
    self.c48.append_value(record.c48);
    self.c49.append_value(record.c49);
    self.c50.append_value(record.c50);
    self.c51.append_value(record.c51);
    self.c52.append_value(record.c52);
    self.c53.append_value(record.c53);
    self.c54.append_value(record.c54);
    self.c55.append_value(record.c55);
    self.c56.append_value(record.c56);
    self.c57.append_value(record.c57);
    self.c58.append_value(record.c58);
    self.c59.append_value(record.c59);
    self.c60.append_value(record.c60);
    self.c61.append_value(record.c61);
    self.c62.append_value(record.c62);
    self.c63.append_value(record.c63);
    self.c64.append_value(record.c64);
    self.c65.append_value(record.c65);
    self.c66.append_value(record.c66);
    self.c67.append_value(record.c67);
    self.c68.append_value(record.c68);
    self.c69.append_value(record.c69);
    self.c70.append_value(record.c70);
    self.c71.append_value(record.c71);
    self.c72.append_value(record.c72);
    self.c73.append_value(record.c73);
    self.c74.append_value(record.c74);
    self.c75.append_value(record.c75);
    self.c76.append_value(record.c76);
    self.c77.append_value(record.c77);
    self.c78.append_value(record.c78);
    self.c79.append_value(record.c79);
    self.c80.append_value(record.c80);
    self.c81.append_value(record.c81);
    self.c82.append_value(record.c82);
    self.c83.append_value(record.c83);
    self.c84.append_value(record.c84);
    self.c85.append_value(record.c85);
    self.c86.append_value(record.c86);
    self.c87.append_value(record.c87);
    self.c88.append_value(record.c88);
    self.c89.append_value(record.c89);
    self.c90.append_value(record.c90);
    self.c91.append_value(record.c91);
    self.c92.append_value(record.c92);
    self.c93.append_value(record.c93);
    self.c94.append_value(record.c94);
    self.c95.append_value(record.c95);
    self.c96.append_value(record.c96);
    self.c97.append_value(record.c97);
    self.c98.append_value(record.c98);
    self.c99.append_value(record.c99);
    self.c100.append_value(record.c100);
    self.c101.append_value(record.c101);
    self.c102.append_value(record.c102);
    self.c103.append_value(record.c103);
    self.c104.append_value(record.c104);
    self.c105.append_value(record.c105);
    self.c106.append_value(record.c106);
    self.c107.append_value(record.c107);
    self.c108.append_value(record.c108);
    self.c109.append_value(record.c109);
    self.c110.append_value(record.c110);
    self.c111.append_value(record.c111);
    self.c112.append_value(record.c112);
    self.c113.append_value(record.c113);
    self.c114.append_value(record.c114);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
        Arc::new(self.c35.finish()),
        Arc::new(self.c36.finish()),
        Arc::new(self.c37.finish()),
        Arc::new(self.c38.finish()),
        Arc::new(self.c39.finish()),
        Arc::new(self.c40.finish()),
        Arc::new(self.c41.finish()),
        Arc::new(self.c42.finish()),
        Arc::new(self.c43.finish()),
        Arc::new(self.c44.finish()),
        Arc::new(self.c45.finish()),
        Arc::new(self.c46.finish()),
        Arc::new(self.c47.finish()),
        Arc::new(self.c48.finish()),
        Arc::new(self.c49.finish()),
        Arc::new(self.c50.finish()),
        Arc::new(self.c51.finish()),
        Arc::new(self.c52.finish()),
        Arc::new(self.c53.finish()),
        Arc::new(self.c54.finish()),
        Arc::new(self.c55.finish()),
        Arc::new(self.c56.finish()),
        Arc::new(self.c57.finish()),
        Arc::new(self.c58.finish()),
        Arc::new(self.c59.finish()),
        Arc::new(self.c60.finish()),
        Arc::new(self.c61.finish()),
        Arc::new(self.c62.finish()),
        Arc::new(self.c63.finish()),
        Arc::new(self.c64.finish()),
        Arc::new(self.c65.finish()),
        Arc::new(self.c66.finish()),
        Arc::new(self.c67.finish()),
        Arc::new(self.c68.finish()),
        Arc::new(self.c69.finish()),
        Arc::new(self.c70.finish()),
        Arc::new(self.c71.finish()),
        Arc::new(self.c72.finish()),
        Arc::new(self.c73.finish()),
        Arc::new(self.c74.finish()),
        Arc::new(self.c75.finish()),
        Arc::new(self.c76.finish()),
        Arc::new(self.c77.finish()),
        Arc::new(self.c78.finish()),
        Arc::new(self.c79.finish()),
        Arc::new(self.c80.finish()),
        Arc::new(self.c81.finish()),
        Arc::new(self.c82.finish()),
        Arc::new(self.c83.finish()),
        Arc::new(self.c84.finish()),
        Arc::new(self.c85.finish()),
        Arc::new(self.c86.finish()),
        Arc::new(self.c87.finish()),
        Arc::new(self.c88.finish()),
        Arc::new(self.c89.finish()),
        Arc::new(self.c90.finish()),
        Arc::new(self.c91.finish()),
        Arc::new(self.c92.finish()),
        Arc::new(self.c93.finish()),
        Arc::new(self.c94.finish()),
        Arc::new(self.c95.finish()),
        Arc::new(self.c96.finish()),
        Arc::new(self.c97.finish()),
        Arc::new(self.c98.finish()),
        Arc::new(self.c99.finish()),
        Arc::new(self.c100.finish()),
        Arc::new(self.c101.finish()),
        Arc::new(self.c102.finish()),
        Arc::new(self.c103.finish()),
        Arc::new(self.c104.finish()),
        Arc::new(self.c105.finish()),
        Arc::new(self.c106.finish()),
        Arc::new(self.c107.finish()),
        Arc::new(self.c108.finish()),
        Arc::new(self.c109.finish()),
        Arc::new(self.c110.finish()),
        Arc::new(self.c111.finish()),
        Arc::new(self.c112.finish()),
        Arc::new(self.c113.finish()),
        Arc::new(self.c114.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder102 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBraceRange
  c2: arrow::array::builder::UInt64Builder, // getInnerLocStart
  c3: arrow::array::builder::UInt64Builder, // getOuterLocStart
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c6: arrow::array::builder::BooleanBuilder, // isThisDeclarationADefinition
  c7: arrow::array::builder::BooleanBuilder, // isCompleteDefinition
  c8: arrow::array::builder::BooleanBuilder, // isCompleteDefinitionRequired
  c9: arrow::array::builder::BooleanBuilder, // isBeingDefined
  c10: arrow::array::builder::BooleanBuilder, // isEmbeddedInDeclarator
  c11: arrow::array::builder::BooleanBuilder, // isFreeStanding
  c12: arrow::array::builder::BooleanBuilder, // mayHaveOutOfDateDef
  c13: arrow::array::builder::BooleanBuilder, // isDependentType
  c14: arrow::array::builder::BooleanBuilder, // isThisDeclarationADemotedDefinition
  c15: arrow::array::builder::UInt64Builder, // getDefinition
  c16: arrow::array::builder::StringBuilder, // getKindName
  c17: arrow::array::builder::UInt64Builder, // getTagKind
  c18: arrow::array::builder::BooleanBuilder, // isStruct
  c19: arrow::array::builder::BooleanBuilder, // isInterface
  c20: arrow::array::builder::BooleanBuilder, // isClass
  c21: arrow::array::builder::BooleanBuilder, // isUnion
  c22: arrow::array::builder::BooleanBuilder, // isEnum
  c23: arrow::array::builder::BooleanBuilder, // hasNameForLinkage
  c24: arrow::array::builder::UInt64Builder, // getTypedefNameForAnonDecl
  c25: arrow::array::builder::UInt32Builder, // getNumTemplateParameterLists
  writer: ParquetWriter,
}

impl TableBuilder102 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBraceRange", DataType::UInt64, false),
      Field::new("getInnerLocStart", DataType::UInt64, false),
      Field::new("getOuterLocStart", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::Boolean, false),
      Field::new("isCompleteDefinition", DataType::Boolean, false),
      Field::new("isCompleteDefinitionRequired", DataType::Boolean, false),
      Field::new("isBeingDefined", DataType::Boolean, false),
      Field::new("isEmbeddedInDeclarator", DataType::Boolean, false),
      Field::new("isFreeStanding", DataType::Boolean, false),
      Field::new("mayHaveOutOfDateDef", DataType::Boolean, false),
      Field::new("isDependentType", DataType::Boolean, false),
      Field::new("isThisDeclarationADemotedDefinition", DataType::Boolean, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("getKindName", DataType::Utf8, false),
      Field::new("getTagKind", DataType::UInt64, false),
      Field::new("isStruct", DataType::Boolean, false),
      Field::new("isInterface", DataType::Boolean, false),
      Field::new("isClass", DataType::Boolean, false),
      Field::new("isUnion", DataType::Boolean, false),
      Field::new("isEnum", DataType::Boolean, false),
      Field::new("hasNameForLinkage", DataType::Boolean, false),
      Field::new("getTypedefNameForAnonDecl", DataType::UInt64, false),
      Field::new("getNumTemplateParameterLists", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::StringBuilder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::UInt64Builder::new(),
      c25: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::StringBuilder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::UInt64Builder::new();
    self.c25 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record102) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder103 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getLocStart
  c3: arrow::array::builder::UInt64Builder, // getLBraceLoc
  c4: arrow::array::builder::UInt64Builder, // getRBraceLoc
  c5: arrow::array::builder::BooleanBuilder, // isCBuffer
  writer: ParquetWriter,
}

impl TableBuilder103 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getLocStart", DataType::UInt64, false),
      Field::new("getLBraceLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
      Field::new("isCBuffer", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record103) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder104 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNominatedNamespaceAsWritten
  c2: arrow::array::builder::UInt64Builder, // getNominatedNamespace
  c3: arrow::array::builder::UInt64Builder, // getUsingLoc
  c4: arrow::array::builder::UInt64Builder, // getNamespaceKeyLocation
  c5: arrow::array::builder::UInt64Builder, // getIdentLocation
  c6: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder104 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNominatedNamespaceAsWritten", DataType::UInt64, false),
      Field::new("getNominatedNamespace", DataType::UInt64, false),
      Field::new("getUsingLoc", DataType::UInt64, false),
      Field::new("getNamespaceKeyLocation", DataType::UInt64, false),
      Field::new("getIdentLocation", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record104) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder105 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c2: arrow::array::builder::UInt64Builder, // getNamespace
  c3: arrow::array::builder::UInt64Builder, // getAliasLoc
  c4: arrow::array::builder::UInt64Builder, // getNamespaceLoc
  c5: arrow::array::builder::UInt64Builder, // getTargetNameLoc
  c6: arrow::array::builder::UInt64Builder, // getAliasedNamespace
  c7: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder105 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getNamespace", DataType::UInt64, false),
      Field::new("getAliasLoc", DataType::UInt64, false),
      Field::new("getNamespaceLoc", DataType::UInt64, false),
      Field::new("getTargetNameLoc", DataType::UInt64, false),
      Field::new("getAliasedNamespace", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record105) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder106 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTypeForDecl
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder106 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTypeForDecl", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record106) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder107 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c2: arrow::array::builder::BooleanBuilder, // isMemberSpecialization
  c3: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  writer: ParquetWriter,
}

impl TableBuilder107 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("isMemberSpecialization", DataType::Boolean, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record107) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder108 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder108 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record108) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder109 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getIntroducer
  c2: arrow::array::builder::UInt64Builder, // getParent
  c3: arrow::array::builder::UInt64Builder, // getNominatedBaseClassShadowDecl
  c4: arrow::array::builder::UInt64Builder, // getConstructedBaseClassShadowDecl
  c5: arrow::array::builder::UInt64Builder, // getNominatedBaseClass
  c6: arrow::array::builder::UInt64Builder, // getConstructedBaseClass
  c7: arrow::array::builder::BooleanBuilder, // constructsVirtualBase
  writer: ParquetWriter,
}

impl TableBuilder109 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getIntroducer", DataType::UInt64, false),
      Field::new("getParent", DataType::UInt64, false),
      Field::new("getNominatedBaseClassShadowDecl", DataType::UInt64, false),
      Field::new("getConstructedBaseClassShadowDecl", DataType::UInt64, false),
      Field::new("getNominatedBaseClass", DataType::UInt64, false),
      Field::new("getConstructedBaseClass", DataType::UInt64, false),
      Field::new("constructsVirtualBase", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record109) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder110 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getBuiltinTemplateKind
  writer: ParquetWriter,
}

impl TableBuilder110 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getBuiltinTemplateKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record110) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder111 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c2: arrow::array::builder::UInt64Builder, // getTargetDecl
  c3: arrow::array::builder::UInt64Builder, // getIntroducer
  c4: arrow::array::builder::UInt64Builder, // getNextUsingShadowDecl
  writer: ParquetWriter,
}

impl TableBuilder111 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getTargetDecl", DataType::UInt64, false),
      Field::new("getIntroducer", DataType::UInt64, false),
      Field::new("getNextUsingShadowDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record111) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder112 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBinding
  c2: arrow::array::builder::UInt64Builder, // getDecomposedDecl
  c3: arrow::array::builder::UInt64Builder, // getHoldingVar
  writer: ParquetWriter,
}

impl TableBuilder112 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBinding", DataType::UInt64, false),
      Field::new("getDecomposedDecl", DataType::UInt64, false),
      Field::new("getHoldingVar", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record112) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder113 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUsingLoc
  c2: arrow::array::builder::BooleanBuilder, // isAccessDeclaration
  c3: arrow::array::builder::BooleanBuilder, // hasTypename
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder113 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUsingLoc", DataType::UInt64, false),
      Field::new("isAccessDeclaration", DataType::Boolean, false),
      Field::new("hasTypename", DataType::Boolean, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record113) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder114 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUsingLoc
  c2: arrow::array::builder::UInt64Builder, // getTypenameLoc
  c3: arrow::array::builder::BooleanBuilder, // isPackExpansion
  c4: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c5: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder114 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUsingLoc", DataType::UInt64, false),
      Field::new("getTypenameLoc", DataType::UInt64, false),
      Field::new("isPackExpansion", DataType::Boolean, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record114) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder115 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getStmt
  c2: arrow::array::builder::BooleanBuilder, // isGnuLocal
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  c4: arrow::array::builder::BooleanBuilder, // isMSAsmLabel
  c5: arrow::array::builder::BooleanBuilder, // isResolvedMSAsmLabel
  c6: arrow::array::builder::StringBuilder, // getMSAsmLabel
  writer: ParquetWriter,
}

impl TableBuilder115 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getStmt", DataType::UInt64, false),
      Field::new("isGnuLocal", DataType::Boolean, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("isMSAsmLabel", DataType::Boolean, false),
      Field::new("isResolvedMSAsmLabel", DataType::Boolean, false),
      Field::new("getMSAsmLabel", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record115) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder116 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder116 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record116) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder117 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // shadow_size
  writer: ParquetWriter,
}

impl TableBuilder117 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("shadow_size", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record117) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder118 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder118 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record118) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder119 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInstantiatedFromUsingDecl
  c2: arrow::array::builder::UInt64Builder, // getSourceRange
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder119 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInstantiatedFromUsingDecl", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record119) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder120 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder120 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record120) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder121 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isStatic
  c2: arrow::array::builder::BooleanBuilder, // isInstance
  c3: arrow::array::builder::BooleanBuilder, // isExplicitObjectMemberFunction
  c4: arrow::array::builder::BooleanBuilder, // isImplicitObjectMemberFunction
  c5: arrow::array::builder::BooleanBuilder, // isConst
  c6: arrow::array::builder::BooleanBuilder, // isVolatile
  c7: arrow::array::builder::BooleanBuilder, // isVirtual
  c8: arrow::array::builder::BooleanBuilder, // isCopyAssignmentOperator
  c9: arrow::array::builder::BooleanBuilder, // isMoveAssignmentOperator
  c10: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c11: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c12: arrow::array::builder::UInt32Builder, // size_overridden_methods
  c13: arrow::array::builder::UInt64Builder, // getParent
  c14: arrow::array::builder::UInt64Builder, // getThisType
  c15: arrow::array::builder::UInt64Builder, // getFunctionObjectParameterReferenceType
  c16: arrow::array::builder::UInt64Builder, // getFunctionObjectParameterType
  c17: arrow::array::builder::UInt32Builder, // getNumExplicitParams
  c18: arrow::array::builder::UInt64Builder, // getRefQualifier
  c19: arrow::array::builder::BooleanBuilder, // hasInlineBody
  c20: arrow::array::builder::BooleanBuilder, // isLambdaStaticInvoker
  writer: ParquetWriter,
}

impl TableBuilder121 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isStatic", DataType::Boolean, false),
      Field::new("isInstance", DataType::Boolean, false),
      Field::new("isExplicitObjectMemberFunction", DataType::Boolean, false),
      Field::new("isImplicitObjectMemberFunction", DataType::Boolean, false),
      Field::new("isConst", DataType::Boolean, false),
      Field::new("isVolatile", DataType::Boolean, false),
      Field::new("isVirtual", DataType::Boolean, false),
      Field::new("isCopyAssignmentOperator", DataType::Boolean, false),
      Field::new("isMoveAssignmentOperator", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("size_overridden_methods", DataType::UInt32, false),
      Field::new("getParent", DataType::UInt64, false),
      Field::new("getThisType", DataType::UInt64, false),
      Field::new("getFunctionObjectParameterReferenceType", DataType::UInt64, false),
      Field::new("getFunctionObjectParameterType", DataType::UInt64, false),
      Field::new("getNumExplicitParams", DataType::UInt32, false),
      Field::new("getRefQualifier", DataType::UInt64, false),
      Field::new("hasInlineBody", DataType::Boolean, false),
      Field::new("isLambdaStaticInvoker", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt32Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt32Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt32Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt32Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record121) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder122 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // wasDeclaredWithTypename
  c2: arrow::array::builder::BooleanBuilder, // hasDefaultArgument
  c3: arrow::array::builder::UInt64Builder, // getDefaultArgumentLoc
  c4: arrow::array::builder::BooleanBuilder, // defaultArgumentWasInherited
  c5: arrow::array::builder::UInt32Builder, // getDepth
  c6: arrow::array::builder::UInt32Builder, // getIndex
  c7: arrow::array::builder::BooleanBuilder, // isParameterPack
  c8: arrow::array::builder::BooleanBuilder, // isPackExpansion
  c9: arrow::array::builder::BooleanBuilder, // isExpandedParameterPack
  c10: arrow::array::builder::BooleanBuilder, // hasTypeConstraint
  c11: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder122 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("wasDeclaredWithTypename", DataType::Boolean, false),
      Field::new("hasDefaultArgument", DataType::Boolean, false),
      Field::new("getDefaultArgumentLoc", DataType::UInt64, false),
      Field::new("defaultArgumentWasInherited", DataType::Boolean, false),
      Field::new("getDepth", DataType::UInt32, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("isPackExpansion", DataType::Boolean, false),
      Field::new("isExpandedParameterPack", DataType::Boolean, false),
      Field::new("hasTypeConstraint", DataType::Boolean, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record122) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder123 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder123 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record123) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder124 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getStorageClass
  c3: arrow::array::builder::UInt64Builder, // getTSCSpec
  c4: arrow::array::builder::UInt64Builder, // getTLSKind
  c5: arrow::array::builder::BooleanBuilder, // hasLocalStorage
  c6: arrow::array::builder::BooleanBuilder, // isStaticLocal
  c7: arrow::array::builder::BooleanBuilder, // hasExternalStorage
  c8: arrow::array::builder::BooleanBuilder, // hasGlobalStorage
  c9: arrow::array::builder::UInt64Builder, // getStorageDuration
  c10: arrow::array::builder::UInt64Builder, // getLanguageLinkage
  c11: arrow::array::builder::BooleanBuilder, // isExternC
  c12: arrow::array::builder::BooleanBuilder, // isInExternCContext
  c13: arrow::array::builder::BooleanBuilder, // isInExternCXXContext
  c14: arrow::array::builder::BooleanBuilder, // isLocalVarDecl
  c15: arrow::array::builder::BooleanBuilder, // isLocalVarDeclOrParm
  c16: arrow::array::builder::BooleanBuilder, // isFunctionOrMethodVarDecl
  c17: arrow::array::builder::BooleanBuilder, // isStaticDataMember
  c18: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c19: arrow::array::builder::UInt64Builder, // isThisDeclarationADefinition
  c20: arrow::array::builder::UInt64Builder, // hasDefinition
  c21: arrow::array::builder::UInt64Builder, // getActingDefinition
  c22: arrow::array::builder::UInt64Builder, // getDefinition
  c23: arrow::array::builder::BooleanBuilder, // isOutOfLine
  c24: arrow::array::builder::BooleanBuilder, // isFileVarDecl
  c25: arrow::array::builder::UInt64Builder, // getAnyInitializer
  c26: arrow::array::builder::BooleanBuilder, // hasInit
  c27: arrow::array::builder::UInt64Builder, // getInit
  c28: arrow::array::builder::UInt64Builder, // getInitializingDeclaration
  c29: arrow::array::builder::BooleanBuilder, // hasConstantInitialization
  c30: arrow::array::builder::UInt64Builder, // getInitStyle
  c31: arrow::array::builder::BooleanBuilder, // isDirectInit
  c32: arrow::array::builder::BooleanBuilder, // isThisDeclarationADemotedDefinition
  c33: arrow::array::builder::BooleanBuilder, // isExceptionVariable
  c34: arrow::array::builder::BooleanBuilder, // isNRVOVariable
  c35: arrow::array::builder::BooleanBuilder, // isCXXForRangeDecl
  c36: arrow::array::builder::BooleanBuilder, // isObjCForDecl
  c37: arrow::array::builder::BooleanBuilder, // isARCPseudoStrong
  c38: arrow::array::builder::BooleanBuilder, // isInline
  c39: arrow::array::builder::BooleanBuilder, // isInlineSpecified
  c40: arrow::array::builder::BooleanBuilder, // isConstexpr
  c41: arrow::array::builder::BooleanBuilder, // isInitCapture
  c42: arrow::array::builder::BooleanBuilder, // isParameterPack
  c43: arrow::array::builder::BooleanBuilder, // isPreviousDeclInSameBlockScope
  c44: arrow::array::builder::BooleanBuilder, // isEscapingByref
  c45: arrow::array::builder::BooleanBuilder, // isNonEscapingByref
  c46: arrow::array::builder::BooleanBuilder, // hasDependentAlignment
  c47: arrow::array::builder::UInt64Builder, // getTemplateInstantiationPattern
  c48: arrow::array::builder::UInt64Builder, // getInstantiatedFromStaticDataMember
  c49: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKind
  c50: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKindForInstantiation
  c51: arrow::array::builder::UInt64Builder, // getPointOfInstantiation
  c52: arrow::array::builder::UInt64Builder, // getDescribedVarTemplate
  c53: arrow::array::builder::BooleanBuilder, // isKnownToBeDefined
  writer: ParquetWriter,
}

impl TableBuilder124 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getStorageClass", DataType::UInt64, false),
      Field::new("getTSCSpec", DataType::UInt64, false),
      Field::new("getTLSKind", DataType::UInt64, false),
      Field::new("hasLocalStorage", DataType::Boolean, false),
      Field::new("isStaticLocal", DataType::Boolean, false),
      Field::new("hasExternalStorage", DataType::Boolean, false),
      Field::new("hasGlobalStorage", DataType::Boolean, false),
      Field::new("getStorageDuration", DataType::UInt64, false),
      Field::new("getLanguageLinkage", DataType::UInt64, false),
      Field::new("isExternC", DataType::Boolean, false),
      Field::new("isInExternCContext", DataType::Boolean, false),
      Field::new("isInExternCXXContext", DataType::Boolean, false),
      Field::new("isLocalVarDecl", DataType::Boolean, false),
      Field::new("isLocalVarDeclOrParm", DataType::Boolean, false),
      Field::new("isFunctionOrMethodVarDecl", DataType::Boolean, false),
      Field::new("isStaticDataMember", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::UInt64, false),
      Field::new("hasDefinition", DataType::UInt64, false),
      Field::new("getActingDefinition", DataType::UInt64, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("isOutOfLine", DataType::Boolean, false),
      Field::new("isFileVarDecl", DataType::Boolean, false),
      Field::new("getAnyInitializer", DataType::UInt64, false),
      Field::new("hasInit", DataType::Boolean, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getInitializingDeclaration", DataType::UInt64, false),
      Field::new("hasConstantInitialization", DataType::Boolean, false),
      Field::new("getInitStyle", DataType::UInt64, false),
      Field::new("isDirectInit", DataType::Boolean, false),
      Field::new("isThisDeclarationADemotedDefinition", DataType::Boolean, false),
      Field::new("isExceptionVariable", DataType::Boolean, false),
      Field::new("isNRVOVariable", DataType::Boolean, false),
      Field::new("isCXXForRangeDecl", DataType::Boolean, false),
      Field::new("isObjCForDecl", DataType::Boolean, false),
      Field::new("isARCPseudoStrong", DataType::Boolean, false),
      Field::new("isInline", DataType::Boolean, false),
      Field::new("isInlineSpecified", DataType::Boolean, false),
      Field::new("isConstexpr", DataType::Boolean, false),
      Field::new("isInitCapture", DataType::Boolean, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("isPreviousDeclInSameBlockScope", DataType::Boolean, false),
      Field::new("isEscapingByref", DataType::Boolean, false),
      Field::new("isNonEscapingByref", DataType::Boolean, false),
      Field::new("hasDependentAlignment", DataType::Boolean, false),
      Field::new("getTemplateInstantiationPattern", DataType::UInt64, false),
      Field::new("getInstantiatedFromStaticDataMember", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKind", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKindForInstantiation", DataType::UInt64, false),
      Field::new("getPointOfInstantiation", DataType::UInt64, false),
      Field::new("getDescribedVarTemplate", DataType::UInt64, false),
      Field::new("isKnownToBeDefined", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::UInt64Builder::new(),
      c20: arrow::array::builder::UInt64Builder::new(),
      c21: arrow::array::builder::UInt64Builder::new(),
      c22: arrow::array::builder::UInt64Builder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::BooleanBuilder::new(),
      c25: arrow::array::builder::UInt64Builder::new(),
      c26: arrow::array::builder::BooleanBuilder::new(),
      c27: arrow::array::builder::UInt64Builder::new(),
      c28: arrow::array::builder::UInt64Builder::new(),
      c29: arrow::array::builder::BooleanBuilder::new(),
      c30: arrow::array::builder::UInt64Builder::new(),
      c31: arrow::array::builder::BooleanBuilder::new(),
      c32: arrow::array::builder::BooleanBuilder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::BooleanBuilder::new(),
      c35: arrow::array::builder::BooleanBuilder::new(),
      c36: arrow::array::builder::BooleanBuilder::new(),
      c37: arrow::array::builder::BooleanBuilder::new(),
      c38: arrow::array::builder::BooleanBuilder::new(),
      c39: arrow::array::builder::BooleanBuilder::new(),
      c40: arrow::array::builder::BooleanBuilder::new(),
      c41: arrow::array::builder::BooleanBuilder::new(),
      c42: arrow::array::builder::BooleanBuilder::new(),
      c43: arrow::array::builder::BooleanBuilder::new(),
      c44: arrow::array::builder::BooleanBuilder::new(),
      c45: arrow::array::builder::BooleanBuilder::new(),
      c46: arrow::array::builder::BooleanBuilder::new(),
      c47: arrow::array::builder::UInt64Builder::new(),
      c48: arrow::array::builder::UInt64Builder::new(),
      c49: arrow::array::builder::UInt64Builder::new(),
      c50: arrow::array::builder::UInt64Builder::new(),
      c51: arrow::array::builder::UInt64Builder::new(),
      c52: arrow::array::builder::UInt64Builder::new(),
      c53: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::UInt64Builder::new();
    self.c20 = arrow::array::builder::UInt64Builder::new();
    self.c21 = arrow::array::builder::UInt64Builder::new();
    self.c22 = arrow::array::builder::UInt64Builder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::BooleanBuilder::new();
    self.c25 = arrow::array::builder::UInt64Builder::new();
    self.c26 = arrow::array::builder::BooleanBuilder::new();
    self.c27 = arrow::array::builder::UInt64Builder::new();
    self.c28 = arrow::array::builder::UInt64Builder::new();
    self.c29 = arrow::array::builder::BooleanBuilder::new();
    self.c30 = arrow::array::builder::UInt64Builder::new();
    self.c31 = arrow::array::builder::BooleanBuilder::new();
    self.c32 = arrow::array::builder::BooleanBuilder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::BooleanBuilder::new();
    self.c35 = arrow::array::builder::BooleanBuilder::new();
    self.c36 = arrow::array::builder::BooleanBuilder::new();
    self.c37 = arrow::array::builder::BooleanBuilder::new();
    self.c38 = arrow::array::builder::BooleanBuilder::new();
    self.c39 = arrow::array::builder::BooleanBuilder::new();
    self.c40 = arrow::array::builder::BooleanBuilder::new();
    self.c41 = arrow::array::builder::BooleanBuilder::new();
    self.c42 = arrow::array::builder::BooleanBuilder::new();
    self.c43 = arrow::array::builder::BooleanBuilder::new();
    self.c44 = arrow::array::builder::BooleanBuilder::new();
    self.c45 = arrow::array::builder::BooleanBuilder::new();
    self.c46 = arrow::array::builder::BooleanBuilder::new();
    self.c47 = arrow::array::builder::UInt64Builder::new();
    self.c48 = arrow::array::builder::UInt64Builder::new();
    self.c49 = arrow::array::builder::UInt64Builder::new();
    self.c50 = arrow::array::builder::UInt64Builder::new();
    self.c51 = arrow::array::builder::UInt64Builder::new();
    self.c52 = arrow::array::builder::UInt64Builder::new();
    self.c53 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record124) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    self.c35.append_value(record.c35);
    self.c36.append_value(record.c36);
    self.c37.append_value(record.c37);
    self.c38.append_value(record.c38);
    self.c39.append_value(record.c39);
    self.c40.append_value(record.c40);
    self.c41.append_value(record.c41);
    self.c42.append_value(record.c42);
    self.c43.append_value(record.c43);
    self.c44.append_value(record.c44);
    self.c45.append_value(record.c45);
    self.c46.append_value(record.c46);
    self.c47.append_value(record.c47);
    self.c48.append_value(record.c48);
    self.c49.append_value(record.c49);
    self.c50.append_value(record.c50);
    self.c51.append_value(record.c51);
    self.c52.append_value(record.c52);
    self.c53.append_value(record.c53);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
        Arc::new(self.c35.finish()),
        Arc::new(self.c36.finish()),
        Arc::new(self.c37.finish()),
        Arc::new(self.c38.finish()),
        Arc::new(self.c39.finish()),
        Arc::new(self.c40.finish()),
        Arc::new(self.c41.finish()),
        Arc::new(self.c42.finish()),
        Arc::new(self.c43.finish()),
        Arc::new(self.c44.finish()),
        Arc::new(self.c45.finish()),
        Arc::new(self.c46.finish()),
        Arc::new(self.c47.finish()),
        Arc::new(self.c48.finish()),
        Arc::new(self.c49.finish()),
        Arc::new(self.c50.finish()),
        Arc::new(self.c51.finish()),
        Arc::new(self.c52.finish()),
        Arc::new(self.c53.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder125 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTemplatedDecl
  c2: arrow::array::builder::BooleanBuilder, // isThisDeclarationADefinition
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c4: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c5: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c6: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  c7: arrow::array::builder::BooleanBuilder, // isAbbreviated
  writer: ParquetWriter,
}

impl TableBuilder125 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTemplatedDecl", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
      Field::new("isAbbreviated", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record125) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder126 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTemplatedDecl
  c2: arrow::array::builder::BooleanBuilder, // isThisDeclarationADefinition
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c4: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c5: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c6: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  writer: ParquetWriter,
}

impl TableBuilder126 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTemplatedDecl", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record126) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder127 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isModed
  c2: arrow::array::builder::UInt64Builder, // getUnderlyingType
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c4: arrow::array::builder::BooleanBuilder, // isTransparentTag
  writer: ParquetWriter,
}

impl TableBuilder127 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isModed", DataType::Boolean, false),
      Field::new("getUnderlyingType", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("isTransparentTag", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record127) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder128 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTemplatedDecl
  c2: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c3: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c4: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  writer: ParquetWriter,
}

impl TableBuilder128 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTemplatedDecl", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record128) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder129 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder129 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record129) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder130 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c2: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c3: arrow::array::builder::BooleanBuilder, // hasFlexibleArrayMember
  c4: arrow::array::builder::BooleanBuilder, // isAnonymousStructOrUnion
  c5: arrow::array::builder::BooleanBuilder, // hasObjectMember
  c6: arrow::array::builder::BooleanBuilder, // hasVolatileMember
  c7: arrow::array::builder::BooleanBuilder, // hasLoadedFieldsFromExternalStorage
  c8: arrow::array::builder::BooleanBuilder, // isNonTrivialToPrimitiveDefaultInitialize
  c9: arrow::array::builder::BooleanBuilder, // isNonTrivialToPrimitiveCopy
  c10: arrow::array::builder::BooleanBuilder, // isNonTrivialToPrimitiveDestroy
  c11: arrow::array::builder::BooleanBuilder, // hasNonTrivialToPrimitiveDefaultInitializeCUnion
  c12: arrow::array::builder::BooleanBuilder, // hasNonTrivialToPrimitiveDestructCUnion
  c13: arrow::array::builder::BooleanBuilder, // hasNonTrivialToPrimitiveCopyCUnion
  c14: arrow::array::builder::BooleanBuilder, // canPassInRegisters
  c15: arrow::array::builder::UInt64Builder, // getArgPassingRestrictions
  c16: arrow::array::builder::BooleanBuilder, // isParamDestroyedInCallee
  c17: arrow::array::builder::BooleanBuilder, // isRandomized
  c18: arrow::array::builder::BooleanBuilder, // isInjectedClassName
  c19: arrow::array::builder::BooleanBuilder, // isLambda
  c20: arrow::array::builder::BooleanBuilder, // isCapturedRecord
  c21: arrow::array::builder::UInt64Builder, // getDefinition
  c22: arrow::array::builder::BooleanBuilder, // isOrContainsUnion
  c23: arrow::array::builder::BooleanBuilder, // field_empty
  c24: arrow::array::builder::UInt64Builder, // findFirstNamedDataMember
  writer: ParquetWriter,
}

impl TableBuilder130 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("hasFlexibleArrayMember", DataType::Boolean, false),
      Field::new("isAnonymousStructOrUnion", DataType::Boolean, false),
      Field::new("hasObjectMember", DataType::Boolean, false),
      Field::new("hasVolatileMember", DataType::Boolean, false),
      Field::new("hasLoadedFieldsFromExternalStorage", DataType::Boolean, false),
      Field::new("isNonTrivialToPrimitiveDefaultInitialize", DataType::Boolean, false),
      Field::new("isNonTrivialToPrimitiveCopy", DataType::Boolean, false),
      Field::new("isNonTrivialToPrimitiveDestroy", DataType::Boolean, false),
      Field::new("hasNonTrivialToPrimitiveDefaultInitializeCUnion", DataType::Boolean, false),
      Field::new("hasNonTrivialToPrimitiveDestructCUnion", DataType::Boolean, false),
      Field::new("hasNonTrivialToPrimitiveCopyCUnion", DataType::Boolean, false),
      Field::new("canPassInRegisters", DataType::Boolean, false),
      Field::new("getArgPassingRestrictions", DataType::UInt64, false),
      Field::new("isParamDestroyedInCallee", DataType::Boolean, false),
      Field::new("isRandomized", DataType::Boolean, false),
      Field::new("isInjectedClassName", DataType::Boolean, false),
      Field::new("isLambda", DataType::Boolean, false),
      Field::new("isCapturedRecord", DataType::Boolean, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("isOrContainsUnion", DataType::Boolean, false),
      Field::new("field_empty", DataType::Boolean, false),
      Field::new("findFirstNamedDataMember", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::UInt64Builder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::UInt64Builder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record130) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder131 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isParameterPack
  c2: arrow::array::builder::BooleanBuilder, // isPackExpansion
  c3: arrow::array::builder::BooleanBuilder, // isExpandedParameterPack
  c4: arrow::array::builder::BooleanBuilder, // hasDefaultArgument
  c5: arrow::array::builder::UInt64Builder, // getDefaultArgumentLoc
  c6: arrow::array::builder::BooleanBuilder, // defaultArgumentWasInherited
  c7: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder131 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("isPackExpansion", DataType::Boolean, false),
      Field::new("isExpandedParameterPack", DataType::Boolean, false),
      Field::new("hasDefaultArgument", DataType::Boolean, false),
      Field::new("getDefaultArgumentLoc", DataType::UInt64, false),
      Field::new("defaultArgumentWasInherited", DataType::Boolean, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record131) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder132 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getExportLoc
  c2: arrow::array::builder::UInt64Builder, // getRBraceLoc
  c3: arrow::array::builder::BooleanBuilder, // hasBraces
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder132 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getExportLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
      Field::new("hasBraces", DataType::Boolean, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record132) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder133 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUsingLoc
  c2: arrow::array::builder::UInt64Builder, // getEnumLoc
  c3: arrow::array::builder::UInt64Builder, // getEnumDecl
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder133 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUsingLoc", DataType::UInt64, false),
      Field::new("getEnumLoc", DataType::UInt64, false),
      Field::new("getEnumDecl", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record133) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder134 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // getName
  c2: arrow::array::builder::StringBuilder, // getValue
  writer: ParquetWriter,
}

impl TableBuilder134 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getName", DataType::Utf8, false),
      Field::new("getValue", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record134) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder135 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTemplatedDecl
  c2: arrow::array::builder::BooleanBuilder, // isThisDeclarationADefinition
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c4: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c5: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c6: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberTemplate
  writer: ParquetWriter,
}

impl TableBuilder135 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTemplatedDecl", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberTemplate", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record135) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder136 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder136 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record136) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder137 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder137 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record137) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder138 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getLocation
  c5: arrow::array::builder::UInt64Builder, // getNextDeclInContext
  c6: arrow::array::builder::UInt64Builder, // getNonClosureContext
  c7: arrow::array::builder::UInt64Builder, // getTranslationUnitDecl
  c8: arrow::array::builder::BooleanBuilder, // isInAnonymousNamespace
  c9: arrow::array::builder::BooleanBuilder, // isInStdNamespace
  c10: arrow::array::builder::BooleanBuilder, // isFileContextDecl
  c11: arrow::array::builder::UInt64Builder, // getAccess
  c12: arrow::array::builder::UInt64Builder, // getAccessUnsafe
  c13: arrow::array::builder::BooleanBuilder, // hasAttrs
  c14: arrow::array::builder::BooleanBuilder, // isInvalidDecl
  c15: arrow::array::builder::BooleanBuilder, // isImplicit
  c16: arrow::array::builder::BooleanBuilder, // isReferenced
  c17: arrow::array::builder::BooleanBuilder, // isThisDeclarationReferenced
  c18: arrow::array::builder::BooleanBuilder, // isTopLevelDeclInObjCContainer
  c19: arrow::array::builder::BooleanBuilder, // isModulePrivate
  c20: arrow::array::builder::BooleanBuilder, // isInExportDeclContext
  c21: arrow::array::builder::BooleanBuilder, // isInvisibleOutsideTheOwningModule
  c22: arrow::array::builder::BooleanBuilder, // isInAnotherModuleUnit
  c23: arrow::array::builder::BooleanBuilder, // isDiscardedInGlobalModuleFragment
  c24: arrow::array::builder::BooleanBuilder, // shouldSkipCheckingODR
  c25: arrow::array::builder::BooleanBuilder, // hasDefiningAttr
  c26: arrow::array::builder::UInt64Builder, // getDefiningAttr
  c27: arrow::array::builder::BooleanBuilder, // isWeakImported
  c28: arrow::array::builder::BooleanBuilder, // isFromASTFile
  c29: arrow::array::builder::UInt32Builder, // getGlobalID
  c30: arrow::array::builder::UInt32Builder, // getOwningModuleID
  c31: arrow::array::builder::BooleanBuilder, // hasOwningModule
  c32: arrow::array::builder::BooleanBuilder, // isUnconditionallyVisible
  c33: arrow::array::builder::BooleanBuilder, // isReachable
  c34: arrow::array::builder::UInt64Builder, // getModuleOwnershipKind
  c35: arrow::array::builder::UInt32Builder, // getIdentifierNamespace
  c36: arrow::array::builder::BooleanBuilder, // hasTagIdentifierNamespace
  c37: arrow::array::builder::BooleanBuilder, // isOutOfLine
  c38: arrow::array::builder::BooleanBuilder, // isTemplated
  c39: arrow::array::builder::UInt32Builder, // getTemplateDepth
  c40: arrow::array::builder::BooleanBuilder, // isDefinedOutsideFunctionOrMethod
  c41: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c42: arrow::array::builder::BooleanBuilder, // isCanonicalDecl
  c43: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c44: arrow::array::builder::BooleanBuilder, // isFirstDecl
  c45: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c46: arrow::array::builder::UInt64Builder, // getBody
  c47: arrow::array::builder::BooleanBuilder, // hasBody
  c48: arrow::array::builder::UInt64Builder, // getBodyRBrace
  c49: arrow::array::builder::BooleanBuilder, // isTemplateParameter
  c50: arrow::array::builder::BooleanBuilder, // isTemplateParameterPack
  c51: arrow::array::builder::BooleanBuilder, // isParameterPack
  c52: arrow::array::builder::BooleanBuilder, // isTemplateDecl
  c53: arrow::array::builder::BooleanBuilder, // isFunctionOrFunctionTemplate
  c54: arrow::array::builder::UInt64Builder, // getDescribedTemplate
  c55: arrow::array::builder::UInt64Builder, // getAsFunction
  c56: arrow::array::builder::BooleanBuilder, // isLocalExternDecl
  c57: arrow::array::builder::UInt64Builder, // getFriendObjectKind
  c58: arrow::array::builder::Int64Builder, // getID
  c59: arrow::array::builder::BooleanBuilder, // isFunctionPointerType
  writer: ParquetWriter,
}

impl TableBuilder138 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getNextDeclInContext", DataType::UInt64, false),
      Field::new("getNonClosureContext", DataType::UInt64, false),
      Field::new("getTranslationUnitDecl", DataType::UInt64, false),
      Field::new("isInAnonymousNamespace", DataType::Boolean, false),
      Field::new("isInStdNamespace", DataType::Boolean, false),
      Field::new("isFileContextDecl", DataType::Boolean, false),
      Field::new("getAccess", DataType::UInt64, false),
      Field::new("getAccessUnsafe", DataType::UInt64, false),
      Field::new("hasAttrs", DataType::Boolean, false),
      Field::new("isInvalidDecl", DataType::Boolean, false),
      Field::new("isImplicit", DataType::Boolean, false),
      Field::new("isReferenced", DataType::Boolean, false),
      Field::new("isThisDeclarationReferenced", DataType::Boolean, false),
      Field::new("isTopLevelDeclInObjCContainer", DataType::Boolean, false),
      Field::new("isModulePrivate", DataType::Boolean, false),
      Field::new("isInExportDeclContext", DataType::Boolean, false),
      Field::new("isInvisibleOutsideTheOwningModule", DataType::Boolean, false),
      Field::new("isInAnotherModuleUnit", DataType::Boolean, false),
      Field::new("isDiscardedInGlobalModuleFragment", DataType::Boolean, false),
      Field::new("shouldSkipCheckingODR", DataType::Boolean, false),
      Field::new("hasDefiningAttr", DataType::Boolean, false),
      Field::new("getDefiningAttr", DataType::UInt64, false),
      Field::new("isWeakImported", DataType::Boolean, false),
      Field::new("isFromASTFile", DataType::Boolean, false),
      Field::new("getGlobalID", DataType::UInt32, false),
      Field::new("getOwningModuleID", DataType::UInt32, false),
      Field::new("hasOwningModule", DataType::Boolean, false),
      Field::new("isUnconditionallyVisible", DataType::Boolean, false),
      Field::new("isReachable", DataType::Boolean, false),
      Field::new("getModuleOwnershipKind", DataType::UInt64, false),
      Field::new("getIdentifierNamespace", DataType::UInt32, false),
      Field::new("hasTagIdentifierNamespace", DataType::Boolean, false),
      Field::new("isOutOfLine", DataType::Boolean, false),
      Field::new("isTemplated", DataType::Boolean, false),
      Field::new("getTemplateDepth", DataType::UInt32, false),
      Field::new("isDefinedOutsideFunctionOrMethod", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("isCanonicalDecl", DataType::Boolean, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("isFirstDecl", DataType::Boolean, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("hasBody", DataType::Boolean, false),
      Field::new("getBodyRBrace", DataType::UInt64, false),
      Field::new("isTemplateParameter", DataType::Boolean, false),
      Field::new("isTemplateParameterPack", DataType::Boolean, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("isTemplateDecl", DataType::Boolean, false),
      Field::new("isFunctionOrFunctionTemplate", DataType::Boolean, false),
      Field::new("getDescribedTemplate", DataType::UInt64, false),
      Field::new("getAsFunction", DataType::UInt64, false),
      Field::new("isLocalExternDecl", DataType::Boolean, false),
      Field::new("getFriendObjectKind", DataType::UInt64, false),
      Field::new("getID", DataType::Int64, false),
      Field::new("isFunctionPointerType", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::BooleanBuilder::new(),
      c25: arrow::array::builder::BooleanBuilder::new(),
      c26: arrow::array::builder::UInt64Builder::new(),
      c27: arrow::array::builder::BooleanBuilder::new(),
      c28: arrow::array::builder::BooleanBuilder::new(),
      c29: arrow::array::builder::UInt32Builder::new(),
      c30: arrow::array::builder::UInt32Builder::new(),
      c31: arrow::array::builder::BooleanBuilder::new(),
      c32: arrow::array::builder::BooleanBuilder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::UInt64Builder::new(),
      c35: arrow::array::builder::UInt32Builder::new(),
      c36: arrow::array::builder::BooleanBuilder::new(),
      c37: arrow::array::builder::BooleanBuilder::new(),
      c38: arrow::array::builder::BooleanBuilder::new(),
      c39: arrow::array::builder::UInt32Builder::new(),
      c40: arrow::array::builder::BooleanBuilder::new(),
      c41: arrow::array::builder::UInt64Builder::new(),
      c42: arrow::array::builder::BooleanBuilder::new(),
      c43: arrow::array::builder::UInt64Builder::new(),
      c44: arrow::array::builder::BooleanBuilder::new(),
      c45: arrow::array::builder::UInt64Builder::new(),
      c46: arrow::array::builder::UInt64Builder::new(),
      c47: arrow::array::builder::BooleanBuilder::new(),
      c48: arrow::array::builder::UInt64Builder::new(),
      c49: arrow::array::builder::BooleanBuilder::new(),
      c50: arrow::array::builder::BooleanBuilder::new(),
      c51: arrow::array::builder::BooleanBuilder::new(),
      c52: arrow::array::builder::BooleanBuilder::new(),
      c53: arrow::array::builder::BooleanBuilder::new(),
      c54: arrow::array::builder::UInt64Builder::new(),
      c55: arrow::array::builder::UInt64Builder::new(),
      c56: arrow::array::builder::BooleanBuilder::new(),
      c57: arrow::array::builder::UInt64Builder::new(),
      c58: arrow::array::builder::Int64Builder::new(),
      c59: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::BooleanBuilder::new();
    self.c25 = arrow::array::builder::BooleanBuilder::new();
    self.c26 = arrow::array::builder::UInt64Builder::new();
    self.c27 = arrow::array::builder::BooleanBuilder::new();
    self.c28 = arrow::array::builder::BooleanBuilder::new();
    self.c29 = arrow::array::builder::UInt32Builder::new();
    self.c30 = arrow::array::builder::UInt32Builder::new();
    self.c31 = arrow::array::builder::BooleanBuilder::new();
    self.c32 = arrow::array::builder::BooleanBuilder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::UInt64Builder::new();
    self.c35 = arrow::array::builder::UInt32Builder::new();
    self.c36 = arrow::array::builder::BooleanBuilder::new();
    self.c37 = arrow::array::builder::BooleanBuilder::new();
    self.c38 = arrow::array::builder::BooleanBuilder::new();
    self.c39 = arrow::array::builder::UInt32Builder::new();
    self.c40 = arrow::array::builder::BooleanBuilder::new();
    self.c41 = arrow::array::builder::UInt64Builder::new();
    self.c42 = arrow::array::builder::BooleanBuilder::new();
    self.c43 = arrow::array::builder::UInt64Builder::new();
    self.c44 = arrow::array::builder::BooleanBuilder::new();
    self.c45 = arrow::array::builder::UInt64Builder::new();
    self.c46 = arrow::array::builder::UInt64Builder::new();
    self.c47 = arrow::array::builder::BooleanBuilder::new();
    self.c48 = arrow::array::builder::UInt64Builder::new();
    self.c49 = arrow::array::builder::BooleanBuilder::new();
    self.c50 = arrow::array::builder::BooleanBuilder::new();
    self.c51 = arrow::array::builder::BooleanBuilder::new();
    self.c52 = arrow::array::builder::BooleanBuilder::new();
    self.c53 = arrow::array::builder::BooleanBuilder::new();
    self.c54 = arrow::array::builder::UInt64Builder::new();
    self.c55 = arrow::array::builder::UInt64Builder::new();
    self.c56 = arrow::array::builder::BooleanBuilder::new();
    self.c57 = arrow::array::builder::UInt64Builder::new();
    self.c58 = arrow::array::builder::Int64Builder::new();
    self.c59 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record138) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    self.c35.append_value(record.c35);
    self.c36.append_value(record.c36);
    self.c37.append_value(record.c37);
    self.c38.append_value(record.c38);
    self.c39.append_value(record.c39);
    self.c40.append_value(record.c40);
    self.c41.append_value(record.c41);
    self.c42.append_value(record.c42);
    self.c43.append_value(record.c43);
    self.c44.append_value(record.c44);
    self.c45.append_value(record.c45);
    self.c46.append_value(record.c46);
    self.c47.append_value(record.c47);
    self.c48.append_value(record.c48);
    self.c49.append_value(record.c49);
    self.c50.append_value(record.c50);
    self.c51.append_value(record.c51);
    self.c52.append_value(record.c52);
    self.c53.append_value(record.c53);
    self.c54.append_value(record.c54);
    self.c55.append_value(record.c55);
    self.c56.append_value(record.c56);
    self.c57.append_value(record.c57);
    self.c58.append_value(record.c58);
    self.c59.append_value(record.c59);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
        Arc::new(self.c35.finish()),
        Arc::new(self.c36.finish()),
        Arc::new(self.c37.finish()),
        Arc::new(self.c38.finish()),
        Arc::new(self.c39.finish()),
        Arc::new(self.c40.finish()),
        Arc::new(self.c41.finish()),
        Arc::new(self.c42.finish()),
        Arc::new(self.c43.finish()),
        Arc::new(self.c44.finish()),
        Arc::new(self.c45.finish()),
        Arc::new(self.c46.finish()),
        Arc::new(self.c47.finish()),
        Arc::new(self.c48.finish()),
        Arc::new(self.c49.finish()),
        Arc::new(self.c50.finish()),
        Arc::new(self.c51.finish()),
        Arc::new(self.c52.finish()),
        Arc::new(self.c53.finish()),
        Arc::new(self.c54.finish()),
        Arc::new(self.c55.finish()),
        Arc::new(self.c56.finish()),
        Arc::new(self.c57.finish()),
        Arc::new(self.c58.finish()),
        Arc::new(self.c59.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder139 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder139 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record139) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder140 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder140 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record140) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder141 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isExplicit
  c2: arrow::array::builder::UInt32Builder, // getNumCtorInitializers
  c3: arrow::array::builder::BooleanBuilder, // isDelegatingConstructor
  c4: arrow::array::builder::BooleanBuilder, // isDefaultConstructor
  c5: arrow::array::builder::BooleanBuilder, // isCopyConstructor
  c6: arrow::array::builder::BooleanBuilder, // isMoveConstructor
  c7: arrow::array::builder::BooleanBuilder, // isCopyOrMoveConstructor
  c8: arrow::array::builder::BooleanBuilder, // isSpecializationCopyingObject
  c9: arrow::array::builder::BooleanBuilder, // isInheritingConstructor
  c10: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder141 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isExplicit", DataType::Boolean, false),
      Field::new("getNumCtorInitializers", DataType::UInt32, false),
      Field::new("isDelegatingConstructor", DataType::Boolean, false),
      Field::new("isDefaultConstructor", DataType::Boolean, false),
      Field::new("isCopyConstructor", DataType::Boolean, false),
      Field::new("isMoveConstructor", DataType::Boolean, false),
      Field::new("isCopyOrMoveConstructor", DataType::Boolean, false),
      Field::new("isSpecializationCopyingObject", DataType::Boolean, false),
      Field::new("isInheritingConstructor", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record141) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder142 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder142 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record142) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder143 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getFieldIndex
  c2: arrow::array::builder::BooleanBuilder, // isMutable
  c3: arrow::array::builder::BooleanBuilder, // isBitField
  c4: arrow::array::builder::BooleanBuilder, // isUnnamedBitfield
  c5: arrow::array::builder::BooleanBuilder, // isAnonymousStructOrUnion
  c6: arrow::array::builder::UInt64Builder, // getBitWidth
  c7: arrow::array::builder::BooleanBuilder, // isPotentiallyOverlapping
  c8: arrow::array::builder::UInt64Builder, // getInClassInitStyle
  c9: arrow::array::builder::BooleanBuilder, // hasInClassInitializer
  c10: arrow::array::builder::BooleanBuilder, // hasNonNullInClassInitializer
  c11: arrow::array::builder::UInt64Builder, // getInClassInitializer
  c12: arrow::array::builder::BooleanBuilder, // hasCapturedVLAType
  c13: arrow::array::builder::UInt64Builder, // getCapturedVLAType
  c14: arrow::array::builder::UInt64Builder, // getParent
  c15: arrow::array::builder::UInt64Builder, // getSourceRange
  c16: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder143 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getFieldIndex", DataType::UInt32, false),
      Field::new("isMutable", DataType::Boolean, false),
      Field::new("isBitField", DataType::Boolean, false),
      Field::new("isUnnamedBitfield", DataType::Boolean, false),
      Field::new("isAnonymousStructOrUnion", DataType::Boolean, false),
      Field::new("getBitWidth", DataType::UInt64, false),
      Field::new("isPotentiallyOverlapping", DataType::Boolean, false),
      Field::new("getInClassInitStyle", DataType::UInt64, false),
      Field::new("hasInClassInitializer", DataType::Boolean, false),
      Field::new("hasNonNullInClassInitializer", DataType::Boolean, false),
      Field::new("getInClassInitializer", DataType::UInt64, false),
      Field::new("hasCapturedVLAType", DataType::Boolean, false),
      Field::new("getCapturedVLAType", DataType::UInt64, false),
      Field::new("getParent", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record143) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder144 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder144 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record144) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder145 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder145 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record145) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder146 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSpecializedTemplate
  c2: arrow::array::builder::UInt64Builder, // getSpecializationKind
  c3: arrow::array::builder::BooleanBuilder, // isExplicitSpecialization
  c4: arrow::array::builder::BooleanBuilder, // isClassScopeExplicitSpecialization
  c5: arrow::array::builder::BooleanBuilder, // isExplicitInstantiationOrSpecialization
  c6: arrow::array::builder::UInt64Builder, // getPointOfInstantiation
  c7: arrow::array::builder::UInt64Builder, // getExternLoc
  c8: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c9: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder146 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSpecializedTemplate", DataType::UInt64, false),
      Field::new("getSpecializationKind", DataType::UInt64, false),
      Field::new("isExplicitSpecialization", DataType::Boolean, false),
      Field::new("isClassScopeExplicitSpecialization", DataType::Boolean, false),
      Field::new("isExplicitInstantiationOrSpecialization", DataType::Boolean, false),
      Field::new("getPointOfInstantiation", DataType::UInt64, false),
      Field::new("getExternLoc", DataType::UInt64, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record146) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder147 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getExtendingDecl
  c2: arrow::array::builder::UInt64Builder, // getStorageDuration
  c3: arrow::array::builder::UInt64Builder, // getTemporaryExpr
  c4: arrow::array::builder::UInt32Builder, // getManglingNumber
  writer: ParquetWriter,
}

impl TableBuilder147 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getExtendingDecl", DataType::UInt64, false),
      Field::new("getStorageDuration", DataType::UInt64, false),
      Field::new("getTemporaryExpr", DataType::UInt64, false),
      Field::new("getManglingNumber", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record147) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder148 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder148 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record148) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder149 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder149 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record149) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder150 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCommentKind
  c2: arrow::array::builder::StringBuilder, // getArg
  writer: ParquetWriter,
}

impl TableBuilder150 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCommentKind", DataType::UInt64, false),
      Field::new("getArg", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record150) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder151 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasAssociatedConstraints
  c2: arrow::array::builder::UInt64Builder, // getInstantiatedFromMember
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder151 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasAssociatedConstraints", DataType::Boolean, false),
      Field::new("getInstantiatedFromMember", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record151) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder152 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder152 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record152) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder153 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c2: arrow::array::builder::UInt64Builder, // getSourceRange
  c3: arrow::array::builder::BooleanBuilder, // hasBody
  c4: arrow::array::builder::BooleanBuilder, // hasTrivialBody
  c5: arrow::array::builder::BooleanBuilder, // isDefined
  c6: arrow::array::builder::UInt64Builder, // getDefinition
  c7: arrow::array::builder::UInt64Builder, // getBody
  c8: arrow::array::builder::BooleanBuilder, // isThisDeclarationADefinition
  c9: arrow::array::builder::BooleanBuilder, // isThisDeclarationInstantiatedFromAFriendDefinition
  c10: arrow::array::builder::BooleanBuilder, // doesThisDeclarationHaveABody
  c11: arrow::array::builder::BooleanBuilder, // isVariadic
  c12: arrow::array::builder::BooleanBuilder, // isVirtualAsWritten
  c13: arrow::array::builder::BooleanBuilder, // isPureVirtual
  c14: arrow::array::builder::BooleanBuilder, // isLateTemplateParsed
  c15: arrow::array::builder::BooleanBuilder, // isTrivial
  c16: arrow::array::builder::BooleanBuilder, // isTrivialForCall
  c17: arrow::array::builder::BooleanBuilder, // isDefaulted
  c18: arrow::array::builder::BooleanBuilder, // isExplicitlyDefaulted
  c19: arrow::array::builder::UInt64Builder, // getDefaultLoc
  c20: arrow::array::builder::BooleanBuilder, // isUserProvided
  c21: arrow::array::builder::BooleanBuilder, // isIneligibleOrNotSelected
  c22: arrow::array::builder::BooleanBuilder, // hasImplicitReturnZero
  c23: arrow::array::builder::BooleanBuilder, // hasPrototype
  c24: arrow::array::builder::BooleanBuilder, // hasWrittenPrototype
  c25: arrow::array::builder::BooleanBuilder, // hasInheritedPrototype
  c26: arrow::array::builder::BooleanBuilder, // isConstexpr
  c27: arrow::array::builder::UInt64Builder, // getConstexprKind
  c28: arrow::array::builder::BooleanBuilder, // isConstexprSpecified
  c29: arrow::array::builder::BooleanBuilder, // isConsteval
  c30: arrow::array::builder::BooleanBuilder, // BodyContainsImmediateEscalatingExpressions
  c31: arrow::array::builder::BooleanBuilder, // isImmediateEscalating
  c32: arrow::array::builder::BooleanBuilder, // isImmediateFunction
  c33: arrow::array::builder::BooleanBuilder, // instantiationIsPending
  c34: arrow::array::builder::BooleanBuilder, // usesSEHTry
  c35: arrow::array::builder::BooleanBuilder, // isDeleted
  c36: arrow::array::builder::BooleanBuilder, // isDeletedAsWritten
  c37: arrow::array::builder::BooleanBuilder, // isMain
  c38: arrow::array::builder::BooleanBuilder, // isMSVCRTEntryPoint
  c39: arrow::array::builder::BooleanBuilder, // isReservedGlobalPlacementOperator
  c40: arrow::array::builder::BooleanBuilder, // isInlineBuiltinDeclaration
  c41: arrow::array::builder::BooleanBuilder, // isDestroyingOperatorDelete
  c42: arrow::array::builder::UInt64Builder, // getLanguageLinkage
  c43: arrow::array::builder::BooleanBuilder, // isExternC
  c44: arrow::array::builder::BooleanBuilder, // isInExternCContext
  c45: arrow::array::builder::BooleanBuilder, // isInExternCXXContext
  c46: arrow::array::builder::BooleanBuilder, // isGlobal
  c47: arrow::array::builder::BooleanBuilder, // isNoReturn
  c48: arrow::array::builder::BooleanBuilder, // hasSkippedBody
  c49: arrow::array::builder::BooleanBuilder, // willHaveBody
  c50: arrow::array::builder::BooleanBuilder, // isMultiVersion
  c51: arrow::array::builder::BooleanBuilder, // FriendConstraintRefersToEnclosingTemplate
  c52: arrow::array::builder::BooleanBuilder, // isMemberLikeConstrainedFriend
  c53: arrow::array::builder::UInt64Builder, // getMultiVersionKind
  c54: arrow::array::builder::BooleanBuilder, // isCPUDispatchMultiVersion
  c55: arrow::array::builder::BooleanBuilder, // isCPUSpecificMultiVersion
  c56: arrow::array::builder::BooleanBuilder, // isTargetMultiVersion
  c57: arrow::array::builder::BooleanBuilder, // isTargetClonesMultiVersion
  c58: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c59: arrow::array::builder::BooleanBuilder, // param_empty
  c60: arrow::array::builder::UInt64Builder, // param_size
  c61: arrow::array::builder::UInt32Builder, // getNumParams
  c62: arrow::array::builder::UInt32Builder, // getMinRequiredArguments
  c63: arrow::array::builder::UInt32Builder, // getMinRequiredExplicitArguments
  c64: arrow::array::builder::BooleanBuilder, // hasCXXExplicitFunctionObjectParameter
  c65: arrow::array::builder::UInt32Builder, // getNumNonObjectParams
  c66: arrow::array::builder::BooleanBuilder, // hasOneParamOrDefaultArgs
  c67: arrow::array::builder::UInt64Builder, // getReturnType
  c68: arrow::array::builder::UInt64Builder, // getReturnTypeSourceRange
  c69: arrow::array::builder::UInt64Builder, // getParametersSourceRange
  c70: arrow::array::builder::UInt64Builder, // getDeclaredReturnType
  c71: arrow::array::builder::UInt64Builder, // getExceptionSpecType
  c72: arrow::array::builder::UInt64Builder, // getExceptionSpecSourceRange
  c73: arrow::array::builder::UInt64Builder, // getCallResultType
  c74: arrow::array::builder::UInt64Builder, // getStorageClass
  c75: arrow::array::builder::BooleanBuilder, // isInlineSpecified
  c76: arrow::array::builder::BooleanBuilder, // UsesFPIntrin
  c77: arrow::array::builder::BooleanBuilder, // isInlined
  c78: arrow::array::builder::BooleanBuilder, // isInlineDefinitionExternallyVisible
  c79: arrow::array::builder::BooleanBuilder, // isMSExternInline
  c80: arrow::array::builder::BooleanBuilder, // doesDeclarationForceExternallyVisibleDefinition
  c81: arrow::array::builder::BooleanBuilder, // isStatic
  c82: arrow::array::builder::BooleanBuilder, // isOverloadedOperator
  c83: arrow::array::builder::UInt64Builder, // getOverloadedOperator
  c84: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberFunction
  c85: arrow::array::builder::UInt64Builder, // getTemplatedKind
  c86: arrow::array::builder::UInt64Builder, // getInstantiatedFromDecl
  c87: arrow::array::builder::UInt64Builder, // getDescribedFunctionTemplate
  c88: arrow::array::builder::BooleanBuilder, // isFunctionTemplateSpecialization
  c89: arrow::array::builder::BooleanBuilder, // isImplicitlyInstantiable
  c90: arrow::array::builder::BooleanBuilder, // isTemplateInstantiation
  c91: arrow::array::builder::UInt64Builder, // getPrimaryTemplate
  c92: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKind
  c93: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKindForInstantiation
  c94: arrow::array::builder::UInt64Builder, // getPointOfInstantiation
  c95: arrow::array::builder::BooleanBuilder, // isOutOfLine
  c96: arrow::array::builder::UInt32Builder, // getMemoryFunctionKind
  c97: arrow::array::builder::UInt32Builder, // getODRHash
  writer: ParquetWriter,
}

impl TableBuilder153 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("hasBody", DataType::Boolean, false),
      Field::new("hasTrivialBody", DataType::Boolean, false),
      Field::new("isDefined", DataType::Boolean, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("isThisDeclarationADefinition", DataType::Boolean, false),
      Field::new("isThisDeclarationInstantiatedFromAFriendDefinition", DataType::Boolean, false),
      Field::new("doesThisDeclarationHaveABody", DataType::Boolean, false),
      Field::new("isVariadic", DataType::Boolean, false),
      Field::new("isVirtualAsWritten", DataType::Boolean, false),
      Field::new("isPureVirtual", DataType::Boolean, false),
      Field::new("isLateTemplateParsed", DataType::Boolean, false),
      Field::new("isTrivial", DataType::Boolean, false),
      Field::new("isTrivialForCall", DataType::Boolean, false),
      Field::new("isDefaulted", DataType::Boolean, false),
      Field::new("isExplicitlyDefaulted", DataType::Boolean, false),
      Field::new("getDefaultLoc", DataType::UInt64, false),
      Field::new("isUserProvided", DataType::Boolean, false),
      Field::new("isIneligibleOrNotSelected", DataType::Boolean, false),
      Field::new("hasImplicitReturnZero", DataType::Boolean, false),
      Field::new("hasPrototype", DataType::Boolean, false),
      Field::new("hasWrittenPrototype", DataType::Boolean, false),
      Field::new("hasInheritedPrototype", DataType::Boolean, false),
      Field::new("isConstexpr", DataType::Boolean, false),
      Field::new("getConstexprKind", DataType::UInt64, false),
      Field::new("isConstexprSpecified", DataType::Boolean, false),
      Field::new("isConsteval", DataType::Boolean, false),
      Field::new("BodyContainsImmediateEscalatingExpressions", DataType::Boolean, false),
      Field::new("isImmediateEscalating", DataType::Boolean, false),
      Field::new("isImmediateFunction", DataType::Boolean, false),
      Field::new("instantiationIsPending", DataType::Boolean, false),
      Field::new("usesSEHTry", DataType::Boolean, false),
      Field::new("isDeleted", DataType::Boolean, false),
      Field::new("isDeletedAsWritten", DataType::Boolean, false),
      Field::new("isMain", DataType::Boolean, false),
      Field::new("isMSVCRTEntryPoint", DataType::Boolean, false),
      Field::new("isReservedGlobalPlacementOperator", DataType::Boolean, false),
      Field::new("isInlineBuiltinDeclaration", DataType::Boolean, false),
      Field::new("isDestroyingOperatorDelete", DataType::Boolean, false),
      Field::new("getLanguageLinkage", DataType::UInt64, false),
      Field::new("isExternC", DataType::Boolean, false),
      Field::new("isInExternCContext", DataType::Boolean, false),
      Field::new("isInExternCXXContext", DataType::Boolean, false),
      Field::new("isGlobal", DataType::Boolean, false),
      Field::new("isNoReturn", DataType::Boolean, false),
      Field::new("hasSkippedBody", DataType::Boolean, false),
      Field::new("willHaveBody", DataType::Boolean, false),
      Field::new("isMultiVersion", DataType::Boolean, false),
      Field::new("FriendConstraintRefersToEnclosingTemplate", DataType::Boolean, false),
      Field::new("isMemberLikeConstrainedFriend", DataType::Boolean, false),
      Field::new("getMultiVersionKind", DataType::UInt64, false),
      Field::new("isCPUDispatchMultiVersion", DataType::Boolean, false),
      Field::new("isCPUSpecificMultiVersion", DataType::Boolean, false),
      Field::new("isTargetMultiVersion", DataType::Boolean, false),
      Field::new("isTargetClonesMultiVersion", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("param_empty", DataType::Boolean, false),
      Field::new("param_size", DataType::UInt64, false),
      Field::new("getNumParams", DataType::UInt32, false),
      Field::new("getMinRequiredArguments", DataType::UInt32, false),
      Field::new("getMinRequiredExplicitArguments", DataType::UInt32, false),
      Field::new("hasCXXExplicitFunctionObjectParameter", DataType::Boolean, false),
      Field::new("getNumNonObjectParams", DataType::UInt32, false),
      Field::new("hasOneParamOrDefaultArgs", DataType::Boolean, false),
      Field::new("getReturnType", DataType::UInt64, false),
      Field::new("getReturnTypeSourceRange", DataType::UInt64, false),
      Field::new("getParametersSourceRange", DataType::UInt64, false),
      Field::new("getDeclaredReturnType", DataType::UInt64, false),
      Field::new("getExceptionSpecType", DataType::UInt64, false),
      Field::new("getExceptionSpecSourceRange", DataType::UInt64, false),
      Field::new("getCallResultType", DataType::UInt64, false),
      Field::new("getStorageClass", DataType::UInt64, false),
      Field::new("isInlineSpecified", DataType::Boolean, false),
      Field::new("UsesFPIntrin", DataType::Boolean, false),
      Field::new("isInlined", DataType::Boolean, false),
      Field::new("isInlineDefinitionExternallyVisible", DataType::Boolean, false),
      Field::new("isMSExternInline", DataType::Boolean, false),
      Field::new("doesDeclarationForceExternallyVisibleDefinition", DataType::Boolean, false),
      Field::new("isStatic", DataType::Boolean, false),
      Field::new("isOverloadedOperator", DataType::Boolean, false),
      Field::new("getOverloadedOperator", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberFunction", DataType::UInt64, false),
      Field::new("getTemplatedKind", DataType::UInt64, false),
      Field::new("getInstantiatedFromDecl", DataType::UInt64, false),
      Field::new("getDescribedFunctionTemplate", DataType::UInt64, false),
      Field::new("isFunctionTemplateSpecialization", DataType::Boolean, false),
      Field::new("isImplicitlyInstantiable", DataType::Boolean, false),
      Field::new("isTemplateInstantiation", DataType::Boolean, false),
      Field::new("getPrimaryTemplate", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKind", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKindForInstantiation", DataType::UInt64, false),
      Field::new("getPointOfInstantiation", DataType::UInt64, false),
      Field::new("isOutOfLine", DataType::Boolean, false),
      Field::new("getMemoryFunctionKind", DataType::UInt32, false),
      Field::new("getODRHash", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::UInt64Builder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::BooleanBuilder::new(),
      c24: arrow::array::builder::BooleanBuilder::new(),
      c25: arrow::array::builder::BooleanBuilder::new(),
      c26: arrow::array::builder::BooleanBuilder::new(),
      c27: arrow::array::builder::UInt64Builder::new(),
      c28: arrow::array::builder::BooleanBuilder::new(),
      c29: arrow::array::builder::BooleanBuilder::new(),
      c30: arrow::array::builder::BooleanBuilder::new(),
      c31: arrow::array::builder::BooleanBuilder::new(),
      c32: arrow::array::builder::BooleanBuilder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::BooleanBuilder::new(),
      c35: arrow::array::builder::BooleanBuilder::new(),
      c36: arrow::array::builder::BooleanBuilder::new(),
      c37: arrow::array::builder::BooleanBuilder::new(),
      c38: arrow::array::builder::BooleanBuilder::new(),
      c39: arrow::array::builder::BooleanBuilder::new(),
      c40: arrow::array::builder::BooleanBuilder::new(),
      c41: arrow::array::builder::BooleanBuilder::new(),
      c42: arrow::array::builder::UInt64Builder::new(),
      c43: arrow::array::builder::BooleanBuilder::new(),
      c44: arrow::array::builder::BooleanBuilder::new(),
      c45: arrow::array::builder::BooleanBuilder::new(),
      c46: arrow::array::builder::BooleanBuilder::new(),
      c47: arrow::array::builder::BooleanBuilder::new(),
      c48: arrow::array::builder::BooleanBuilder::new(),
      c49: arrow::array::builder::BooleanBuilder::new(),
      c50: arrow::array::builder::BooleanBuilder::new(),
      c51: arrow::array::builder::BooleanBuilder::new(),
      c52: arrow::array::builder::BooleanBuilder::new(),
      c53: arrow::array::builder::UInt64Builder::new(),
      c54: arrow::array::builder::BooleanBuilder::new(),
      c55: arrow::array::builder::BooleanBuilder::new(),
      c56: arrow::array::builder::BooleanBuilder::new(),
      c57: arrow::array::builder::BooleanBuilder::new(),
      c58: arrow::array::builder::UInt64Builder::new(),
      c59: arrow::array::builder::BooleanBuilder::new(),
      c60: arrow::array::builder::UInt64Builder::new(),
      c61: arrow::array::builder::UInt32Builder::new(),
      c62: arrow::array::builder::UInt32Builder::new(),
      c63: arrow::array::builder::UInt32Builder::new(),
      c64: arrow::array::builder::BooleanBuilder::new(),
      c65: arrow::array::builder::UInt32Builder::new(),
      c66: arrow::array::builder::BooleanBuilder::new(),
      c67: arrow::array::builder::UInt64Builder::new(),
      c68: arrow::array::builder::UInt64Builder::new(),
      c69: arrow::array::builder::UInt64Builder::new(),
      c70: arrow::array::builder::UInt64Builder::new(),
      c71: arrow::array::builder::UInt64Builder::new(),
      c72: arrow::array::builder::UInt64Builder::new(),
      c73: arrow::array::builder::UInt64Builder::new(),
      c74: arrow::array::builder::UInt64Builder::new(),
      c75: arrow::array::builder::BooleanBuilder::new(),
      c76: arrow::array::builder::BooleanBuilder::new(),
      c77: arrow::array::builder::BooleanBuilder::new(),
      c78: arrow::array::builder::BooleanBuilder::new(),
      c79: arrow::array::builder::BooleanBuilder::new(),
      c80: arrow::array::builder::BooleanBuilder::new(),
      c81: arrow::array::builder::BooleanBuilder::new(),
      c82: arrow::array::builder::BooleanBuilder::new(),
      c83: arrow::array::builder::UInt64Builder::new(),
      c84: arrow::array::builder::UInt64Builder::new(),
      c85: arrow::array::builder::UInt64Builder::new(),
      c86: arrow::array::builder::UInt64Builder::new(),
      c87: arrow::array::builder::UInt64Builder::new(),
      c88: arrow::array::builder::BooleanBuilder::new(),
      c89: arrow::array::builder::BooleanBuilder::new(),
      c90: arrow::array::builder::BooleanBuilder::new(),
      c91: arrow::array::builder::UInt64Builder::new(),
      c92: arrow::array::builder::UInt64Builder::new(),
      c93: arrow::array::builder::UInt64Builder::new(),
      c94: arrow::array::builder::UInt64Builder::new(),
      c95: arrow::array::builder::BooleanBuilder::new(),
      c96: arrow::array::builder::UInt32Builder::new(),
      c97: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::UInt64Builder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::BooleanBuilder::new();
    self.c24 = arrow::array::builder::BooleanBuilder::new();
    self.c25 = arrow::array::builder::BooleanBuilder::new();
    self.c26 = arrow::array::builder::BooleanBuilder::new();
    self.c27 = arrow::array::builder::UInt64Builder::new();
    self.c28 = arrow::array::builder::BooleanBuilder::new();
    self.c29 = arrow::array::builder::BooleanBuilder::new();
    self.c30 = arrow::array::builder::BooleanBuilder::new();
    self.c31 = arrow::array::builder::BooleanBuilder::new();
    self.c32 = arrow::array::builder::BooleanBuilder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::BooleanBuilder::new();
    self.c35 = arrow::array::builder::BooleanBuilder::new();
    self.c36 = arrow::array::builder::BooleanBuilder::new();
    self.c37 = arrow::array::builder::BooleanBuilder::new();
    self.c38 = arrow::array::builder::BooleanBuilder::new();
    self.c39 = arrow::array::builder::BooleanBuilder::new();
    self.c40 = arrow::array::builder::BooleanBuilder::new();
    self.c41 = arrow::array::builder::BooleanBuilder::new();
    self.c42 = arrow::array::builder::UInt64Builder::new();
    self.c43 = arrow::array::builder::BooleanBuilder::new();
    self.c44 = arrow::array::builder::BooleanBuilder::new();
    self.c45 = arrow::array::builder::BooleanBuilder::new();
    self.c46 = arrow::array::builder::BooleanBuilder::new();
    self.c47 = arrow::array::builder::BooleanBuilder::new();
    self.c48 = arrow::array::builder::BooleanBuilder::new();
    self.c49 = arrow::array::builder::BooleanBuilder::new();
    self.c50 = arrow::array::builder::BooleanBuilder::new();
    self.c51 = arrow::array::builder::BooleanBuilder::new();
    self.c52 = arrow::array::builder::BooleanBuilder::new();
    self.c53 = arrow::array::builder::UInt64Builder::new();
    self.c54 = arrow::array::builder::BooleanBuilder::new();
    self.c55 = arrow::array::builder::BooleanBuilder::new();
    self.c56 = arrow::array::builder::BooleanBuilder::new();
    self.c57 = arrow::array::builder::BooleanBuilder::new();
    self.c58 = arrow::array::builder::UInt64Builder::new();
    self.c59 = arrow::array::builder::BooleanBuilder::new();
    self.c60 = arrow::array::builder::UInt64Builder::new();
    self.c61 = arrow::array::builder::UInt32Builder::new();
    self.c62 = arrow::array::builder::UInt32Builder::new();
    self.c63 = arrow::array::builder::UInt32Builder::new();
    self.c64 = arrow::array::builder::BooleanBuilder::new();
    self.c65 = arrow::array::builder::UInt32Builder::new();
    self.c66 = arrow::array::builder::BooleanBuilder::new();
    self.c67 = arrow::array::builder::UInt64Builder::new();
    self.c68 = arrow::array::builder::UInt64Builder::new();
    self.c69 = arrow::array::builder::UInt64Builder::new();
    self.c70 = arrow::array::builder::UInt64Builder::new();
    self.c71 = arrow::array::builder::UInt64Builder::new();
    self.c72 = arrow::array::builder::UInt64Builder::new();
    self.c73 = arrow::array::builder::UInt64Builder::new();
    self.c74 = arrow::array::builder::UInt64Builder::new();
    self.c75 = arrow::array::builder::BooleanBuilder::new();
    self.c76 = arrow::array::builder::BooleanBuilder::new();
    self.c77 = arrow::array::builder::BooleanBuilder::new();
    self.c78 = arrow::array::builder::BooleanBuilder::new();
    self.c79 = arrow::array::builder::BooleanBuilder::new();
    self.c80 = arrow::array::builder::BooleanBuilder::new();
    self.c81 = arrow::array::builder::BooleanBuilder::new();
    self.c82 = arrow::array::builder::BooleanBuilder::new();
    self.c83 = arrow::array::builder::UInt64Builder::new();
    self.c84 = arrow::array::builder::UInt64Builder::new();
    self.c85 = arrow::array::builder::UInt64Builder::new();
    self.c86 = arrow::array::builder::UInt64Builder::new();
    self.c87 = arrow::array::builder::UInt64Builder::new();
    self.c88 = arrow::array::builder::BooleanBuilder::new();
    self.c89 = arrow::array::builder::BooleanBuilder::new();
    self.c90 = arrow::array::builder::BooleanBuilder::new();
    self.c91 = arrow::array::builder::UInt64Builder::new();
    self.c92 = arrow::array::builder::UInt64Builder::new();
    self.c93 = arrow::array::builder::UInt64Builder::new();
    self.c94 = arrow::array::builder::UInt64Builder::new();
    self.c95 = arrow::array::builder::BooleanBuilder::new();
    self.c96 = arrow::array::builder::UInt32Builder::new();
    self.c97 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record153) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    self.c35.append_value(record.c35);
    self.c36.append_value(record.c36);
    self.c37.append_value(record.c37);
    self.c38.append_value(record.c38);
    self.c39.append_value(record.c39);
    self.c40.append_value(record.c40);
    self.c41.append_value(record.c41);
    self.c42.append_value(record.c42);
    self.c43.append_value(record.c43);
    self.c44.append_value(record.c44);
    self.c45.append_value(record.c45);
    self.c46.append_value(record.c46);
    self.c47.append_value(record.c47);
    self.c48.append_value(record.c48);
    self.c49.append_value(record.c49);
    self.c50.append_value(record.c50);
    self.c51.append_value(record.c51);
    self.c52.append_value(record.c52);
    self.c53.append_value(record.c53);
    self.c54.append_value(record.c54);
    self.c55.append_value(record.c55);
    self.c56.append_value(record.c56);
    self.c57.append_value(record.c57);
    self.c58.append_value(record.c58);
    self.c59.append_value(record.c59);
    self.c60.append_value(record.c60);
    self.c61.append_value(record.c61);
    self.c62.append_value(record.c62);
    self.c63.append_value(record.c63);
    self.c64.append_value(record.c64);
    self.c65.append_value(record.c65);
    self.c66.append_value(record.c66);
    self.c67.append_value(record.c67);
    self.c68.append_value(record.c68);
    self.c69.append_value(record.c69);
    self.c70.append_value(record.c70);
    self.c71.append_value(record.c71);
    self.c72.append_value(record.c72);
    self.c73.append_value(record.c73);
    self.c74.append_value(record.c74);
    self.c75.append_value(record.c75);
    self.c76.append_value(record.c76);
    self.c77.append_value(record.c77);
    self.c78.append_value(record.c78);
    self.c79.append_value(record.c79);
    self.c80.append_value(record.c80);
    self.c81.append_value(record.c81);
    self.c82.append_value(record.c82);
    self.c83.append_value(record.c83);
    self.c84.append_value(record.c84);
    self.c85.append_value(record.c85);
    self.c86.append_value(record.c86);
    self.c87.append_value(record.c87);
    self.c88.append_value(record.c88);
    self.c89.append_value(record.c89);
    self.c90.append_value(record.c90);
    self.c91.append_value(record.c91);
    self.c92.append_value(record.c92);
    self.c93.append_value(record.c93);
    self.c94.append_value(record.c94);
    self.c95.append_value(record.c95);
    self.c96.append_value(record.c96);
    self.c97.append_value(record.c97);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
        Arc::new(self.c35.finish()),
        Arc::new(self.c36.finish()),
        Arc::new(self.c37.finish()),
        Arc::new(self.c38.finish()),
        Arc::new(self.c39.finish()),
        Arc::new(self.c40.finish()),
        Arc::new(self.c41.finish()),
        Arc::new(self.c42.finish()),
        Arc::new(self.c43.finish()),
        Arc::new(self.c44.finish()),
        Arc::new(self.c45.finish()),
        Arc::new(self.c46.finish()),
        Arc::new(self.c47.finish()),
        Arc::new(self.c48.finish()),
        Arc::new(self.c49.finish()),
        Arc::new(self.c50.finish()),
        Arc::new(self.c51.finish()),
        Arc::new(self.c52.finish()),
        Arc::new(self.c53.finish()),
        Arc::new(self.c54.finish()),
        Arc::new(self.c55.finish()),
        Arc::new(self.c56.finish()),
        Arc::new(self.c57.finish()),
        Arc::new(self.c58.finish()),
        Arc::new(self.c59.finish()),
        Arc::new(self.c60.finish()),
        Arc::new(self.c61.finish()),
        Arc::new(self.c62.finish()),
        Arc::new(self.c63.finish()),
        Arc::new(self.c64.finish()),
        Arc::new(self.c65.finish()),
        Arc::new(self.c66.finish()),
        Arc::new(self.c67.finish()),
        Arc::new(self.c68.finish()),
        Arc::new(self.c69.finish()),
        Arc::new(self.c70.finish()),
        Arc::new(self.c71.finish()),
        Arc::new(self.c72.finish()),
        Arc::new(self.c73.finish()),
        Arc::new(self.c74.finish()),
        Arc::new(self.c75.finish()),
        Arc::new(self.c76.finish()),
        Arc::new(self.c77.finish()),
        Arc::new(self.c78.finish()),
        Arc::new(self.c79.finish()),
        Arc::new(self.c80.finish()),
        Arc::new(self.c81.finish()),
        Arc::new(self.c82.finish()),
        Arc::new(self.c83.finish()),
        Arc::new(self.c84.finish()),
        Arc::new(self.c85.finish()),
        Arc::new(self.c86.finish()),
        Arc::new(self.c87.finish()),
        Arc::new(self.c88.finish()),
        Arc::new(self.c89.finish()),
        Arc::new(self.c90.finish()),
        Arc::new(self.c91.finish()),
        Arc::new(self.c92.finish()),
        Arc::new(self.c93.finish()),
        Arc::new(self.c94.finish()),
        Arc::new(self.c95.finish()),
        Arc::new(self.c96.finish()),
        Arc::new(self.c97.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder154 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::BooleanBuilder, // hasDefaultArgument
  c3: arrow::array::builder::UInt64Builder, // getDefaultArgument
  c4: arrow::array::builder::UInt64Builder, // getDefaultArgumentLoc
  c5: arrow::array::builder::BooleanBuilder, // defaultArgumentWasInherited
  c6: arrow::array::builder::BooleanBuilder, // isParameterPack
  c7: arrow::array::builder::BooleanBuilder, // isPackExpansion
  c8: arrow::array::builder::BooleanBuilder, // isExpandedParameterPack
  c9: arrow::array::builder::UInt64Builder, // getPlaceholderTypeConstraint
  c10: arrow::array::builder::BooleanBuilder, // hasPlaceholderTypeConstraint
  writer: ParquetWriter,
}

impl TableBuilder154 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("hasDefaultArgument", DataType::Boolean, false),
      Field::new("getDefaultArgument", DataType::UInt64, false),
      Field::new("getDefaultArgumentLoc", DataType::UInt64, false),
      Field::new("defaultArgumentWasInherited", DataType::Boolean, false),
      Field::new("isParameterPack", DataType::Boolean, false),
      Field::new("isPackExpansion", DataType::Boolean, false),
      Field::new("isExpandedParameterPack", DataType::Boolean, false),
      Field::new("getPlaceholderTypeConstraint", DataType::UInt64, false),
      Field::new("hasPlaceholderTypeConstraint", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record154) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder155 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasGetter
  c2: arrow::array::builder::BooleanBuilder, // hasSetter
  writer: ParquetWriter,
}

impl TableBuilder155 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasGetter", DataType::Boolean, false),
      Field::new("hasSetter", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record155) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder156 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getParameterKind
  writer: ParquetWriter,
}

impl TableBuilder156 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getParameterKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record156) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder157 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // getNameAsString
  c2: arrow::array::builder::StringBuilder, // getQualifiedNameAsString
  c3: arrow::array::builder::BooleanBuilder, // hasLinkage
  c4: arrow::array::builder::BooleanBuilder, // isCXXClassMember
  c5: arrow::array::builder::BooleanBuilder, // isCXXInstanceMember
  c6: arrow::array::builder::UInt64Builder, // getLinkageInternal
  c7: arrow::array::builder::UInt64Builder, // getFormalLinkage
  c8: arrow::array::builder::BooleanBuilder, // hasExternalFormalLinkage
  c9: arrow::array::builder::BooleanBuilder, // isExternallyVisible
  c10: arrow::array::builder::BooleanBuilder, // isExternallyDeclarable
  c11: arrow::array::builder::BooleanBuilder, // isLinkageValid
  c12: arrow::array::builder::BooleanBuilder, // hasLinkageBeenComputed
  c13: arrow::array::builder::UInt64Builder, // getUnderlyingDecl
  c14: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c15: arrow::array::builder::UInt64Builder, // getObjCFStringFormattingFamily
  writer: ParquetWriter,
}

impl TableBuilder157 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNameAsString", DataType::Utf8, false),
      Field::new("getQualifiedNameAsString", DataType::Utf8, false),
      Field::new("hasLinkage", DataType::Boolean, false),
      Field::new("isCXXClassMember", DataType::Boolean, false),
      Field::new("isCXXInstanceMember", DataType::Boolean, false),
      Field::new("getLinkageInternal", DataType::UInt64, false),
      Field::new("getFormalLinkage", DataType::UInt64, false),
      Field::new("hasExternalFormalLinkage", DataType::Boolean, false),
      Field::new("isExternallyVisible", DataType::Boolean, false),
      Field::new("isExternallyDeclarable", DataType::Boolean, false),
      Field::new("isLinkageValid", DataType::Boolean, false),
      Field::new("hasLinkageBeenComputed", DataType::Boolean, false),
      Field::new("getUnderlyingDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getObjCFStringFormattingFamily", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record157) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder158 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperatorDelete
  c2: arrow::array::builder::UInt64Builder, // getOperatorDeleteThisArg
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder158 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperatorDelete", DataType::UInt64, false),
      Field::new("getOperatorDeleteThisArg", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record158) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder159 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getType
  c2: arrow::array::builder::BooleanBuilder, // isWeak
  c3: arrow::array::builder::BooleanBuilder, // isInitCapture
  c4: arrow::array::builder::UInt64Builder, // getPotentiallyDecomposedVarDecl
  writer: ParquetWriter,
}

impl TableBuilder159 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getType", DataType::UInt64, false),
      Field::new("isWeak", DataType::Boolean, false),
      Field::new("isInitCapture", DataType::Boolean, false),
      Field::new("getPotentiallyDecomposedVarDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record159) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder160 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder160 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record160) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder161 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBody
  c2: arrow::array::builder::BooleanBuilder, // isNothrow
  c3: arrow::array::builder::UInt32Builder, // getNumParams
  c4: arrow::array::builder::UInt64Builder, // getContextParam
  c5: arrow::array::builder::UInt32Builder, // getContextParamPosition
  writer: ParquetWriter,
}

impl TableBuilder161 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("isNothrow", DataType::Boolean, false),
      Field::new("getNumParams", DataType::UInt32, false),
      Field::new("getContextParam", DataType::UInt64, false),
      Field::new("getContextParamPosition", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record161) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder162 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getFriendDecl
  c2: arrow::array::builder::UInt64Builder, // getFriendLoc
  c3: arrow::array::builder::UInt32Builder, // getNumTemplateParameters
  writer: ParquetWriter,
}

impl TableBuilder162 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getFriendDecl", DataType::UInt64, false),
      Field::new("getFriendLoc", DataType::UInt64, false),
      Field::new("getNumTemplateParameters", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record162) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder163 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder163 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record163) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder164 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getChainingSize
  c2: arrow::array::builder::UInt64Builder, // getAnonField
  c3: arrow::array::builder::UInt64Builder, // getVarDecl
  c4: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder164 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getChainingSize", DataType::UInt32, false),
      Field::new("getAnonField", DataType::UInt64, false),
      Field::new("getVarDecl", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record164) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder165 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInitExpr
  c2: arrow::array::builder::UInt64Builder, // getSourceRange
  c3: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder165 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInitExpr", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record165) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder166 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isExplicit
  c2: arrow::array::builder::UInt64Builder, // getConversionType
  c3: arrow::array::builder::BooleanBuilder, // isLambdaToBlockPointerConversion
  c4: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder166 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isExplicit", DataType::Boolean, false),
      Field::new("getConversionType", DataType::UInt64, false),
      Field::new("isLambdaToBlockPointerConversion", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record166) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder167 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder167 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record167) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder168 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c2: arrow::array::builder::UInt64Builder, // getPreviousDecl
  c3: arrow::array::builder::UInt64Builder, // getMostRecentDecl
  c4: arrow::array::builder::UInt64Builder, // getDefinition
  c5: arrow::array::builder::UInt64Builder, // getSourceRange
  c6: arrow::array::builder::UInt64Builder, // getPromotionType
  c7: arrow::array::builder::UInt64Builder, // getIntegerType
  c8: arrow::array::builder::UInt64Builder, // getIntegerTypeRange
  c9: arrow::array::builder::UInt32Builder, // getNumPositiveBits
  c10: arrow::array::builder::UInt32Builder, // getNumNegativeBits
  c11: arrow::array::builder::BooleanBuilder, // isScoped
  c12: arrow::array::builder::BooleanBuilder, // isScopedUsingClassTag
  c13: arrow::array::builder::BooleanBuilder, // isFixed
  c14: arrow::array::builder::BooleanBuilder, // isComplete
  c15: arrow::array::builder::BooleanBuilder, // isClosed
  c16: arrow::array::builder::BooleanBuilder, // isClosedFlag
  c17: arrow::array::builder::BooleanBuilder, // isClosedNonFlag
  c18: arrow::array::builder::UInt64Builder, // getTemplateInstantiationPattern
  c19: arrow::array::builder::UInt64Builder, // getInstantiatedFromMemberEnum
  c20: arrow::array::builder::UInt64Builder, // getTemplateSpecializationKind
  writer: ParquetWriter,
}

impl TableBuilder168 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getPreviousDecl", DataType::UInt64, false),
      Field::new("getMostRecentDecl", DataType::UInt64, false),
      Field::new("getDefinition", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getPromotionType", DataType::UInt64, false),
      Field::new("getIntegerType", DataType::UInt64, false),
      Field::new("getIntegerTypeRange", DataType::UInt64, false),
      Field::new("getNumPositiveBits", DataType::UInt32, false),
      Field::new("getNumNegativeBits", DataType::UInt32, false),
      Field::new("isScoped", DataType::Boolean, false),
      Field::new("isScopedUsingClassTag", DataType::Boolean, false),
      Field::new("isFixed", DataType::Boolean, false),
      Field::new("isComplete", DataType::Boolean, false),
      Field::new("isClosed", DataType::Boolean, false),
      Field::new("isClosedFlag", DataType::Boolean, false),
      Field::new("isClosedNonFlag", DataType::Boolean, false),
      Field::new("getTemplateInstantiationPattern", DataType::UInt64, false),
      Field::new("getInstantiatedFromMemberEnum", DataType::UInt64, false),
      Field::new("getTemplateSpecializationKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
      c10: arrow::array::builder::UInt32Builder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::UInt64Builder::new(),
      c20: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
    self.c10 = arrow::array::builder::UInt32Builder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::UInt64Builder::new();
    self.c20 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record168) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder169 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getUsingLoc
  c2: arrow::array::builder::BooleanBuilder, // isAccessDeclaration
  c3: arrow::array::builder::BooleanBuilder, // isPackExpansion
  c4: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c5: arrow::array::builder::UInt64Builder, // getSourceRange
  c6: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder169 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getUsingLoc", DataType::UInt64, false),
      Field::new("isAccessDeclaration", DataType::Boolean, false),
      Field::new("isPackExpansion", DataType::Boolean, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record169) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder170 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder170 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record170) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder171 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCaretLocation
  c2: arrow::array::builder::BooleanBuilder, // isVariadic
  c3: arrow::array::builder::UInt64Builder, // getCompoundBody
  c4: arrow::array::builder::UInt64Builder, // getBody
  c5: arrow::array::builder::BooleanBuilder, // param_empty
  c6: arrow::array::builder::UInt64Builder, // param_size
  c7: arrow::array::builder::UInt32Builder, // getNumParams
  c8: arrow::array::builder::BooleanBuilder, // hasCaptures
  c9: arrow::array::builder::UInt32Builder, // getNumCaptures
  c10: arrow::array::builder::BooleanBuilder, // capturesCXXThis
  c11: arrow::array::builder::BooleanBuilder, // blockMissingReturnType
  c12: arrow::array::builder::BooleanBuilder, // isConversionFromLambda
  c13: arrow::array::builder::BooleanBuilder, // doesNotEscape
  c14: arrow::array::builder::BooleanBuilder, // canAvoidCopyToHeap
  c15: arrow::array::builder::UInt32Builder, // getBlockManglingNumber
  c16: arrow::array::builder::UInt64Builder, // getBlockManglingContextDecl
  c17: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder171 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCaretLocation", DataType::UInt64, false),
      Field::new("isVariadic", DataType::Boolean, false),
      Field::new("getCompoundBody", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("param_empty", DataType::Boolean, false),
      Field::new("param_size", DataType::UInt64, false),
      Field::new("getNumParams", DataType::UInt32, false),
      Field::new("hasCaptures", DataType::Boolean, false),
      Field::new("getNumCaptures", DataType::UInt32, false),
      Field::new("capturesCXXThis", DataType::Boolean, false),
      Field::new("blockMissingReturnType", DataType::Boolean, false),
      Field::new("isConversionFromLambda", DataType::Boolean, false),
      Field::new("doesNotEscape", DataType::Boolean, false),
      Field::new("canAvoidCopyToHeap", DataType::Boolean, false),
      Field::new("getBlockManglingNumber", DataType::UInt32, false),
      Field::new("getBlockManglingContextDecl", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt32Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt32Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt32Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt32Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record171) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder172 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInnerLocStart
  c2: arrow::array::builder::UInt64Builder, // getOuterLocStart
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getTrailingRequiresClause
  c6: arrow::array::builder::UInt32Builder, // getNumTemplateParameterLists
  c7: arrow::array::builder::UInt64Builder, // getTypeSpecStartLoc
  c8: arrow::array::builder::UInt64Builder, // getTypeSpecEndLoc
  writer: ParquetWriter,
}

impl TableBuilder172 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInnerLocStart", DataType::UInt64, false),
      Field::new("getOuterLocStart", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getTrailingRequiresClause", DataType::UInt64, false),
      Field::new("getNumTemplateParameterLists", DataType::UInt32, false),
      Field::new("getTypeSpecStartLoc", DataType::UInt64, false),
      Field::new("getTypeSpecEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record172) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder173 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getDescribedAliasTemplate
  writer: ParquetWriter,
}

impl TableBuilder173 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getDescribedAliasTemplate", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record173) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder174 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isExplicit
  c2: arrow::array::builder::UInt64Builder, // getDeducedTemplate
  c3: arrow::array::builder::UInt64Builder, // getCorrespondingConstructor
  c4: arrow::array::builder::UInt64Builder, // getDeductionCandidateKind
  writer: ParquetWriter,
}

impl TableBuilder174 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isExplicit", DataType::Boolean, false),
      Field::new("getDeducedTemplate", DataType::UInt64, false),
      Field::new("getCorrespondingConstructor", DataType::UInt64, false),
      Field::new("getDeductionCandidateKind", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record174) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder175 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder175 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record175) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder176 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder176 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record176) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder177 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAccessSpecifierLoc
  c2: arrow::array::builder::UInt64Builder, // getColonLoc
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder177 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAccessSpecifierLoc", DataType::UInt64, false),
      Field::new("getColonLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record177) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder178 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::BooleanBuilder, // isObjCMethodParameter
  c3: arrow::array::builder::BooleanBuilder, // isDestroyedInCallee
  c4: arrow::array::builder::UInt32Builder, // getFunctionScopeDepth
  c5: arrow::array::builder::UInt32Builder, // getFunctionScopeIndex
  c6: arrow::array::builder::UInt64Builder, // getObjCDeclQualifier
  c7: arrow::array::builder::BooleanBuilder, // isKNRPromoted
  c8: arrow::array::builder::BooleanBuilder, // isExplicitObjectParameter
  c9: arrow::array::builder::UInt64Builder, // getExplicitObjectParamThisLoc
  c10: arrow::array::builder::UInt64Builder, // getDefaultArg
  c11: arrow::array::builder::UInt64Builder, // getDefaultArgRange
  c12: arrow::array::builder::UInt64Builder, // getUninstantiatedDefaultArg
  c13: arrow::array::builder::BooleanBuilder, // hasDefaultArg
  c14: arrow::array::builder::BooleanBuilder, // hasUnparsedDefaultArg
  c15: arrow::array::builder::BooleanBuilder, // hasUninstantiatedDefaultArg
  c16: arrow::array::builder::BooleanBuilder, // hasInheritedDefaultArg
  c17: arrow::array::builder::UInt64Builder, // getOriginalType
  writer: ParquetWriter,
}

impl TableBuilder178 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("isObjCMethodParameter", DataType::Boolean, false),
      Field::new("isDestroyedInCallee", DataType::Boolean, false),
      Field::new("getFunctionScopeDepth", DataType::UInt32, false),
      Field::new("getFunctionScopeIndex", DataType::UInt32, false),
      Field::new("getObjCDeclQualifier", DataType::UInt64, false),
      Field::new("isKNRPromoted", DataType::Boolean, false),
      Field::new("isExplicitObjectParameter", DataType::Boolean, false),
      Field::new("getExplicitObjectParamThisLoc", DataType::UInt64, false),
      Field::new("getDefaultArg", DataType::UInt64, false),
      Field::new("getDefaultArgRange", DataType::UInt64, false),
      Field::new("getUninstantiatedDefaultArg", DataType::UInt64, false),
      Field::new("hasDefaultArg", DataType::Boolean, false),
      Field::new("hasUnparsedDefaultArg", DataType::Boolean, false),
      Field::new("hasUninstantiatedDefaultArg", DataType::Boolean, false),
      Field::new("hasInheritedDefaultArg", DataType::Boolean, false),
      Field::new("getOriginalType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record178) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder179 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getFriendTypeNumTemplateParameterLists
  c2: arrow::array::builder::UInt64Builder, // getFriendDecl
  c3: arrow::array::builder::UInt64Builder, // getFriendLoc
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::BooleanBuilder, // isUnsupportedFriend
  writer: ParquetWriter,
}

impl TableBuilder179 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getFriendTypeNumTemplateParameterLists", DataType::UInt32, false),
      Field::new("getFriendDecl", DataType::UInt64, false),
      Field::new("getFriendLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("isUnsupportedFriend", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record179) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder180 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAsmLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::UInt64Builder, // getSourceRange
  c4: arrow::array::builder::UInt64Builder, // getAsmString
  writer: ParquetWriter,
}

impl TableBuilder180 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAsmLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getAsmString", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record180) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder181 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAssertExpr
  c2: arrow::array::builder::UInt64Builder, // getMessage
  c3: arrow::array::builder::BooleanBuilder, // isFailed
  c4: arrow::array::builder::UInt64Builder, // getRParenLoc
  c5: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder181 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAssertExpr", DataType::UInt64, false),
      Field::new("getMessage", DataType::UInt64, false),
      Field::new("isFailed", DataType::Boolean, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record181) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder182 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAnonymousNamespace
  writer: ParquetWriter,
}

impl TableBuilder182 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAnonymousNamespace", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record182) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder183 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLanguage
  c2: arrow::array::builder::BooleanBuilder, // hasBraces
  c3: arrow::array::builder::UInt64Builder, // getExternLoc
  c4: arrow::array::builder::UInt64Builder, // getRBraceLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder183 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLanguage", DataType::UInt64, false),
      Field::new("hasBraces", DataType::Boolean, false),
      Field::new("getExternLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record183) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder184 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder184 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record184) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder185 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::UInt64Builder, // getStmt
  c3: arrow::array::builder::BooleanBuilder, // isSemiMissing
  writer: ParquetWriter,
}

impl TableBuilder185 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getStmt", DataType::UInt64, false),
      Field::new("isSemiMissing", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record185) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder186 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasAssociatedConstraints
  c2: arrow::array::builder::UInt64Builder, // getTemplatedDecl
  c3: arrow::array::builder::BooleanBuilder, // isTypeAlias
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder186 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasAssociatedConstraints", DataType::Boolean, false),
      Field::new("getTemplatedDecl", DataType::UInt64, false),
      Field::new("isTypeAlias", DataType::Boolean, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record186) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder187 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSpecializedTemplate
  c2: arrow::array::builder::UInt64Builder, // getSpecializationKind
  c3: arrow::array::builder::BooleanBuilder, // isExplicitSpecialization
  c4: arrow::array::builder::BooleanBuilder, // isClassScopeExplicitSpecialization
  c5: arrow::array::builder::BooleanBuilder, // isExplicitInstantiationOrSpecialization
  c6: arrow::array::builder::UInt64Builder, // getPointOfInstantiation
  c7: arrow::array::builder::UInt64Builder, // getExternLoc
  c8: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c9: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder187 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSpecializedTemplate", DataType::UInt64, false),
      Field::new("getSpecializationKind", DataType::UInt64, false),
      Field::new("isExplicitSpecialization", DataType::Boolean, false),
      Field::new("isClassScopeExplicitSpecialization", DataType::Boolean, false),
      Field::new("isExplicitInstantiationOrSpecialization", DataType::Boolean, false),
      Field::new("getPointOfInstantiation", DataType::UInt64, false),
      Field::new("getExternLoc", DataType::UInt64, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record187) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder188 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getConstraintExpr
  c2: arrow::array::builder::UInt64Builder, // getSourceRange
  c3: arrow::array::builder::BooleanBuilder, // isTypeConcept
  c4: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  writer: ParquetWriter,
}

impl TableBuilder188 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getConstraintExpr", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("isTypeConcept", DataType::Boolean, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record188) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder189 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isAnonymousNamespace
  c2: arrow::array::builder::BooleanBuilder, // isInline
  c3: arrow::array::builder::BooleanBuilder, // isNested
  c4: arrow::array::builder::UInt64Builder, // getOriginalNamespace
  c5: arrow::array::builder::BooleanBuilder, // isOriginalNamespace
  c6: arrow::array::builder::UInt64Builder, // getAnonymousNamespace
  c7: arrow::array::builder::UInt64Builder, // getCanonicalDecl
  c8: arrow::array::builder::UInt64Builder, // getSourceRange
  c9: arrow::array::builder::UInt64Builder, // getBeginLoc
  c10: arrow::array::builder::UInt64Builder, // getRBraceLoc
  writer: ParquetWriter,
}

impl TableBuilder189 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isAnonymousNamespace", DataType::Boolean, false),
      Field::new("isInline", DataType::Boolean, false),
      Field::new("isNested", DataType::Boolean, false),
      Field::new("getOriginalNamespace", DataType::UInt64, false),
      Field::new("isOriginalNamespace", DataType::Boolean, false),
      Field::new("getAnonymousNamespace", DataType::UInt64, false),
      Field::new("getCanonicalDecl", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record189) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder190 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAsmLoc
  c2: arrow::array::builder::BooleanBuilder, // isSimple
  c3: arrow::array::builder::BooleanBuilder, // isVolatile
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::UInt32Builder, // getNumOutputs
  c7: arrow::array::builder::UInt32Builder, // getNumPlusOperands
  c8: arrow::array::builder::UInt32Builder, // getNumInputs
  c9: arrow::array::builder::UInt32Builder, // getNumClobbers
  writer: ParquetWriter,
}

impl TableBuilder190 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAsmLoc", DataType::UInt64, false),
      Field::new("isSimple", DataType::Boolean, false),
      Field::new("isVolatile", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getNumOutputs", DataType::UInt32, false),
      Field::new("getNumPlusOperands", DataType::UInt32, false),
      Field::new("getNumInputs", DataType::UInt32, false),
      Field::new("getNumClobbers", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::UInt32Builder::new(),
      c8: arrow::array::builder::UInt32Builder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::UInt32Builder::new();
    self.c8 = arrow::array::builder::UInt32Builder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record190) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder191 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  writer: ParquetWriter,
}

impl TableBuilder191 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record191) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder192 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder192 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record192) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder193 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasRewrittenInit
  c2: arrow::array::builder::UInt64Builder, // getField
  c3: arrow::array::builder::UInt64Builder, // getExpr
  c4: arrow::array::builder::UInt64Builder, // getRewrittenExpr
  c5: arrow::array::builder::UInt64Builder, // getUsedLocation
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder193 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasRewrittenInit", DataType::Boolean, false),
      Field::new("getField", DataType::UInt64, false),
      Field::new("getExpr", DataType::UInt64, false),
      Field::new("getRewrittenExpr", DataType::UInt64, false),
      Field::new("getUsedLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record193) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder194 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getConstructor
  c2: arrow::array::builder::UInt64Builder, // getLocation
  c3: arrow::array::builder::BooleanBuilder, // isElidable
  c4: arrow::array::builder::BooleanBuilder, // hadMultipleCandidates
  c5: arrow::array::builder::BooleanBuilder, // isListInitialization
  c6: arrow::array::builder::BooleanBuilder, // isStdInitListInitialization
  c7: arrow::array::builder::BooleanBuilder, // requiresZeroInitialization
  c8: arrow::array::builder::UInt64Builder, // getConstructionKind
  c9: arrow::array::builder::UInt32Builder, // getNumArgs
  c10: arrow::array::builder::BooleanBuilder, // isImmediateEscalating
  c11: arrow::array::builder::UInt64Builder, // getBeginLoc
  c12: arrow::array::builder::UInt64Builder, // getEndLoc
  c13: arrow::array::builder::UInt64Builder, // getParenOrBraceRange
  writer: ParquetWriter,
}

impl TableBuilder194 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getConstructor", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("isElidable", DataType::Boolean, false),
      Field::new("hadMultipleCandidates", DataType::Boolean, false),
      Field::new("isListInitialization", DataType::Boolean, false),
      Field::new("isStdInitListInitialization", DataType::Boolean, false),
      Field::new("requiresZeroInitialization", DataType::Boolean, false),
      Field::new("getConstructionKind", DataType::UInt64, false),
      Field::new("getNumArgs", DataType::UInt32, false),
      Field::new("isImmediateEscalating", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getParenOrBraceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record194) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder195 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getType
  c2: arrow::array::builder::UInt64Builder, // getDependence
  c3: arrow::array::builder::BooleanBuilder, // isValueDependent
  c4: arrow::array::builder::BooleanBuilder, // isTypeDependent
  c5: arrow::array::builder::BooleanBuilder, // isInstantiationDependent
  c6: arrow::array::builder::BooleanBuilder, // containsUnexpandedParameterPack
  c7: arrow::array::builder::BooleanBuilder, // containsErrors
  c8: arrow::array::builder::BooleanBuilder, // isLValue
  c9: arrow::array::builder::BooleanBuilder, // isPRValue
  c10: arrow::array::builder::BooleanBuilder, // isXValue
  c11: arrow::array::builder::BooleanBuilder, // isGLValue
  c12: arrow::array::builder::UInt64Builder, // getValueKind
  c13: arrow::array::builder::UInt64Builder, // getObjectKind
  c14: arrow::array::builder::BooleanBuilder, // isOrdinaryOrBitFieldObject
  c15: arrow::array::builder::BooleanBuilder, // refersToBitField
  c16: arrow::array::builder::UInt64Builder, // getSourceBitField
  c17: arrow::array::builder::UInt64Builder, // getReferencedDeclOfCallee
  c18: arrow::array::builder::UInt64Builder, // getObjCProperty
  c19: arrow::array::builder::BooleanBuilder, // isObjCSelfExpr
  c20: arrow::array::builder::BooleanBuilder, // refersToVectorElement
  c21: arrow::array::builder::BooleanBuilder, // refersToMatrixElement
  c22: arrow::array::builder::BooleanBuilder, // refersToGlobalRegisterVar
  c23: arrow::array::builder::UInt64Builder, // IgnoreImpCasts
  c24: arrow::array::builder::UInt64Builder, // IgnoreCasts
  c25: arrow::array::builder::UInt64Builder, // IgnoreImplicit
  c26: arrow::array::builder::UInt64Builder, // IgnoreImplicitAsWritten
  c27: arrow::array::builder::UInt64Builder, // IgnoreParens
  c28: arrow::array::builder::UInt64Builder, // IgnoreParenImpCasts
  c29: arrow::array::builder::UInt64Builder, // IgnoreParenCasts
  c30: arrow::array::builder::UInt64Builder, // IgnoreConversionOperatorSingleStep
  c31: arrow::array::builder::UInt64Builder, // IgnoreParenLValueCasts
  c32: arrow::array::builder::UInt64Builder, // IgnoreParenBaseCasts
  c33: arrow::array::builder::BooleanBuilder, // isDefaultArgument
  c34: arrow::array::builder::BooleanBuilder, // isImplicitCXXThis
  c35: arrow::array::builder::UInt64Builder, // skipRValueSubobjectAdjustments
  writer: ParquetWriter,
}

impl TableBuilder195 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getType", DataType::UInt64, false),
      Field::new("getDependence", DataType::UInt64, false),
      Field::new("isValueDependent", DataType::Boolean, false),
      Field::new("isTypeDependent", DataType::Boolean, false),
      Field::new("isInstantiationDependent", DataType::Boolean, false),
      Field::new("containsUnexpandedParameterPack", DataType::Boolean, false),
      Field::new("containsErrors", DataType::Boolean, false),
      Field::new("isLValue", DataType::Boolean, false),
      Field::new("isPRValue", DataType::Boolean, false),
      Field::new("isXValue", DataType::Boolean, false),
      Field::new("isGLValue", DataType::Boolean, false),
      Field::new("getValueKind", DataType::UInt64, false),
      Field::new("getObjectKind", DataType::UInt64, false),
      Field::new("isOrdinaryOrBitFieldObject", DataType::Boolean, false),
      Field::new("refersToBitField", DataType::Boolean, false),
      Field::new("getSourceBitField", DataType::UInt64, false),
      Field::new("getReferencedDeclOfCallee", DataType::UInt64, false),
      Field::new("getObjCProperty", DataType::UInt64, false),
      Field::new("isObjCSelfExpr", DataType::Boolean, false),
      Field::new("refersToVectorElement", DataType::Boolean, false),
      Field::new("refersToMatrixElement", DataType::Boolean, false),
      Field::new("refersToGlobalRegisterVar", DataType::Boolean, false),
      Field::new("IgnoreImpCasts", DataType::UInt64, false),
      Field::new("IgnoreCasts", DataType::UInt64, false),
      Field::new("IgnoreImplicit", DataType::UInt64, false),
      Field::new("IgnoreImplicitAsWritten", DataType::UInt64, false),
      Field::new("IgnoreParens", DataType::UInt64, false),
      Field::new("IgnoreParenImpCasts", DataType::UInt64, false),
      Field::new("IgnoreParenCasts", DataType::UInt64, false),
      Field::new("IgnoreConversionOperatorSingleStep", DataType::UInt64, false),
      Field::new("IgnoreParenLValueCasts", DataType::UInt64, false),
      Field::new("IgnoreParenBaseCasts", DataType::UInt64, false),
      Field::new("isDefaultArgument", DataType::Boolean, false),
      Field::new("isImplicitCXXThis", DataType::Boolean, false),
      Field::new("skipRValueSubobjectAdjustments", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
      c23: arrow::array::builder::UInt64Builder::new(),
      c24: arrow::array::builder::UInt64Builder::new(),
      c25: arrow::array::builder::UInt64Builder::new(),
      c26: arrow::array::builder::UInt64Builder::new(),
      c27: arrow::array::builder::UInt64Builder::new(),
      c28: arrow::array::builder::UInt64Builder::new(),
      c29: arrow::array::builder::UInt64Builder::new(),
      c30: arrow::array::builder::UInt64Builder::new(),
      c31: arrow::array::builder::UInt64Builder::new(),
      c32: arrow::array::builder::UInt64Builder::new(),
      c33: arrow::array::builder::BooleanBuilder::new(),
      c34: arrow::array::builder::BooleanBuilder::new(),
      c35: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
    self.c23 = arrow::array::builder::UInt64Builder::new();
    self.c24 = arrow::array::builder::UInt64Builder::new();
    self.c25 = arrow::array::builder::UInt64Builder::new();
    self.c26 = arrow::array::builder::UInt64Builder::new();
    self.c27 = arrow::array::builder::UInt64Builder::new();
    self.c28 = arrow::array::builder::UInt64Builder::new();
    self.c29 = arrow::array::builder::UInt64Builder::new();
    self.c30 = arrow::array::builder::UInt64Builder::new();
    self.c31 = arrow::array::builder::UInt64Builder::new();
    self.c32 = arrow::array::builder::UInt64Builder::new();
    self.c33 = arrow::array::builder::BooleanBuilder::new();
    self.c34 = arrow::array::builder::BooleanBuilder::new();
    self.c35 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record195) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    self.c23.append_value(record.c23);
    self.c24.append_value(record.c24);
    self.c25.append_value(record.c25);
    self.c26.append_value(record.c26);
    self.c27.append_value(record.c27);
    self.c28.append_value(record.c28);
    self.c29.append_value(record.c29);
    self.c30.append_value(record.c30);
    self.c31.append_value(record.c31);
    self.c32.append_value(record.c32);
    self.c33.append_value(record.c33);
    self.c34.append_value(record.c34);
    self.c35.append_value(record.c35);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
        Arc::new(self.c23.finish()),
        Arc::new(self.c24.finish()),
        Arc::new(self.c25.finish()),
        Arc::new(self.c26.finish()),
        Arc::new(self.c27.finish()),
        Arc::new(self.c28.finish()),
        Arc::new(self.c29.finish()),
        Arc::new(self.c30.finish()),
        Arc::new(self.c31.finish()),
        Arc::new(self.c32.finish()),
        Arc::new(self.c33.finish()),
        Arc::new(self.c34.finish()),
        Arc::new(self.c35.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder196 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasVarStorage
  c2: arrow::array::builder::UInt64Builder, // getCond
  c3: arrow::array::builder::UInt64Builder, // getBody
  c4: arrow::array::builder::UInt64Builder, // getConditionVariable
  c5: arrow::array::builder::UInt64Builder, // getConditionVariableDeclStmt
  c6: arrow::array::builder::UInt64Builder, // getWhileLoc
  c7: arrow::array::builder::UInt64Builder, // getLParenLoc
  c8: arrow::array::builder::UInt64Builder, // getRParenLoc
  c9: arrow::array::builder::UInt64Builder, // getBeginLoc
  c10: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder196 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasVarStorage", DataType::Boolean, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getConditionVariable", DataType::UInt64, false),
      Field::new("getConditionVariableDeclStmt", DataType::UInt64, false),
      Field::new("getWhileLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record196) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder197 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getExprStmt
  writer: ParquetWriter,
}

impl TableBuilder197 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getExprStmt", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record197) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder198 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCond
  c2: arrow::array::builder::UInt64Builder, // getBody
  c3: arrow::array::builder::UInt64Builder, // getDoLoc
  c4: arrow::array::builder::UInt64Builder, // getWhileLoc
  c5: arrow::array::builder::UInt64Builder, // getRParenLoc
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder198 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getDoLoc", DataType::UInt64, false),
      Field::new("getWhileLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record198) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder199 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLocation
  c2: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c3: arrow::array::builder::UInt64Builder, // getLAngleLoc
  c4: arrow::array::builder::UInt64Builder, // getRAngleLoc
  c5: arrow::array::builder::BooleanBuilder, // hasTemplateKeyword
  c6: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c7: arrow::array::builder::UInt32Builder, // getNumTemplateArgs
  c8: arrow::array::builder::UInt64Builder, // getBeginLoc
  c9: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder199 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getLAngleLoc", DataType::UInt64, false),
      Field::new("getRAngleLoc", DataType::UInt64, false),
      Field::new("hasTemplateKeyword", DataType::Boolean, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getNumTemplateArgs", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::UInt32Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::UInt32Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record199) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder200 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getGotoLoc
  c2: arrow::array::builder::UInt64Builder, // getStarLoc
  c3: arrow::array::builder::UInt64Builder, // getTarget
  c4: arrow::array::builder::UInt64Builder, // getConstantTarget
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder200 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getGotoLoc", DataType::UInt64, false),
      Field::new("getStarLoc", DataType::UInt64, false),
      Field::new("getTarget", DataType::UInt64, false),
      Field::new("getConstantTarget", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record200) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder201 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getContinueLoc
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder201 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getContinueLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record201) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder202 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNamedConcept
  c2: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c3: arrow::array::builder::UInt64Builder, // getConceptNameLoc
  c4: arrow::array::builder::UInt64Builder, // getTemplateKWLoc
  c5: arrow::array::builder::UInt64Builder, // getFoundDecl
  c6: arrow::array::builder::UInt64Builder, // getSpecializationDecl
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  c9: arrow::array::builder::UInt64Builder, // getExprLoc
  writer: ParquetWriter,
}

impl TableBuilder202 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNamedConcept", DataType::UInt64, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getConceptNameLoc", DataType::UInt64, false),
      Field::new("getTemplateKWLoc", DataType::UInt64, false),
      Field::new("getFoundDecl", DataType::UInt64, false),
      Field::new("getSpecializationDecl", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record202) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder203 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getRetValue
  c2: arrow::array::builder::UInt64Builder, // getNRVOCandidate
  c3: arrow::array::builder::UInt64Builder, // getReturnLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder203 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getRetValue", DataType::UInt64, false),
      Field::new("getNRVOCandidate", DataType::UInt64, false),
      Field::new("getReturnLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record203) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder204 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getRParenLoc
  c2: arrow::array::builder::UInt64Builder, // getAsmString
  c3: arrow::array::builder::BooleanBuilder, // isAsmGoto
  c4: arrow::array::builder::UInt32Builder, // getNumLabels
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder204 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getAsmString", DataType::UInt64, false),
      Field::new("isAsmGoto", DataType::Boolean, false),
      Field::new("getNumLabels", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record204) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder205 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::StringBuilder, // element
  writer: ParquetWriter,
}

impl TableBuilder205 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record205) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder206 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::StringBuilder, // element
  writer: ParquetWriter,
}

impl TableBuilder206 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::Utf8, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
  }

  pub async fn push(&mut self, record: Record206) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder207 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder207 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record207) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder208 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLBraceLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::BooleanBuilder, // hasBraces
  c4: arrow::array::builder::StringBuilder, // getAsmString
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  writer: ParquetWriter,
}

impl TableBuilder208 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLBraceLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("hasBraces", DataType::Boolean, false),
      Field::new("getAsmString", DataType::Utf8, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::StringBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::StringBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record208) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder209 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getExceptLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getFilterExpr
  c5: arrow::array::builder::UInt64Builder, // getBlock
  writer: ParquetWriter,
}

impl TableBuilder209 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getExceptLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getFilterExpr", DataType::UInt64, false),
      Field::new("getBlock", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record209) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder210 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getTryLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::BooleanBuilder, // getIsCXXTry
  c5: arrow::array::builder::UInt64Builder, // getTryBlock
  c6: arrow::array::builder::UInt64Builder, // getHandler
  c7: arrow::array::builder::UInt64Builder, // getExceptHandler
  c8: arrow::array::builder::UInt64Builder, // getFinallyHandler
  writer: ParquetWriter,
}

impl TableBuilder210 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getTryLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getIsCXXTry", DataType::Boolean, false),
      Field::new("getTryBlock", DataType::UInt64, false),
      Field::new("getHandler", DataType::UInt64, false),
      Field::new("getExceptHandler", DataType::UInt64, false),
      Field::new("getFinallyHandler", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record210) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder211 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder211 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record211) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder212 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumInits
  c2: arrow::array::builder::UInt64Builder, // getArrayFiller
  c3: arrow::array::builder::BooleanBuilder, // hasArrayFiller
  c4: arrow::array::builder::BooleanBuilder, // hasDesignatedInit
  c5: arrow::array::builder::UInt64Builder, // getInitializedFieldInUnion
  c6: arrow::array::builder::BooleanBuilder, // isExplicit
  c7: arrow::array::builder::BooleanBuilder, // isStringLiteralInit
  c8: arrow::array::builder::BooleanBuilder, // isTransparent
  c9: arrow::array::builder::UInt64Builder, // getLBraceLoc
  c10: arrow::array::builder::UInt64Builder, // getRBraceLoc
  c11: arrow::array::builder::BooleanBuilder, // isSemanticForm
  c12: arrow::array::builder::UInt64Builder, // getSemanticForm
  c13: arrow::array::builder::BooleanBuilder, // isSyntacticForm
  c14: arrow::array::builder::UInt64Builder, // getSyntacticForm
  c15: arrow::array::builder::BooleanBuilder, // hadArrayRangeDesignator
  c16: arrow::array::builder::UInt64Builder, // getBeginLoc
  c17: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder212 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumInits", DataType::UInt32, false),
      Field::new("getArrayFiller", DataType::UInt64, false),
      Field::new("hasArrayFiller", DataType::Boolean, false),
      Field::new("hasDesignatedInit", DataType::Boolean, false),
      Field::new("getInitializedFieldInUnion", DataType::UInt64, false),
      Field::new("isExplicit", DataType::Boolean, false),
      Field::new("isStringLiteralInit", DataType::Boolean, false),
      Field::new("isTransparent", DataType::Boolean, false),
      Field::new("getLBraceLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
      Field::new("isSemanticForm", DataType::Boolean, false),
      Field::new("getSemanticForm", DataType::UInt64, false),
      Field::new("isSyntacticForm", DataType::Boolean, false),
      Field::new("getSyntacticForm", DataType::UInt64, false),
      Field::new("hadArrayRangeDesignator", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record212) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder213 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLeaveLoc
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder213 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLeaveLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record213) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder214 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder214 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record214) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder215 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCapturedStmt
  c2: arrow::array::builder::UInt64Builder, // getCapturedDecl
  c3: arrow::array::builder::UInt64Builder, // getCapturedRegionKind
  c4: arrow::array::builder::UInt64Builder, // getCapturedRecordDecl
  c5: arrow::array::builder::UInt32Builder, // capture_size
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  c8: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder215 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCapturedStmt", DataType::UInt64, false),
      Field::new("getCapturedDecl", DataType::UInt64, false),
      Field::new("getCapturedRegionKind", DataType::UInt64, false),
      Field::new("getCapturedRecordDecl", DataType::UInt64, false),
      Field::new("capture_size", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record215) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder216 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getCatchLoc
  c4: arrow::array::builder::UInt64Builder, // getExceptionDecl
  c5: arrow::array::builder::UInt64Builder, // getCaughtType
  c6: arrow::array::builder::UInt64Builder, // getHandlerBlock
  writer: ParquetWriter,
}

impl TableBuilder216 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getCatchLoc", DataType::UInt64, false),
      Field::new("getExceptionDecl", DataType::UInt64, false),
      Field::new("getCaughtType", DataType::UInt64, false),
      Field::new("getHandlerBlock", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record216) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder217 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInit
  c2: arrow::array::builder::UInt64Builder, // getLoopVariable
  c3: arrow::array::builder::UInt64Builder, // getRangeInit
  c4: arrow::array::builder::UInt64Builder, // getRangeStmt
  c5: arrow::array::builder::UInt64Builder, // getBeginStmt
  c6: arrow::array::builder::UInt64Builder, // getEndStmt
  c7: arrow::array::builder::UInt64Builder, // getCond
  c8: arrow::array::builder::UInt64Builder, // getInc
  c9: arrow::array::builder::UInt64Builder, // getLoopVarStmt
  c10: arrow::array::builder::UInt64Builder, // getBody
  c11: arrow::array::builder::UInt64Builder, // getForLoc
  c12: arrow::array::builder::UInt64Builder, // getCoawaitLoc
  c13: arrow::array::builder::UInt64Builder, // getColonLoc
  c14: arrow::array::builder::UInt64Builder, // getRParenLoc
  c15: arrow::array::builder::UInt64Builder, // getBeginLoc
  c16: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder217 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getLoopVariable", DataType::UInt64, false),
      Field::new("getRangeInit", DataType::UInt64, false),
      Field::new("getRangeStmt", DataType::UInt64, false),
      Field::new("getBeginStmt", DataType::UInt64, false),
      Field::new("getEndStmt", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getInc", DataType::UInt64, false),
      Field::new("getLoopVarStmt", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getForLoc", DataType::UInt64, false),
      Field::new("getCoawaitLoc", DataType::UInt64, false),
      Field::new("getColonLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record217) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder218 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAllocatedType
  c2: arrow::array::builder::UInt64Builder, // getOperatorNew
  c3: arrow::array::builder::UInt64Builder, // getOperatorDelete
  c4: arrow::array::builder::BooleanBuilder, // isArray
  c5: arrow::array::builder::UInt32Builder, // getNumPlacementArgs
  c6: arrow::array::builder::BooleanBuilder, // isParenTypeId
  c7: arrow::array::builder::UInt64Builder, // getTypeIdParens
  c8: arrow::array::builder::BooleanBuilder, // isGlobalNew
  c9: arrow::array::builder::BooleanBuilder, // hasInitializer
  c10: arrow::array::builder::UInt64Builder, // getInitializationStyle
  c11: arrow::array::builder::UInt64Builder, // getInitializer
  c12: arrow::array::builder::UInt64Builder, // getConstructExpr
  c13: arrow::array::builder::BooleanBuilder, // passAlignment
  c14: arrow::array::builder::BooleanBuilder, // doesUsualArrayDeleteWantSize
  c15: arrow::array::builder::UInt64Builder, // getBeginLoc
  c16: arrow::array::builder::UInt64Builder, // getEndLoc
  c17: arrow::array::builder::UInt64Builder, // getDirectInitRange
  c18: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder218 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAllocatedType", DataType::UInt64, false),
      Field::new("getOperatorNew", DataType::UInt64, false),
      Field::new("getOperatorDelete", DataType::UInt64, false),
      Field::new("isArray", DataType::Boolean, false),
      Field::new("getNumPlacementArgs", DataType::UInt32, false),
      Field::new("isParenTypeId", DataType::Boolean, false),
      Field::new("getTypeIdParens", DataType::UInt64, false),
      Field::new("isGlobalNew", DataType::Boolean, false),
      Field::new("hasInitializer", DataType::Boolean, false),
      Field::new("getInitializationStyle", DataType::UInt64, false),
      Field::new("getInitializer", DataType::UInt64, false),
      Field::new("getConstructExpr", DataType::UInt64, false),
      Field::new("passAlignment", DataType::Boolean, false),
      Field::new("doesUsualArrayDeleteWantSize", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getDirectInitRange", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record218) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder219 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder219 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record219) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder220 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasDependentPromiseType
  c2: arrow::array::builder::UInt64Builder, // getBody
  c3: arrow::array::builder::UInt64Builder, // getPromiseDeclStmt
  c4: arrow::array::builder::UInt64Builder, // getPromiseDecl
  c5: arrow::array::builder::UInt64Builder, // getInitSuspendStmt
  c6: arrow::array::builder::UInt64Builder, // getFinalSuspendStmt
  c7: arrow::array::builder::UInt64Builder, // getExceptionHandler
  c8: arrow::array::builder::UInt64Builder, // getFallthroughHandler
  c9: arrow::array::builder::UInt64Builder, // getAllocate
  c10: arrow::array::builder::UInt64Builder, // getDeallocate
  c11: arrow::array::builder::UInt64Builder, // getResultDecl
  c12: arrow::array::builder::UInt64Builder, // getReturnValueInit
  c13: arrow::array::builder::UInt64Builder, // getReturnValue
  c14: arrow::array::builder::UInt64Builder, // getReturnStmt
  c15: arrow::array::builder::UInt64Builder, // getReturnStmtOnAllocFailure
  c16: arrow::array::builder::UInt64Builder, // getBeginLoc
  c17: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder220 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasDependentPromiseType", DataType::Boolean, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getPromiseDeclStmt", DataType::UInt64, false),
      Field::new("getPromiseDecl", DataType::UInt64, false),
      Field::new("getInitSuspendStmt", DataType::UInt64, false),
      Field::new("getFinalSuspendStmt", DataType::UInt64, false),
      Field::new("getExceptionHandler", DataType::UInt64, false),
      Field::new("getFallthroughHandler", DataType::UInt64, false),
      Field::new("getAllocate", DataType::UInt64, false),
      Field::new("getDeallocate", DataType::UInt64, false),
      Field::new("getResultDecl", DataType::UInt64, false),
      Field::new("getReturnValueInit", DataType::UInt64, false),
      Field::new("getReturnValue", DataType::UInt64, false),
      Field::new("getReturnStmt", DataType::UInt64, false),
      Field::new("getReturnStmtOnAllocFailure", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record220) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder221 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumExprs
  c2: arrow::array::builder::UInt64Builder, // getLParenLoc
  c3: arrow::array::builder::UInt64Builder, // getRParenLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder221 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumExprs", DataType::UInt32, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record221) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder222 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getRParenLoc
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder222 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record222) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder223 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSourceRange
  c2: arrow::array::builder::BooleanBuilder, // isImplicitAccess
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getBaseExpr
  c6: arrow::array::builder::UInt64Builder, // getPropertyDecl
  c7: arrow::array::builder::BooleanBuilder, // isArrow
  c8: arrow::array::builder::UInt64Builder, // getMemberLoc
  writer: ParquetWriter,
}

impl TableBuilder223 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("isImplicitAccess", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getBaseExpr", DataType::UInt64, false),
      Field::new("getPropertyDecl", DataType::UInt64, false),
      Field::new("isArrow", DataType::Boolean, false),
      Field::new("getMemberLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record223) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder224 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getFinallyLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getBlock
  writer: ParquetWriter,
}

impl TableBuilder224 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getFinallyLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getBlock", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record224) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder225 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getDecl
  c2: arrow::array::builder::UInt64Builder, // getLocation
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::BooleanBuilder, // hasQualifier
  c6: arrow::array::builder::UInt64Builder, // getFoundDecl
  c7: arrow::array::builder::BooleanBuilder, // hasTemplateKWAndArgsInfo
  c8: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c9: arrow::array::builder::UInt64Builder, // getLAngleLoc
  c10: arrow::array::builder::UInt64Builder, // getRAngleLoc
  c11: arrow::array::builder::BooleanBuilder, // hasTemplateKeyword
  c12: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c13: arrow::array::builder::UInt32Builder, // getNumTemplateArgs
  c14: arrow::array::builder::BooleanBuilder, // hadMultipleCandidates
  c15: arrow::array::builder::UInt64Builder, // isNonOdrUse
  c16: arrow::array::builder::BooleanBuilder, // refersToEnclosingVariableOrCapture
  c17: arrow::array::builder::BooleanBuilder, // isImmediateEscalating
  c18: arrow::array::builder::BooleanBuilder, // isCapturedByCopyInLambdaWithExplicitObjectParameter
  writer: ParquetWriter,
}

impl TableBuilder225 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("hasQualifier", DataType::Boolean, false),
      Field::new("getFoundDecl", DataType::UInt64, false),
      Field::new("hasTemplateKWAndArgsInfo", DataType::Boolean, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getLAngleLoc", DataType::UInt64, false),
      Field::new("getRAngleLoc", DataType::UInt64, false),
      Field::new("hasTemplateKeyword", DataType::Boolean, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getNumTemplateArgs", DataType::UInt32, false),
      Field::new("hadMultipleCandidates", DataType::Boolean, false),
      Field::new("isNonOdrUse", DataType::UInt64, false),
      Field::new("refersToEnclosingVariableOrCapture", DataType::Boolean, false),
      Field::new("isImmediateEscalating", DataType::Boolean, false),
      Field::new("isCapturedByCopyInLambdaWithExplicitObjectParameter", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::UInt32Builder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::UInt32Builder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record225) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder226 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLParenLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder226 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record226) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder227 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getLocation
  writer: ParquetWriter,
}

impl TableBuilder227 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record227) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder228 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getConditionVariable
  c2: arrow::array::builder::UInt64Builder, // getConditionVariableDeclStmt
  c3: arrow::array::builder::UInt64Builder, // getInit
  c4: arrow::array::builder::UInt64Builder, // getCond
  c5: arrow::array::builder::UInt64Builder, // getInc
  c6: arrow::array::builder::UInt64Builder, // getBody
  c7: arrow::array::builder::UInt64Builder, // getForLoc
  c8: arrow::array::builder::UInt64Builder, // getLParenLoc
  c9: arrow::array::builder::UInt64Builder, // getRParenLoc
  c10: arrow::array::builder::UInt64Builder, // getBeginLoc
  c11: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder228 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getConditionVariable", DataType::UInt64, false),
      Field::new("getConditionVariableDeclStmt", DataType::UInt64, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getInc", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getForLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record228) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder229 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSrcExpr
  c2: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c3: arrow::array::builder::UInt64Builder, // getRParenLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder229 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSrcExpr", DataType::UInt64, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record229) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder230 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isIncomplete
  c2: arrow::array::builder::UInt64Builder, // getBase
  c3: arrow::array::builder::UInt64Builder, // getRowIdx
  c4: arrow::array::builder::UInt64Builder, // getColumnIdx
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  c7: arrow::array::builder::UInt64Builder, // getExprLoc
  c8: arrow::array::builder::UInt64Builder, // getRBracketLoc
  writer: ParquetWriter,
}

impl TableBuilder230 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isIncomplete", DataType::Boolean, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getRowIdx", DataType::UInt64, false),
      Field::new("getColumnIdx", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getRBracketLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record230) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder231 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder231 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record231) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder232 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getAngleBrackets
  writer: ParquetWriter,
}

impl TableBuilder232 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getAngleBrackets", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record232) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder233 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBase
  c2: arrow::array::builder::UInt64Builder, // getMemberDecl
  c3: arrow::array::builder::BooleanBuilder, // hasQualifier
  c4: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c5: arrow::array::builder::UInt64Builder, // getLAngleLoc
  c6: arrow::array::builder::UInt64Builder, // getRAngleLoc
  c7: arrow::array::builder::BooleanBuilder, // hasTemplateKeyword
  c8: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c9: arrow::array::builder::UInt32Builder, // getNumTemplateArgs
  c10: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c11: arrow::array::builder::BooleanBuilder, // isArrow
  c12: arrow::array::builder::UInt64Builder, // getMemberLoc
  c13: arrow::array::builder::UInt64Builder, // getBeginLoc
  c14: arrow::array::builder::UInt64Builder, // getEndLoc
  c15: arrow::array::builder::UInt64Builder, // getExprLoc
  c16: arrow::array::builder::BooleanBuilder, // isImplicitAccess
  c17: arrow::array::builder::BooleanBuilder, // hadMultipleCandidates
  c18: arrow::array::builder::UInt64Builder, // isNonOdrUse
  writer: ParquetWriter,
}

impl TableBuilder233 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getMemberDecl", DataType::UInt64, false),
      Field::new("hasQualifier", DataType::Boolean, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getLAngleLoc", DataType::UInt64, false),
      Field::new("getRAngleLoc", DataType::UInt64, false),
      Field::new("hasTemplateKeyword", DataType::Boolean, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getNumTemplateArgs", DataType::UInt32, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("isArrow", DataType::Boolean, false),
      Field::new("getMemberLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("isImplicitAccess", DataType::Boolean, false),
      Field::new("hadMultipleCandidates", DataType::Boolean, false),
      Field::new("isNonOdrUse", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record233) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder234 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperand
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::BooleanBuilder, // getValue
  writer: ParquetWriter,
}

impl TableBuilder234 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperand", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getValue", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record234) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder235 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBlockDecl
  c2: arrow::array::builder::UInt64Builder, // getCaretLocation
  c3: arrow::array::builder::UInt64Builder, // getBody
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::UInt64Builder, // getFunctionType
  writer: ParquetWriter,
}

impl TableBuilder235 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBlockDecl", DataType::UInt64, false),
      Field::new("getCaretLocation", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getFunctionType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record235) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder236 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBreakLoc
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder236 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBreakLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record236) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder237 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getTryLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getTryBlock
  c5: arrow::array::builder::UInt32Builder, // getNumHandlers
  writer: ParquetWriter,
}

impl TableBuilder237 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getTryLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getTryBlock", DataType::UInt64, false),
      Field::new("getNumHandlers", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record237) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder238 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // stripLabelLikeStatements
  writer: ParquetWriter,
}

impl TableBuilder238 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("stripLabelLikeStatements", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record238) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder239 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getExprLoc
  c2: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c3: arrow::array::builder::UInt64Builder, // getOpcode
  c4: arrow::array::builder::UInt64Builder, // getLHS
  c5: arrow::array::builder::UInt64Builder, // getRHS
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  c8: arrow::array::builder::StringBuilder, // getOpcodeStr
  c9: arrow::array::builder::BooleanBuilder, // isPtrMemOp
  c10: arrow::array::builder::BooleanBuilder, // isMultiplicativeOp
  c11: arrow::array::builder::BooleanBuilder, // isAdditiveOp
  c12: arrow::array::builder::BooleanBuilder, // isShiftOp
  c13: arrow::array::builder::BooleanBuilder, // isBitwiseOp
  c14: arrow::array::builder::BooleanBuilder, // isRelationalOp
  c15: arrow::array::builder::BooleanBuilder, // isEqualityOp
  c16: arrow::array::builder::BooleanBuilder, // isComparisonOp
  c17: arrow::array::builder::BooleanBuilder, // isCommaOp
  c18: arrow::array::builder::BooleanBuilder, // isLogicalOp
  c19: arrow::array::builder::BooleanBuilder, // isAssignmentOp
  c20: arrow::array::builder::BooleanBuilder, // isCompoundAssignmentOp
  c21: arrow::array::builder::BooleanBuilder, // isShiftAssignOp
  c22: arrow::array::builder::BooleanBuilder, // hasStoredFPFeatures
  writer: ParquetWriter,
}

impl TableBuilder239 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getOpcode", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getOpcodeStr", DataType::Utf8, false),
      Field::new("isPtrMemOp", DataType::Boolean, false),
      Field::new("isMultiplicativeOp", DataType::Boolean, false),
      Field::new("isAdditiveOp", DataType::Boolean, false),
      Field::new("isShiftOp", DataType::Boolean, false),
      Field::new("isBitwiseOp", DataType::Boolean, false),
      Field::new("isRelationalOp", DataType::Boolean, false),
      Field::new("isEqualityOp", DataType::Boolean, false),
      Field::new("isComparisonOp", DataType::Boolean, false),
      Field::new("isCommaOp", DataType::Boolean, false),
      Field::new("isLogicalOp", DataType::Boolean, false),
      Field::new("isAssignmentOp", DataType::Boolean, false),
      Field::new("isCompoundAssignmentOp", DataType::Boolean, false),
      Field::new("isShiftAssignOp", DataType::Boolean, false),
      Field::new("hasStoredFPFeatures", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::StringBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::BooleanBuilder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::BooleanBuilder::new(),
      c19: arrow::array::builder::BooleanBuilder::new(),
      c20: arrow::array::builder::BooleanBuilder::new(),
      c21: arrow::array::builder::BooleanBuilder::new(),
      c22: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::StringBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::BooleanBuilder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::BooleanBuilder::new();
    self.c19 = arrow::array::builder::BooleanBuilder::new();
    self.c20 = arrow::array::builder::BooleanBuilder::new();
    self.c21 = arrow::array::builder::BooleanBuilder::new();
    self.c22 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record239) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    self.c22.append_value(record.c22);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
        Arc::new(self.c22.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder240 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLocation
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getExprLoc
  c5: arrow::array::builder::UInt64Builder, // getSourceExpr
  c6: arrow::array::builder::BooleanBuilder, // isUnique
  writer: ParquetWriter,
}

impl TableBuilder240 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getSourceExpr", DataType::UInt64, false),
      Field::new("isUnique", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record240) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder241 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isImplicitAccess
  c2: arrow::array::builder::UInt64Builder, // getBaseType
  c3: arrow::array::builder::BooleanBuilder, // hasUnresolvedUsing
  c4: arrow::array::builder::BooleanBuilder, // isArrow
  c5: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c6: arrow::array::builder::UInt64Builder, // getNamingClass
  c7: arrow::array::builder::UInt64Builder, // getMemberLoc
  c8: arrow::array::builder::UInt64Builder, // getExprLoc
  c9: arrow::array::builder::UInt64Builder, // getBeginLoc
  c10: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder241 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isImplicitAccess", DataType::Boolean, false),
      Field::new("getBaseType", DataType::UInt64, false),
      Field::new("hasUnresolvedUsing", DataType::Boolean, false),
      Field::new("isArrow", DataType::Boolean, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getNamingClass", DataType::UInt64, false),
      Field::new("getMemberLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record241) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder242 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubStmt
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getLParenLoc
  c5: arrow::array::builder::UInt64Builder, // getRParenLoc
  c6: arrow::array::builder::UInt32Builder, // getTemplateDepth
  writer: ParquetWriter,
}

impl TableBuilder242 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getTemplateDepth", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record242) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder243 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getParameterPack
  c2: arrow::array::builder::UInt64Builder, // getParameterPackLocation
  c3: arrow::array::builder::UInt32Builder, // getNumExpansions
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder243 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getParameterPack", DataType::UInt64, false),
      Field::new("getParameterPackLocation", DataType::UInt64, false),
      Field::new("getNumExpansions", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record243) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder244 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isPartOfExplicitCast
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder244 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isPartOfExplicitCast", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record244) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder245 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLiteralOperatorKind
  c2: arrow::array::builder::UInt64Builder, // getCookedLiteral
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getUDSuffixLoc
  writer: ParquetWriter,
}

impl TableBuilder245 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLiteralOperatorKind", DataType::UInt64, false),
      Field::new("getCookedLiteral", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getUDSuffixLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record245) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder246 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isAlwaysNull
  writer: ParquetWriter,
}

impl TableBuilder246 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isAlwaysNull", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record246) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder247 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getTrait
  c4: arrow::array::builder::UInt64Builder, // getQueriedType
  c5: arrow::array::builder::UInt64Builder, // getDimensionExpression
  writer: ParquetWriter,
}

impl TableBuilder247 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getTrait", DataType::UInt64, false),
      Field::new("getQueriedType", DataType::UInt64, false),
      Field::new("getDimensionExpression", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record247) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder248 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder248 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record248) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder249 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // body_empty
  c2: arrow::array::builder::UInt32Builder, // size
  c3: arrow::array::builder::BooleanBuilder, // hasStoredFPFeatures
  c4: arrow::array::builder::UInt64Builder, // body_front
  c5: arrow::array::builder::UInt64Builder, // body_back
  c6: arrow::array::builder::UInt64Builder, // getStmtExprResult
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  c9: arrow::array::builder::UInt64Builder, // getLBracLoc
  c10: arrow::array::builder::UInt64Builder, // getRBracLoc
  writer: ParquetWriter,
}

impl TableBuilder249 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("body_empty", DataType::Boolean, false),
      Field::new("size", DataType::UInt32, false),
      Field::new("hasStoredFPFeatures", DataType::Boolean, false),
      Field::new("body_front", DataType::UInt64, false),
      Field::new("body_back", DataType::UInt64, false),
      Field::new("getStmtExprResult", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLBracLoc", DataType::UInt64, false),
      Field::new("getRBracLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record249) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder250 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBase
  c2: arrow::array::builder::BooleanBuilder, // hasQualifier
  c3: arrow::array::builder::BooleanBuilder, // isArrow
  c4: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c5: arrow::array::builder::UInt64Builder, // getColonColonLoc
  c6: arrow::array::builder::UInt64Builder, // getTildeLoc
  c7: arrow::array::builder::UInt64Builder, // getDestroyedType
  c8: arrow::array::builder::UInt64Builder, // getDestroyedTypeLoc
  c9: arrow::array::builder::UInt64Builder, // getBeginLoc
  c10: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder250 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("hasQualifier", DataType::Boolean, false),
      Field::new("isArrow", DataType::Boolean, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getColonColonLoc", DataType::UInt64, false),
      Field::new("getTildeLoc", DataType::UInt64, false),
      Field::new("getDestroyedType", DataType::UInt64, false),
      Field::new("getDestroyedTypeLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record250) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder251 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // getString
  c2: arrow::array::builder::StringBuilder, // getBytes
  c3: arrow::array::builder::UInt32Builder, // getByteLength
  c4: arrow::array::builder::UInt32Builder, // getLength
  c5: arrow::array::builder::UInt32Builder, // getCharByteWidth
  c6: arrow::array::builder::UInt64Builder, // getKind
  c7: arrow::array::builder::BooleanBuilder, // isOrdinary
  c8: arrow::array::builder::BooleanBuilder, // isWide
  c9: arrow::array::builder::BooleanBuilder, // isUTF8
  c10: arrow::array::builder::BooleanBuilder, // isUTF16
  c11: arrow::array::builder::BooleanBuilder, // isUTF32
  c12: arrow::array::builder::BooleanBuilder, // isUnevaluated
  c13: arrow::array::builder::BooleanBuilder, // isPascal
  c14: arrow::array::builder::BooleanBuilder, // containsNonAscii
  c15: arrow::array::builder::BooleanBuilder, // containsNonAsciiOrNull
  c16: arrow::array::builder::UInt32Builder, // getNumConcatenated
  c17: arrow::array::builder::UInt64Builder, // getBeginLoc
  c18: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder251 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getString", DataType::Utf8, false),
      Field::new("getBytes", DataType::Utf8, false),
      Field::new("getByteLength", DataType::UInt32, false),
      Field::new("getLength", DataType::UInt32, false),
      Field::new("getCharByteWidth", DataType::UInt32, false),
      Field::new("getKind", DataType::UInt64, false),
      Field::new("isOrdinary", DataType::Boolean, false),
      Field::new("isWide", DataType::Boolean, false),
      Field::new("isUTF8", DataType::Boolean, false),
      Field::new("isUTF16", DataType::Boolean, false),
      Field::new("isUTF32", DataType::Boolean, false),
      Field::new("isUnevaluated", DataType::Boolean, false),
      Field::new("isPascal", DataType::Boolean, false),
      Field::new("containsNonAscii", DataType::Boolean, false),
      Field::new("containsNonAsciiOrNull", DataType::Boolean, false),
      Field::new("getNumConcatenated", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
      c2: arrow::array::builder::StringBuilder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::UInt32Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
    self.c2 = arrow::array::builder::StringBuilder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::UInt32Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record251) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder252 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getParam
  c2: arrow::array::builder::BooleanBuilder, // hasRewrittenInit
  c3: arrow::array::builder::UInt64Builder, // getExpr
  c4: arrow::array::builder::UInt64Builder, // getRewrittenExpr
  c5: arrow::array::builder::UInt64Builder, // getAdjustedRewrittenExpr
  c6: arrow::array::builder::UInt64Builder, // getUsedLocation
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  c9: arrow::array::builder::UInt64Builder, // getExprLoc
  writer: ParquetWriter,
}

impl TableBuilder252 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getParam", DataType::UInt64, false),
      Field::new("hasRewrittenInit", DataType::Boolean, false),
      Field::new("getExpr", DataType::UInt64, false),
      Field::new("getRewrittenExpr", DataType::UInt64, false),
      Field::new("getAdjustedRewrittenExpr", DataType::UInt64, false),
      Field::new("getUsedLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record252) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder253 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLocation
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::BooleanBuilder, // isImplicit
  writer: ParquetWriter,
}

impl TableBuilder253 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("isImplicit", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record253) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder254 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isTypeOperand
  c2: arrow::array::builder::UInt64Builder, // getExprOperand
  c3: arrow::array::builder::UInt64Builder, // getGuidDecl
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder254 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isTypeOperand", DataType::Boolean, false),
      Field::new("getExprOperand", DataType::UInt64, false),
      Field::new("getGuidDecl", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record254) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder255 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt32Builder, // getNumSubExprs
  writer: ParquetWriter,
}

impl TableBuilder255 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getNumSubExprs", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record255) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder256 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder256 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record256) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder257 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder257 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record257) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder258 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isSingleDecl
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  writer: ParquetWriter,
}

impl TableBuilder258 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isSingleDecl", DataType::Boolean, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record258) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder259 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder259 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record259) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder260 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPtr
  c2: arrow::array::builder::UInt64Builder, // getOrder
  c3: arrow::array::builder::UInt64Builder, // getScope
  c4: arrow::array::builder::UInt64Builder, // getVal1
  c5: arrow::array::builder::UInt64Builder, // getOrderFail
  c6: arrow::array::builder::UInt64Builder, // getVal2
  c7: arrow::array::builder::UInt64Builder, // getWeak
  c8: arrow::array::builder::UInt64Builder, // getValueType
  c9: arrow::array::builder::UInt64Builder, // getOp
  c10: arrow::array::builder::StringBuilder, // getOpAsString
  c11: arrow::array::builder::UInt32Builder, // getNumSubExprs
  c12: arrow::array::builder::BooleanBuilder, // isVolatile
  c13: arrow::array::builder::BooleanBuilder, // isCmpXChg
  c14: arrow::array::builder::BooleanBuilder, // isOpenCL
  c15: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c16: arrow::array::builder::UInt64Builder, // getRParenLoc
  c17: arrow::array::builder::UInt64Builder, // getBeginLoc
  c18: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder260 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPtr", DataType::UInt64, false),
      Field::new("getOrder", DataType::UInt64, false),
      Field::new("getScope", DataType::UInt64, false),
      Field::new("getVal1", DataType::UInt64, false),
      Field::new("getOrderFail", DataType::UInt64, false),
      Field::new("getVal2", DataType::UInt64, false),
      Field::new("getWeak", DataType::UInt64, false),
      Field::new("getValueType", DataType::UInt64, false),
      Field::new("getOp", DataType::UInt64, false),
      Field::new("getOpAsString", DataType::Utf8, false),
      Field::new("getNumSubExprs", DataType::UInt32, false),
      Field::new("isVolatile", DataType::Boolean, false),
      Field::new("isCmpXChg", DataType::Boolean, false),
      Field::new("isOpenCL", DataType::Boolean, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::StringBuilder::new(),
      c11: arrow::array::builder::UInt32Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::UInt64Builder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::StringBuilder::new();
    self.c11 = arrow::array::builder::UInt32Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::UInt64Builder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record260) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder261 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder261 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record261) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder262 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder262 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record262) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder263 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getThrowLoc
  c3: arrow::array::builder::BooleanBuilder, // isThrownVariableInScope
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder263 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getThrowLoc", DataType::UInt64, false),
      Field::new("isThrownVariableInScope", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record263) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder264 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCond
  c2: arrow::array::builder::UInt64Builder, // getTrueExpr
  c3: arrow::array::builder::UInt64Builder, // getFalseExpr
  c4: arrow::array::builder::UInt64Builder, // getQuestionLoc
  c5: arrow::array::builder::UInt64Builder, // getColonLoc
  writer: ParquetWriter,
}

impl TableBuilder264 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getTrueExpr", DataType::UInt64, false),
      Field::new("getFalseExpr", DataType::UInt64, false),
      Field::new("getQuestionLoc", DataType::UInt64, false),
      Field::new("getColonLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record264) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder265 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder265 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record265) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder266 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder266 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record266) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder267 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCommon
  c2: arrow::array::builder::UInt64Builder, // getOpaqueValue
  c3: arrow::array::builder::UInt64Builder, // getCond
  c4: arrow::array::builder::UInt64Builder, // getTrueExpr
  c5: arrow::array::builder::UInt64Builder, // getFalseExpr
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder267 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCommon", DataType::UInt64, false),
      Field::new("getOpaqueValue", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getTrueExpr", DataType::UInt64, false),
      Field::new("getFalseExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record267) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder268 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBase
  c2: arrow::array::builder::UInt64Builder, // getAccessorLoc
  c3: arrow::array::builder::UInt32Builder, // getNumElements
  c4: arrow::array::builder::BooleanBuilder, // containsDuplicateElements
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  c7: arrow::array::builder::BooleanBuilder, // isArrow
  writer: ParquetWriter,
}

impl TableBuilder268 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getAccessorLoc", DataType::UInt64, false),
      Field::new("getNumElements", DataType::UInt32, false),
      Field::new("containsDuplicateElements", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("isArrow", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record268) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder269 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isPotentiallyEvaluated
  c2: arrow::array::builder::BooleanBuilder, // isTypeOperand
  c3: arrow::array::builder::UInt64Builder, // getExprOperand
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder269 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isPotentiallyEvaluated", DataType::Boolean, false),
      Field::new("isTypeOperand", DataType::Boolean, false),
      Field::new("getExprOperand", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record269) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder270 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder270 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record270) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder271 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumAssocs
  c2: arrow::array::builder::UInt32Builder, // getResultIndex
  c3: arrow::array::builder::BooleanBuilder, // isResultDependent
  c4: arrow::array::builder::BooleanBuilder, // isExprPredicate
  c5: arrow::array::builder::BooleanBuilder, // isTypePredicate
  c6: arrow::array::builder::UInt64Builder, // getControllingExpr
  c7: arrow::array::builder::UInt64Builder, // getResultExpr
  c8: arrow::array::builder::UInt64Builder, // getGenericLoc
  c9: arrow::array::builder::UInt64Builder, // getDefaultLoc
  c10: arrow::array::builder::UInt64Builder, // getRParenLoc
  c11: arrow::array::builder::UInt64Builder, // getBeginLoc
  c12: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder271 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumAssocs", DataType::UInt32, false),
      Field::new("getResultIndex", DataType::UInt32, false),
      Field::new("isResultDependent", DataType::Boolean, false),
      Field::new("isExprPredicate", DataType::Boolean, false),
      Field::new("isTypePredicate", DataType::Boolean, false),
      Field::new("getControllingExpr", DataType::UInt64, false),
      Field::new("getResultExpr", DataType::UInt64, false),
      Field::new("getGenericLoc", DataType::UInt64, false),
      Field::new("getDefaultLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record271) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder272 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getTrait
  c4: arrow::array::builder::UInt64Builder, // getQueriedExpression
  c5: arrow::array::builder::BooleanBuilder, // getValue
  writer: ParquetWriter,
}

impl TableBuilder272 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getTrait", DataType::UInt64, false),
      Field::new("getQueriedExpression", DataType::UInt64, false),
      Field::new("getValue", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record272) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder273 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getImplicitObjectArgument
  c2: arrow::array::builder::UInt64Builder, // getObjectType
  c3: arrow::array::builder::UInt64Builder, // getMethodDecl
  c4: arrow::array::builder::UInt64Builder, // getRecordDecl
  c5: arrow::array::builder::UInt64Builder, // getExprLoc
  writer: ParquetWriter,
}

impl TableBuilder273 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getImplicitObjectArgument", DataType::UInt64, false),
      Field::new("getObjectType", DataType::UInt64, false),
      Field::new("getMethodDecl", DataType::UInt64, false),
      Field::new("getRecordDecl", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record273) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder274 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLHS
  c2: arrow::array::builder::UInt64Builder, // getRHS
  c3: arrow::array::builder::UInt64Builder, // getBase
  c4: arrow::array::builder::UInt64Builder, // getIdx
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  c7: arrow::array::builder::UInt64Builder, // getRBracketLoc
  c8: arrow::array::builder::UInt64Builder, // getExprLoc
  writer: ParquetWriter,
}

impl TableBuilder274 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getIdx", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getRBracketLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record274) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder275 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder275 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record275) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder276 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBody
  c2: arrow::array::builder::UInt64Builder, // getRequiresKWLoc
  c3: arrow::array::builder::UInt64Builder, // getLParenLoc
  c4: arrow::array::builder::UInt64Builder, // getRParenLoc
  c5: arrow::array::builder::UInt64Builder, // getRBraceLoc
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder276 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getRequiresKWLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getRBraceLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record276) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder277 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder277 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record277) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder278 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCastKind
  c2: arrow::array::builder::UInt64Builder, // getSubExpr
  c3: arrow::array::builder::UInt64Builder, // getSubExprAsWritten
  c4: arrow::array::builder::UInt64Builder, // getConversionFunction
  c5: arrow::array::builder::BooleanBuilder, // path_empty
  c6: arrow::array::builder::UInt32Builder, // path_size
  c7: arrow::array::builder::BooleanBuilder, // hasStoredFPFeatures
  c8: arrow::array::builder::BooleanBuilder, // changesVolatileQualification
  writer: ParquetWriter,
}

impl TableBuilder278 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCastKind", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getSubExprAsWritten", DataType::UInt64, false),
      Field::new("getConversionFunction", DataType::UInt64, false),
      Field::new("path_empty", DataType::Boolean, false),
      Field::new("path_size", DataType::UInt32, false),
      Field::new("hasStoredFPFeatures", DataType::Boolean, false),
      Field::new("changesVolatileQualification", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record278) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder279 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getPattern
  c2: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder279 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getPattern", DataType::UInt64, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record279) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder280 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder280 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record280) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder281 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::UInt32Builder, // getNumComponents
  c4: arrow::array::builder::UInt32Builder, // getNumExpressions
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder281 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getNumComponents", DataType::UInt32, false),
      Field::new("getNumExpressions", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record281) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder282 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getKind
  c2: arrow::array::builder::BooleanBuilder, // isArgumentType
  c3: arrow::array::builder::UInt64Builder, // getTypeOfArgument
  c4: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c5: arrow::array::builder::UInt64Builder, // getRParenLoc
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder282 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getKind", DataType::UInt64, false),
      Field::new("isArgumentType", DataType::Boolean, false),
      Field::new("getTypeOfArgument", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record282) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder283 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getIdentLoc
  c2: arrow::array::builder::UInt64Builder, // getDecl
  c3: arrow::array::builder::UInt64Builder, // getSubStmt
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  c6: arrow::array::builder::BooleanBuilder, // isSideEntry
  writer: ParquetWriter,
}

impl TableBuilder283 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getIdentLoc", DataType::UInt64, false),
      Field::new("getDecl", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("isSideEntry", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record283) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder284 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // getValue
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getLocation
  writer: ParquetWriter,
}

impl TableBuilder284 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getValue", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record284) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder285 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLocation
  c2: arrow::array::builder::UInt64Builder, // getKind
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt32Builder, // getValue
  writer: ParquetWriter,
}

impl TableBuilder285 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getKind", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getValue", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record285) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder286 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder286 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record286) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder287 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAttrLoc
  c2: arrow::array::builder::UInt64Builder, // getSubStmt
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder287 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAttrLoc", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record287) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder288 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasInitStorage
  c2: arrow::array::builder::BooleanBuilder, // hasVarStorage
  c3: arrow::array::builder::UInt64Builder, // getCond
  c4: arrow::array::builder::UInt64Builder, // getBody
  c5: arrow::array::builder::UInt64Builder, // getInit
  c6: arrow::array::builder::UInt64Builder, // getConditionVariable
  c7: arrow::array::builder::UInt64Builder, // getConditionVariableDeclStmt
  c8: arrow::array::builder::UInt64Builder, // getSwitchCaseList
  c9: arrow::array::builder::UInt64Builder, // getSwitchLoc
  c10: arrow::array::builder::UInt64Builder, // getLParenLoc
  c11: arrow::array::builder::UInt64Builder, // getRParenLoc
  c12: arrow::array::builder::BooleanBuilder, // isAllEnumCasesCovered
  c13: arrow::array::builder::UInt64Builder, // getBeginLoc
  c14: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder288 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasInitStorage", DataType::Boolean, false),
      Field::new("hasVarStorage", DataType::Boolean, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getConditionVariable", DataType::UInt64, false),
      Field::new("getConditionVariableDeclStmt", DataType::UInt64, false),
      Field::new("getSwitchCaseList", DataType::UInt64, false),
      Field::new("getSwitchLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("isAllEnumCasesCovered", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record288) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder289 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getResultAPValueKind
  c4: arrow::array::builder::UInt64Builder, // getResultStorageKind
  c5: arrow::array::builder::BooleanBuilder, // isImmediateInvocation
  c6: arrow::array::builder::BooleanBuilder, // hasAPValueResult
  writer: ParquetWriter,
}

impl TableBuilder289 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getResultAPValueKind", DataType::UInt64, false),
      Field::new("getResultStorageKind", DataType::UInt64, false),
      Field::new("isImmediateInvocation", DataType::Boolean, false),
      Field::new("hasAPValueResult", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record289) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder290 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSrcExpr
  c2: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c3: arrow::array::builder::UInt64Builder, // getRParenLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder290 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSrcExpr", DataType::UInt64, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record290) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder291 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getLocation
  writer: ParquetWriter,
}

impl TableBuilder291 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record291) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder292 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder292 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record292) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder293 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBase
  c2: arrow::array::builder::UInt64Builder, // getIdx
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getRBracketLoc
  c6: arrow::array::builder::UInt64Builder, // getExprLoc
  writer: ParquetWriter,
}

impl TableBuilder293 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getIdx", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getRBracketLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record293) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder294 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSemiLoc
  c2: arrow::array::builder::BooleanBuilder, // hasLeadingEmptyMacro
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder294 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSemiLoc", DataType::UInt64, false),
      Field::new("hasLeadingEmptyMacro", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record294) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder295 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder295 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record295) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder296 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLParenLoc
  c2: arrow::array::builder::UInt64Builder, // getRParenLoc
  c3: arrow::array::builder::BooleanBuilder, // isListInitialization
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder296 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("isListInitialization", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record296) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder297 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperator
  c2: arrow::array::builder::BooleanBuilder, // isAssignmentOp
  c3: arrow::array::builder::BooleanBuilder, // isComparisonOp
  c4: arrow::array::builder::BooleanBuilder, // isInfixBinaryOp
  c5: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c6: arrow::array::builder::UInt64Builder, // getExprLoc
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  c9: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder297 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperator", DataType::UInt64, false),
      Field::new("isAssignmentOp", DataType::Boolean, false),
      Field::new("isComparisonOp", DataType::Boolean, false),
      Field::new("isInfixBinaryOp", DataType::Boolean, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record297) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder298 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder298 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record298) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder299 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSemanticForm
  c2: arrow::array::builder::BooleanBuilder, // isReversed
  c3: arrow::array::builder::UInt64Builder, // getOperator
  c4: arrow::array::builder::UInt64Builder, // getOpcode
  c5: arrow::array::builder::StringBuilder, // getOpcodeStr
  c6: arrow::array::builder::BooleanBuilder, // isComparisonOp
  c7: arrow::array::builder::BooleanBuilder, // isAssignmentOp
  c8: arrow::array::builder::UInt64Builder, // getLHS
  c9: arrow::array::builder::UInt64Builder, // getRHS
  c10: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c11: arrow::array::builder::UInt64Builder, // getExprLoc
  c12: arrow::array::builder::UInt64Builder, // getBeginLoc
  c13: arrow::array::builder::UInt64Builder, // getEndLoc
  c14: arrow::array::builder::UInt64Builder, // getSourceRange
  writer: ParquetWriter,
}

impl TableBuilder299 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSemanticForm", DataType::UInt64, false),
      Field::new("isReversed", DataType::Boolean, false),
      Field::new("getOperator", DataType::UInt64, false),
      Field::new("getOpcode", DataType::UInt64, false),
      Field::new("getOpcodeStr", DataType::Utf8, false),
      Field::new("isComparisonOp", DataType::Boolean, false),
      Field::new("isAssignmentOp", DataType::Boolean, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::StringBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::StringBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record299) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder300 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNamingClass
  c2: arrow::array::builder::UInt32Builder, // getNumDecls
  c3: arrow::array::builder::UInt64Builder, // getNameLoc
  c4: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c5: arrow::array::builder::UInt64Builder, // getLAngleLoc
  c6: arrow::array::builder::UInt64Builder, // getRAngleLoc
  c7: arrow::array::builder::BooleanBuilder, // hasTemplateKeyword
  c8: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c9: arrow::array::builder::UInt32Builder, // getNumTemplateArgs
  writer: ParquetWriter,
}

impl TableBuilder300 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNamingClass", DataType::UInt64, false),
      Field::new("getNumDecls", DataType::UInt32, false),
      Field::new("getNameLoc", DataType::UInt64, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getLAngleLoc", DataType::UInt64, false),
      Field::new("getRAngleLoc", DataType::UInt64, false),
      Field::new("hasTemplateKeyword", DataType::Boolean, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getNumTemplateArgs", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record300) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder301 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getBase
  c4: arrow::array::builder::UInt64Builder, // getUpdater
  writer: ParquetWriter,
}

impl TableBuilder301 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getBase", DataType::UInt64, false),
      Field::new("getUpdater", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record301) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder302 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCond
  c2: arrow::array::builder::UInt64Builder, // getTrueExpr
  c3: arrow::array::builder::UInt64Builder, // getFalseExpr
  c4: arrow::array::builder::UInt64Builder, // getLHS
  c5: arrow::array::builder::UInt64Builder, // getRHS
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder302 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getTrueExpr", DataType::UInt64, false),
      Field::new("getFalseExpr", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record302) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder303 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTrait
  c2: arrow::array::builder::UInt32Builder, // getNumArgs
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder303 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTrait", DataType::UInt64, false),
      Field::new("getNumArgs", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record303) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder304 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getConstructor
  c2: arrow::array::builder::BooleanBuilder, // constructsVBase
  c3: arrow::array::builder::UInt64Builder, // getConstructionKind
  c4: arrow::array::builder::BooleanBuilder, // inheritedFromVBase
  c5: arrow::array::builder::UInt64Builder, // getLocation
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder304 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getConstructor", DataType::UInt64, false),
      Field::new("constructsVBase", DataType::Boolean, false),
      Field::new("getConstructionKind", DataType::UInt64, false),
      Field::new("inheritedFromVBase", DataType::Boolean, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record304) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder305 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubStmt
  c2: arrow::array::builder::UInt64Builder, // getDefaultLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder305 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getDefaultLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record305) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder306 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getComputationLHSType
  c2: arrow::array::builder::UInt64Builder, // getComputationResultType
  writer: ParquetWriter,
}

impl TableBuilder306 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getComputationLHSType", DataType::UInt64, false),
      Field::new("getComputationResultType", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record306) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder307 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getLParen
  c5: arrow::array::builder::UInt64Builder, // getRParen
  writer: ParquetWriter,
}

impl TableBuilder307 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLParen", DataType::UInt64, false),
      Field::new("getRParen", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record307) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder308 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder308 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record308) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder309 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSyntacticForm
  c2: arrow::array::builder::UInt32Builder, // getResultExprIndex
  c3: arrow::array::builder::UInt64Builder, // getResultExpr
  c4: arrow::array::builder::UInt32Builder, // getNumSemanticExprs
  c5: arrow::array::builder::UInt64Builder, // getExprLoc
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder309 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSyntacticForm", DataType::UInt64, false),
      Field::new("getResultExprIndex", DataType::UInt32, false),
      Field::new("getResultExpr", DataType::UInt64, false),
      Field::new("getNumSemanticExprs", DataType::UInt32, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record309) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder310 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getLocation
  c4: arrow::array::builder::UInt32Builder, // getScale
  writer: ParquetWriter,
}

impl TableBuilder310 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getScale", DataType::UInt32, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt32Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt32Builder::new();
  }

  pub async fn push(&mut self, record: Record310) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder311 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNextSwitchCase
  c2: arrow::array::builder::UInt64Builder, // getKeywordLoc
  c3: arrow::array::builder::UInt64Builder, // getColonLoc
  c4: arrow::array::builder::UInt64Builder, // getSubStmt
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder311 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNextSwitchCase", DataType::UInt64, false),
      Field::new("getKeywordLoc", DataType::UInt64, false),
      Field::new("getColonLoc", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record311) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder312 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getLabel
  c2: arrow::array::builder::UInt64Builder, // getGotoLoc
  c3: arrow::array::builder::UInt64Builder, // getLabelLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder312 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getLabel", DataType::UInt64, false),
      Field::new("getGotoLoc", DataType::UInt64, false),
      Field::new("getLabelLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record312) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder313 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getInitializer
  c2: arrow::array::builder::BooleanBuilder, // isFileScope
  c3: arrow::array::builder::UInt64Builder, // getLParenLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder313 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getInitializer", DataType::UInt64, false),
      Field::new("isFileScope", DataType::Boolean, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record313) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder314 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::BooleanBuilder, // isMicrosoftABI
  c3: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c4: arrow::array::builder::UInt64Builder, // getRParenLoc
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder314 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("isMicrosoftABI", DataType::Boolean, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record314) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder315 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAmpAmpLoc
  c2: arrow::array::builder::UInt64Builder, // getLabelLoc
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  c5: arrow::array::builder::UInt64Builder, // getLabel
  writer: ParquetWriter,
}

impl TableBuilder315 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAmpAmpLoc", DataType::UInt64, false),
      Field::new("getLabelLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLabel", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record315) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder316 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTokenLocation
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder316 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTokenLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record316) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder317 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // requiresADL
  c2: arrow::array::builder::BooleanBuilder, // isOverloaded
  c3: arrow::array::builder::UInt64Builder, // getNamingClass
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder317 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("requiresADL", DataType::Boolean, false),
      Field::new("isOverloaded", DataType::Boolean, false),
      Field::new("getNamingClass", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record317) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder318 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder318 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record318) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder319 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder319 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record319) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder320 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTypeAsWritten
  c2: arrow::array::builder::UInt64Builder, // getLParenLoc
  c3: arrow::array::builder::UInt64Builder, // getRParenLoc
  c4: arrow::array::builder::BooleanBuilder, // isListInitialization
  c5: arrow::array::builder::UInt32Builder, // getNumArgs
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder320 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTypeAsWritten", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("isListInitialization", DataType::Boolean, false),
      Field::new("getNumArgs", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record320) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder321 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getTypeAsWritten
  writer: ParquetWriter,
}

impl TableBuilder321 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getTypeAsWritten", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record321) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder322 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isConditionTrue
  c2: arrow::array::builder::BooleanBuilder, // isConditionDependent
  c3: arrow::array::builder::UInt64Builder, // getChosenSubExpr
  c4: arrow::array::builder::UInt64Builder, // getCond
  c5: arrow::array::builder::UInt64Builder, // getLHS
  c6: arrow::array::builder::UInt64Builder, // getRHS
  c7: arrow::array::builder::UInt64Builder, // getBuiltinLoc
  c8: arrow::array::builder::UInt64Builder, // getRParenLoc
  c9: arrow::array::builder::UInt64Builder, // getBeginLoc
  c10: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder322 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isConditionTrue", DataType::Boolean, false),
      Field::new("isConditionDependent", DataType::Boolean, false),
      Field::new("getChosenSubExpr", DataType::UInt64, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getBuiltinLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record322) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder323 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isImplicitAccess
  c2: arrow::array::builder::UInt64Builder, // getBaseType
  c3: arrow::array::builder::BooleanBuilder, // isArrow
  c4: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c5: arrow::array::builder::UInt64Builder, // getFirstQualifierFoundInScope
  c6: arrow::array::builder::UInt64Builder, // getMemberLoc
  c7: arrow::array::builder::UInt64Builder, // getTemplateKeywordLoc
  c8: arrow::array::builder::UInt64Builder, // getLAngleLoc
  c9: arrow::array::builder::UInt64Builder, // getRAngleLoc
  c10: arrow::array::builder::BooleanBuilder, // hasTemplateKeyword
  c11: arrow::array::builder::BooleanBuilder, // hasExplicitTemplateArgs
  c12: arrow::array::builder::UInt32Builder, // getNumTemplateArgs
  c13: arrow::array::builder::UInt64Builder, // getBeginLoc
  c14: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder323 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isImplicitAccess", DataType::Boolean, false),
      Field::new("getBaseType", DataType::UInt64, false),
      Field::new("isArrow", DataType::Boolean, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getFirstQualifierFoundInScope", DataType::UInt64, false),
      Field::new("getMemberLoc", DataType::UInt64, false),
      Field::new("getTemplateKeywordLoc", DataType::UInt64, false),
      Field::new("getLAngleLoc", DataType::UInt64, false),
      Field::new("getRAngleLoc", DataType::UInt64, false),
      Field::new("hasTemplateKeyword", DataType::Boolean, false),
      Field::new("hasExplicitTemplateArgs", DataType::Boolean, false),
      Field::new("getNumTemplateArgs", DataType::UInt32, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::BooleanBuilder::new(),
      c12: arrow::array::builder::UInt32Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::BooleanBuilder::new();
    self.c12 = arrow::array::builder::UInt32Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record323) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder324 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // caseStmtIsGNURange
  c2: arrow::array::builder::UInt64Builder, // getCaseLoc
  c3: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c4: arrow::array::builder::UInt64Builder, // getLHS
  c5: arrow::array::builder::UInt64Builder, // getRHS
  c6: arrow::array::builder::UInt64Builder, // getSubStmt
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder324 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("caseStmtIsGNURange", DataType::Boolean, false),
      Field::new("getCaseLoc", DataType::UInt64, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record324) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder325 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // size
  c2: arrow::array::builder::UInt64Builder, // getEqualOrColonLoc
  c3: arrow::array::builder::BooleanBuilder, // isDirectInit
  c4: arrow::array::builder::BooleanBuilder, // usesGNUSyntax
  c5: arrow::array::builder::UInt64Builder, // getInit
  c6: arrow::array::builder::UInt32Builder, // getNumSubExprs
  c7: arrow::array::builder::UInt64Builder, // getDesignatorsSourceRange
  c8: arrow::array::builder::UInt64Builder, // getBeginLoc
  c9: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder325 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("size", DataType::UInt32, false),
      Field::new("getEqualOrColonLoc", DataType::UInt64, false),
      Field::new("isDirectInit", DataType::Boolean, false),
      Field::new("usesGNUSyntax", DataType::Boolean, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getNumSubExprs", DataType::UInt32, false),
      Field::new("getDesignatorsSourceRange", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record325) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder326 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder326 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record326) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder327 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c2: arrow::array::builder::UInt64Builder, // getPackLoc
  c3: arrow::array::builder::UInt64Builder, // getRParenLoc
  c4: arrow::array::builder::UInt64Builder, // getPack
  c5: arrow::array::builder::BooleanBuilder, // isPartiallySubstituted
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder327 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("getPackLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getPack", DataType::UInt64, false),
      Field::new("isPartiallySubstituted", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record327) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder328 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getIdentKind
  c2: arrow::array::builder::BooleanBuilder, // isTransparent
  c3: arrow::array::builder::UInt64Builder, // getLocation
  c4: arrow::array::builder::UInt64Builder, // getFunctionName
  c5: arrow::array::builder::StringBuilder, // getIdentKindName
  c6: arrow::array::builder::UInt64Builder, // getBeginLoc
  c7: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder328 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getIdentKind", DataType::UInt64, false),
      Field::new("isTransparent", DataType::Boolean, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getFunctionName", DataType::UInt64, false),
      Field::new("getIdentKindName", DataType::Utf8, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::StringBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::StringBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record328) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder329 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getNameLoc
  c2: arrow::array::builder::UInt64Builder, // getBeginLoc
  c3: arrow::array::builder::UInt64Builder, // getEndLoc
  c4: arrow::array::builder::UInt64Builder, // getReplacement
  c5: arrow::array::builder::UInt64Builder, // getAssociatedDecl
  c6: arrow::array::builder::UInt32Builder, // getIndex
  c7: arrow::array::builder::UInt64Builder, // getParameter
  c8: arrow::array::builder::BooleanBuilder, // isReferenceParameter
  writer: ParquetWriter,
}

impl TableBuilder329 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNameLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getReplacement", DataType::UInt64, false),
      Field::new("getAssociatedDecl", DataType::UInt64, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("getParameter", DataType::UInt64, false),
      Field::new("isReferenceParameter", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt32Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt32Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record329) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder330 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getAssociatedDecl
  c2: arrow::array::builder::UInt32Builder, // getIndex
  c3: arrow::array::builder::UInt64Builder, // getParameterPack
  c4: arrow::array::builder::UInt64Builder, // getParameterPackLocation
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder330 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getAssociatedDecl", DataType::UInt64, false),
      Field::new("getIndex", DataType::UInt32, false),
      Field::new("getParameterPack", DataType::UInt64, false),
      Field::new("getParameterPackLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt32Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt32Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record330) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder331 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder331 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record331) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder332 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder332 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record332) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder333 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getInitLoc
  c4: arrow::array::builder::UInt64Builder, // getSourceRange
  c5: arrow::array::builder::UInt64Builder, // getArrayFiller
  c6: arrow::array::builder::UInt64Builder, // getInitializedFieldInUnion
  writer: ParquetWriter,
}

impl TableBuilder333 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getInitLoc", DataType::UInt64, false),
      Field::new("getSourceRange", DataType::UInt64, false),
      Field::new("getArrayFiller", DataType::UInt64, false),
      Field::new("getInitializedFieldInUnion", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record333) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder334 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getConfig
  writer: ParquetWriter,
}

impl TableBuilder334 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getConfig", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record334) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder335 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCommonExpr
  c2: arrow::array::builder::UInt64Builder, // getOpaqueValue
  c3: arrow::array::builder::UInt64Builder, // getReadyExpr
  c4: arrow::array::builder::UInt64Builder, // getSuspendExpr
  c5: arrow::array::builder::UInt64Builder, // getResumeExpr
  c6: arrow::array::builder::UInt64Builder, // getOperand
  c7: arrow::array::builder::UInt64Builder, // getKeywordLoc
  c8: arrow::array::builder::UInt64Builder, // getBeginLoc
  c9: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder335 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCommonExpr", DataType::UInt64, false),
      Field::new("getOpaqueValue", DataType::UInt64, false),
      Field::new("getReadyExpr", DataType::UInt64, false),
      Field::new("getSuspendExpr", DataType::UInt64, false),
      Field::new("getResumeExpr", DataType::UInt64, false),
      Field::new("getOperand", DataType::UInt64, false),
      Field::new("getKeywordLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record335) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder336 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOpcode
  c2: arrow::array::builder::UInt64Builder, // getSubExpr
  c3: arrow::array::builder::UInt64Builder, // getOperatorLoc
  c4: arrow::array::builder::BooleanBuilder, // canOverflow
  c5: arrow::array::builder::BooleanBuilder, // isPrefix
  c6: arrow::array::builder::BooleanBuilder, // isPostfix
  c7: arrow::array::builder::BooleanBuilder, // isIncrementOp
  c8: arrow::array::builder::BooleanBuilder, // isDecrementOp
  c9: arrow::array::builder::BooleanBuilder, // isIncrementDecrementOp
  c10: arrow::array::builder::BooleanBuilder, // isArithmeticOp
  c11: arrow::array::builder::UInt64Builder, // getBeginLoc
  c12: arrow::array::builder::UInt64Builder, // getEndLoc
  c13: arrow::array::builder::UInt64Builder, // getExprLoc
  c14: arrow::array::builder::BooleanBuilder, // hasStoredFPFeatures
  writer: ParquetWriter,
}

impl TableBuilder336 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOpcode", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getOperatorLoc", DataType::UInt64, false),
      Field::new("canOverflow", DataType::Boolean, false),
      Field::new("isPrefix", DataType::Boolean, false),
      Field::new("isPostfix", DataType::Boolean, false),
      Field::new("isIncrementOp", DataType::Boolean, false),
      Field::new("isDecrementOp", DataType::Boolean, false),
      Field::new("isIncrementDecrementOp", DataType::Boolean, false),
      Field::new("isArithmeticOp", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getExprLoc", DataType::UInt64, false),
      Field::new("hasStoredFPFeatures", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::BooleanBuilder::new(),
      c8: arrow::array::builder::BooleanBuilder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::BooleanBuilder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::BooleanBuilder::new();
    self.c8 = arrow::array::builder::BooleanBuilder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::BooleanBuilder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record336) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder337 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getOperand
  c2: arrow::array::builder::UInt64Builder, // getOperatorCoawaitLookup
  c3: arrow::array::builder::UInt64Builder, // getKeywordLoc
  c4: arrow::array::builder::UInt64Builder, // getBeginLoc
  c5: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder337 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getOperand", DataType::UInt64, false),
      Field::new("getOperatorCoawaitLookup", DataType::UInt64, false),
      Field::new("getKeywordLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record337) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder338 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder338 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record338) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder339 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // idx
  c2: arrow::array::builder::UInt64Builder, // element
  writer: ParquetWriter,
}

impl TableBuilder339 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("idx", DataType::UInt64, false),
      Field::new("element", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record339) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder340 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCaptureDefault
  c2: arrow::array::builder::UInt64Builder, // getCaptureDefaultLoc
  c3: arrow::array::builder::UInt32Builder, // capture_size
  c4: arrow::array::builder::UInt64Builder, // getIntroducerRange
  c5: arrow::array::builder::UInt64Builder, // getLambdaClass
  c6: arrow::array::builder::UInt64Builder, // getCallOperator
  c7: arrow::array::builder::UInt64Builder, // getDependentCallOperator
  c8: arrow::array::builder::UInt64Builder, // getTrailingRequiresClause
  c9: arrow::array::builder::BooleanBuilder, // isGenericLambda
  c10: arrow::array::builder::UInt64Builder, // getBody
  c11: arrow::array::builder::UInt64Builder, // getCompoundStmtBody
  c12: arrow::array::builder::BooleanBuilder, // isMutable
  c13: arrow::array::builder::BooleanBuilder, // hasExplicitParameters
  c14: arrow::array::builder::BooleanBuilder, // hasExplicitResultType
  c15: arrow::array::builder::UInt64Builder, // getBeginLoc
  c16: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder340 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCaptureDefault", DataType::UInt64, false),
      Field::new("getCaptureDefaultLoc", DataType::UInt64, false),
      Field::new("capture_size", DataType::UInt32, false),
      Field::new("getIntroducerRange", DataType::UInt64, false),
      Field::new("getLambdaClass", DataType::UInt64, false),
      Field::new("getCallOperator", DataType::UInt64, false),
      Field::new("getDependentCallOperator", DataType::UInt64, false),
      Field::new("getTrailingRequiresClause", DataType::UInt64, false),
      Field::new("isGenericLambda", DataType::Boolean, false),
      Field::new("getBody", DataType::UInt64, false),
      Field::new("getCompoundStmtBody", DataType::UInt64, false),
      Field::new("isMutable", DataType::Boolean, false),
      Field::new("hasExplicitParameters", DataType::Boolean, false),
      Field::new("hasExplicitResultType", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt32Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::BooleanBuilder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::UInt64Builder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt32Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::BooleanBuilder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::UInt64Builder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record340) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder341 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt32Builder, // getNumObjects
  c2: arrow::array::builder::BooleanBuilder, // cleanupsHaveSideEffects
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder341 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getNumObjects", DataType::UInt32, false),
      Field::new("cleanupsHaveSideEffects", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt32Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt32Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record341) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder342 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getBeginLoc
  c2: arrow::array::builder::UInt64Builder, // getEndLoc
  c3: arrow::array::builder::UInt64Builder, // getLocation
  c4: arrow::array::builder::UInt64Builder, // getLParenLocation
  c5: arrow::array::builder::UInt64Builder, // getRParenLocation
  writer: ParquetWriter,
}

impl TableBuilder342 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getLParenLocation", DataType::UInt64, false),
      Field::new("getRParenLocation", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record342) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder343 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isGlobalDelete
  c2: arrow::array::builder::BooleanBuilder, // isArrayForm
  c3: arrow::array::builder::BooleanBuilder, // isArrayFormAsWritten
  c4: arrow::array::builder::BooleanBuilder, // doesUsualArrayDeleteWantSize
  c5: arrow::array::builder::UInt64Builder, // getOperatorDelete
  c6: arrow::array::builder::UInt64Builder, // getArgument
  c7: arrow::array::builder::UInt64Builder, // getDestroyedType
  c8: arrow::array::builder::UInt64Builder, // getBeginLoc
  c9: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder343 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isGlobalDelete", DataType::Boolean, false),
      Field::new("isArrayForm", DataType::Boolean, false),
      Field::new("isArrayFormAsWritten", DataType::Boolean, false),
      Field::new("doesUsualArrayDeleteWantSize", DataType::Boolean, false),
      Field::new("getOperatorDelete", DataType::UInt64, false),
      Field::new("getArgument", DataType::UInt64, false),
      Field::new("getDestroyedType", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record343) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder344 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCallee
  c2: arrow::array::builder::UInt64Builder, // getADLCallKind
  c3: arrow::array::builder::BooleanBuilder, // usesADL
  c4: arrow::array::builder::BooleanBuilder, // hasStoredFPFeatures
  c5: arrow::array::builder::UInt64Builder, // getCalleeDecl
  c6: arrow::array::builder::UInt64Builder, // getDirectCallee
  c7: arrow::array::builder::UInt32Builder, // getNumArgs
  c8: arrow::array::builder::UInt32Builder, // getBuiltinCallee
  c9: arrow::array::builder::UInt64Builder, // getRParenLoc
  c10: arrow::array::builder::UInt64Builder, // getBeginLoc
  c11: arrow::array::builder::UInt64Builder, // getEndLoc
  c12: arrow::array::builder::BooleanBuilder, // isCallToStdMove
  writer: ParquetWriter,
}

impl TableBuilder344 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCallee", DataType::UInt64, false),
      Field::new("getADLCallKind", DataType::UInt64, false),
      Field::new("usesADL", DataType::Boolean, false),
      Field::new("hasStoredFPFeatures", DataType::Boolean, false),
      Field::new("getCalleeDecl", DataType::UInt64, false),
      Field::new("getDirectCallee", DataType::UInt64, false),
      Field::new("getNumArgs", DataType::UInt32, false),
      Field::new("getBuiltinCallee", DataType::UInt32, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("isCallToStdMove", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt32Builder::new(),
      c8: arrow::array::builder::UInt32Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt32Builder::new();
    self.c8 = arrow::array::builder::UInt32Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record344) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder345 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getSubExpr
  c2: arrow::array::builder::UInt64Builder, // getStorageDuration
  c3: arrow::array::builder::UInt64Builder, // getLifetimeExtendedTemporaryDecl
  c4: arrow::array::builder::UInt64Builder, // getExtendingDecl
  c5: arrow::array::builder::UInt32Builder, // getManglingNumber
  c6: arrow::array::builder::BooleanBuilder, // isBoundToLvalueReference
  c7: arrow::array::builder::UInt64Builder, // getBeginLoc
  c8: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder345 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getStorageDuration", DataType::UInt64, false),
      Field::new("getLifetimeExtendedTemporaryDecl", DataType::UInt64, false),
      Field::new("getExtendingDecl", DataType::UInt64, false),
      Field::new("getManglingNumber", DataType::UInt32, false),
      Field::new("isBoundToLvalueReference", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt32Builder::new(),
      c6: arrow::array::builder::BooleanBuilder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt32Builder::new();
    self.c6 = arrow::array::builder::BooleanBuilder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record345) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder346 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::StringBuilder, // getBuiltinStr
  c2: arrow::array::builder::UInt64Builder, // getIdentKind
  c3: arrow::array::builder::BooleanBuilder, // isIntType
  c4: arrow::array::builder::UInt64Builder, // getLocation
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder346 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getBuiltinStr", DataType::Utf8, false),
      Field::new("getIdentKind", DataType::UInt64, false),
      Field::new("isIntType", DataType::Boolean, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::StringBuilder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::StringBuilder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record346) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder347 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // isImplicit
  writer: ParquetWriter,
}

impl TableBuilder347 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("isImplicit", DataType::Boolean, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
  }

  pub async fn push(&mut self, record: Record347) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder348 {
  c0: arrow::array::builder::UInt64Builder, // id
  writer: ParquetWriter,
}

impl TableBuilder348 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record348) -> Result<()> {
    self.c0.append_value(record.c0);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder349 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getKeywordLoc
  c2: arrow::array::builder::UInt64Builder, // getOperand
  c3: arrow::array::builder::UInt64Builder, // getPromiseCall
  c4: arrow::array::builder::BooleanBuilder, // isImplicit
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder349 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getKeywordLoc", DataType::UInt64, false),
      Field::new("getOperand", DataType::UInt64, false),
      Field::new("getPromiseCall", DataType::UInt64, false),
      Field::new("isImplicit", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record349) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder350 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCommonExpr
  c2: arrow::array::builder::UInt64Builder, // getSubExpr
  c3: arrow::array::builder::UInt64Builder, // getBeginLoc
  c4: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder350 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCommonExpr", DataType::UInt64, false),
      Field::new("getSubExpr", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record350) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder351 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getKeywordLoc
  c2: arrow::array::builder::BooleanBuilder, // isIfExists
  c3: arrow::array::builder::BooleanBuilder, // isIfNotExists
  c4: arrow::array::builder::UInt64Builder, // getSubStmt
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder351 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getKeywordLoc", DataType::UInt64, false),
      Field::new("isIfExists", DataType::Boolean, false),
      Field::new("isIfNotExists", DataType::Boolean, false),
      Field::new("getSubStmt", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record351) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder352 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::BooleanBuilder, // hasInitStorage
  c2: arrow::array::builder::BooleanBuilder, // hasVarStorage
  c3: arrow::array::builder::BooleanBuilder, // hasElseStorage
  c4: arrow::array::builder::UInt64Builder, // getCond
  c5: arrow::array::builder::UInt64Builder, // getThen
  c6: arrow::array::builder::UInt64Builder, // getElse
  c7: arrow::array::builder::UInt64Builder, // getConditionVariable
  c8: arrow::array::builder::UInt64Builder, // getConditionVariableDeclStmt
  c9: arrow::array::builder::UInt64Builder, // getInit
  c10: arrow::array::builder::UInt64Builder, // getIfLoc
  c11: arrow::array::builder::UInt64Builder, // getElseLoc
  c12: arrow::array::builder::BooleanBuilder, // isConsteval
  c13: arrow::array::builder::BooleanBuilder, // isNonNegatedConsteval
  c14: arrow::array::builder::BooleanBuilder, // isNegatedConsteval
  c15: arrow::array::builder::BooleanBuilder, // isConstexpr
  c16: arrow::array::builder::UInt64Builder, // getStatementKind
  c17: arrow::array::builder::BooleanBuilder, // isObjCAvailabilityCheck
  c18: arrow::array::builder::UInt64Builder, // getBeginLoc
  c19: arrow::array::builder::UInt64Builder, // getEndLoc
  c20: arrow::array::builder::UInt64Builder, // getLParenLoc
  c21: arrow::array::builder::UInt64Builder, // getRParenLoc
  writer: ParquetWriter,
}

impl TableBuilder352 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("hasInitStorage", DataType::Boolean, false),
      Field::new("hasVarStorage", DataType::Boolean, false),
      Field::new("hasElseStorage", DataType::Boolean, false),
      Field::new("getCond", DataType::UInt64, false),
      Field::new("getThen", DataType::UInt64, false),
      Field::new("getElse", DataType::UInt64, false),
      Field::new("getConditionVariable", DataType::UInt64, false),
      Field::new("getConditionVariableDeclStmt", DataType::UInt64, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getIfLoc", DataType::UInt64, false),
      Field::new("getElseLoc", DataType::UInt64, false),
      Field::new("isConsteval", DataType::Boolean, false),
      Field::new("isNonNegatedConsteval", DataType::Boolean, false),
      Field::new("isNegatedConsteval", DataType::Boolean, false),
      Field::new("isConstexpr", DataType::Boolean, false),
      Field::new("getStatementKind", DataType::UInt64, false),
      Field::new("isObjCAvailabilityCheck", DataType::Boolean, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::BooleanBuilder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::BooleanBuilder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::BooleanBuilder::new(),
      c13: arrow::array::builder::BooleanBuilder::new(),
      c14: arrow::array::builder::BooleanBuilder::new(),
      c15: arrow::array::builder::BooleanBuilder::new(),
      c16: arrow::array::builder::UInt64Builder::new(),
      c17: arrow::array::builder::BooleanBuilder::new(),
      c18: arrow::array::builder::UInt64Builder::new(),
      c19: arrow::array::builder::UInt64Builder::new(),
      c20: arrow::array::builder::UInt64Builder::new(),
      c21: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::BooleanBuilder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::BooleanBuilder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::BooleanBuilder::new();
    self.c13 = arrow::array::builder::BooleanBuilder::new();
    self.c14 = arrow::array::builder::BooleanBuilder::new();
    self.c15 = arrow::array::builder::BooleanBuilder::new();
    self.c16 = arrow::array::builder::UInt64Builder::new();
    self.c17 = arrow::array::builder::BooleanBuilder::new();
    self.c18 = arrow::array::builder::UInt64Builder::new();
    self.c19 = arrow::array::builder::UInt64Builder::new();
    self.c20 = arrow::array::builder::UInt64Builder::new();
    self.c21 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record352) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    self.c14.append_value(record.c14);
    self.c15.append_value(record.c15);
    self.c16.append_value(record.c16);
    self.c17.append_value(record.c17);
    self.c18.append_value(record.c18);
    self.c19.append_value(record.c19);
    self.c20.append_value(record.c20);
    self.c21.append_value(record.c21);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
        Arc::new(self.c14.finish()),
        Arc::new(self.c15.finish()),
        Arc::new(self.c16.finish()),
        Arc::new(self.c17.finish()),
        Arc::new(self.c18.finish()),
        Arc::new(self.c19.finish()),
        Arc::new(self.c20.finish()),
        Arc::new(self.c21.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder353 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getCallee
  c2: arrow::array::builder::UInt64Builder, // getLHS
  c3: arrow::array::builder::UInt64Builder, // getRHS
  c4: arrow::array::builder::BooleanBuilder, // isRightFold
  c5: arrow::array::builder::BooleanBuilder, // isLeftFold
  c6: arrow::array::builder::UInt64Builder, // getPattern
  c7: arrow::array::builder::UInt64Builder, // getInit
  c8: arrow::array::builder::UInt64Builder, // getLParenLoc
  c9: arrow::array::builder::UInt64Builder, // getRParenLoc
  c10: arrow::array::builder::UInt64Builder, // getEllipsisLoc
  c11: arrow::array::builder::UInt64Builder, // getOperator
  c12: arrow::array::builder::UInt64Builder, // getBeginLoc
  c13: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder353 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getCallee", DataType::UInt64, false),
      Field::new("getLHS", DataType::UInt64, false),
      Field::new("getRHS", DataType::UInt64, false),
      Field::new("isRightFold", DataType::Boolean, false),
      Field::new("isLeftFold", DataType::Boolean, false),
      Field::new("getPattern", DataType::UInt64, false),
      Field::new("getInit", DataType::UInt64, false),
      Field::new("getLParenLoc", DataType::UInt64, false),
      Field::new("getRParenLoc", DataType::UInt64, false),
      Field::new("getEllipsisLoc", DataType::UInt64, false),
      Field::new("getOperator", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::UInt64Builder::new(),
      c3: arrow::array::builder::UInt64Builder::new(),
      c4: arrow::array::builder::BooleanBuilder::new(),
      c5: arrow::array::builder::BooleanBuilder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
      c7: arrow::array::builder::UInt64Builder::new(),
      c8: arrow::array::builder::UInt64Builder::new(),
      c9: arrow::array::builder::UInt64Builder::new(),
      c10: arrow::array::builder::UInt64Builder::new(),
      c11: arrow::array::builder::UInt64Builder::new(),
      c12: arrow::array::builder::UInt64Builder::new(),
      c13: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::UInt64Builder::new();
    self.c3 = arrow::array::builder::UInt64Builder::new();
    self.c4 = arrow::array::builder::BooleanBuilder::new();
    self.c5 = arrow::array::builder::BooleanBuilder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
    self.c7 = arrow::array::builder::UInt64Builder::new();
    self.c8 = arrow::array::builder::UInt64Builder::new();
    self.c9 = arrow::array::builder::UInt64Builder::new();
    self.c10 = arrow::array::builder::UInt64Builder::new();
    self.c11 = arrow::array::builder::UInt64Builder::new();
    self.c12 = arrow::array::builder::UInt64Builder::new();
    self.c13 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record353) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    self.c7.append_value(record.c7);
    self.c8.append_value(record.c8);
    self.c9.append_value(record.c9);
    self.c10.append_value(record.c10);
    self.c11.append_value(record.c11);
    self.c12.append_value(record.c12);
    self.c13.append_value(record.c13);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
        Arc::new(self.c7.finish()),
        Arc::new(self.c8.finish()),
        Arc::new(self.c9.finish()),
        Arc::new(self.c10.finish()),
        Arc::new(self.c11.finish()),
        Arc::new(self.c12.finish()),
        Arc::new(self.c13.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

pub struct TableBuilder354 {
  c0: arrow::array::builder::UInt64Builder, // id
  c1: arrow::array::builder::UInt64Builder, // getRawSemantics
  c2: arrow::array::builder::BooleanBuilder, // isExact
  c3: arrow::array::builder::Float64Builder, // getValueAsApproximateDouble
  c4: arrow::array::builder::UInt64Builder, // getLocation
  c5: arrow::array::builder::UInt64Builder, // getBeginLoc
  c6: arrow::array::builder::UInt64Builder, // getEndLoc
  writer: ParquetWriter,
}

impl TableBuilder354 {
  fn schema() -> Arc<Schema> {
    Arc::new(Schema::new(vec![
      Field::new("id", DataType::UInt64, false),
      Field::new("getRawSemantics", DataType::UInt64, false),
      Field::new("isExact", DataType::Boolean, false),
      Field::new("getValueAsApproximateDouble", DataType::Float64, false),
      Field::new("getLocation", DataType::UInt64, false),
      Field::new("getBeginLoc", DataType::UInt64, false),
      Field::new("getEndLoc", DataType::UInt64, false),
    ]))
  }

  pub fn new(output_path: impl AsRef<Path>, partition_size: usize) -> Self {
    Self {
      c0: arrow::array::builder::UInt64Builder::new(),
      c1: arrow::array::builder::UInt64Builder::new(),
      c2: arrow::array::builder::BooleanBuilder::new(),
      c3: arrow::array::builder::Float64Builder::new(),
      c4: arrow::array::builder::UInt64Builder::new(),
      c5: arrow::array::builder::UInt64Builder::new(),
      c6: arrow::array::builder::UInt64Builder::new(),
        writer: ParquetWriter::new(output_path, partition_size, Self::schema()),
    }
  }

  pub fn reset(&mut self) {
    self.c0 = arrow::array::builder::UInt64Builder::new();
    self.c1 = arrow::array::builder::UInt64Builder::new();
    self.c2 = arrow::array::builder::BooleanBuilder::new();
    self.c3 = arrow::array::builder::Float64Builder::new();
    self.c4 = arrow::array::builder::UInt64Builder::new();
    self.c5 = arrow::array::builder::UInt64Builder::new();
    self.c6 = arrow::array::builder::UInt64Builder::new();
  }

  pub async fn push(&mut self, record: Record354) -> Result<()> {
    self.c0.append_value(record.c0);
    self.c1.append_value(record.c1);
    self.c2.append_value(record.c2);
    self.c3.append_value(record.c3);
    self.c4.append_value(record.c4);
    self.c5.append_value(record.c5);
    self.c6.append_value(record.c6);
    if self.writer.add_row() {
      self.flush().await?;
    }
    Ok(())
  }

  pub async fn flush(&mut self) -> Result<()> {
    let batch = RecordBatch::try_new(self.writer.schema.clone(), vec![
        Arc::new(self.c0.finish()),
        Arc::new(self.c1.finish()),
        Arc::new(self.c2.finish()),
        Arc::new(self.c3.finish()),
        Arc::new(self.c4.finish()),
        Arc::new(self.c5.finish()),
        Arc::new(self.c6.finish()),
    ], )?;
    self.writer.flush(batch).await?;
    self.reset();
    Ok(())
  }

  pub async fn cancel(&mut self) -> Result<()> {
    self.writer.cancel().await?;
    Ok(())
  }

}

////   END ARBORETUM GENERATED CODE ////
